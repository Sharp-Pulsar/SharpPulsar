{
  "api/index.html": {
    "href": "api/index.html",
    "title": "PLACEHOLDER | SharpPulsar",
    "keywords": "PLACEHOLDER TODO: Add .NET projects to the src folder and run docfx to generate REAL API Documentation!"
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Add your introductions here! | SharpPulsar",
    "keywords": "Add your introductions here!"
  },
  "commands/new-connect.html": {
    "href": "commands/new-connect.html",
    "title": "New Connect | SharpPulsar",
    "keywords": "New Connect [text] private static void SetFeatureFlags(FeatureFlags flags) { flags.SupportsAuthRefresh = true; flags.SupportsBrokerEntryMetadata = true; flags.SupportsPartialProducer = true; } [text] public static ReadOnlySequence<byte> NewConnect(string authMethodName, string authData, int protocolVersion, string libVersion, string targetBroker, string originalPrincipal, string originalAuthData, string originalAuthMethod) { var connect = new CommandConnect { ClientVersion = libVersion ?? \"Pulsar Client\", AuthMethodName = authMethodName, FeatureFlags = new FeatureFlags() }; if (\"ycav1\".Equals(authMethodName)) { // Handle the case of a client that gets updated before the broker and starts sending the string auth method // name. An example would be in broker-to-broker replication. We need to make sure the clients are still // passing both the enum and the string until all brokers are upgraded. connect.AuthMethod = AuthMethod.AuthMethodYcaV1; } if (!ReferenceEquals(targetBroker, null)) { // When connecting through a proxy, we need to specify which broker do we want to be proxied through connect.ProxyToBrokerUrl = targetBroker; } if (!ReferenceEquals(authData, null)) { connect.AuthData = ByteString.CopyFromUtf8(authData).ToByteArray(); } if (!ReferenceEquals(originalPrincipal, null)) { connect.OriginalPrincipal = originalPrincipal; } if (!ReferenceEquals(originalAuthData, null)) { connect.OriginalAuthData = originalAuthData; } if (!ReferenceEquals(originalAuthMethod, null)) { connect.OriginalAuthMethod = originalAuthMethod; } connect.ProtocolVersion = protocolVersion; SetFeatureFlags(connect.FeatureFlags); return Serializer.Serialize(connect.ToBaseCommand()); } [text] public ReadOnlySequence<byte> NewTcClientConnectRequest(long tcId, long requestId) { var tcClientConnect = new CommandTcClientConnectRequest { TcId = (ulong)tcId, RequestId = (ulong)requestId }; return Serializer.Serialize(tcClientConnect.ToBaseCommand()); } [text] public ReadOnlySequence<byte> NewConnect(string authMethodName, AuthData authData, int protocolVersion, string libVersion, string targetBroker, string originalPrincipal, AuthData originalAuthData, string originalAuthMethod) { var connect = new CommandConnect { ClientVersion = libVersion, AuthMethodName = authMethodName, FeatureFlags = new FeatureFlags(), ProtocolVersion = protocolVersion }; if (!string.IsNullOrWhiteSpace(targetBroker)) { // When connecting through a proxy, we need to specify which broker do we want to be proxied through connect.ProxyToBrokerUrl = targetBroker; } if (authData != null) { connect.AuthData = authData.auth_data; } if (!string.IsNullOrWhiteSpace(originalPrincipal)) { connect.OriginalPrincipal = originalPrincipal; } if (originalAuthData != null) { connect.OriginalAuthData = Encoding.UTF8.GetString(originalAuthData.auth_data); } if (!string.IsNullOrWhiteSpace(originalAuthMethod)) { connect.OriginalAuthMethod = originalAuthMethod; } SetFeatureFlags(connect.FeatureFlags); var ba = connect.ToBaseCommand(); return Serializer.Serialize(ba); }"
  },
  "index.html": {
    "href": "index.html",
    "title": "Quick Start | SharpPulsar",
    "keywords": "Quick Start Build your technical documentation site with docfx. Converts .NET assembly, XML code comment, REST API Swagger files and markdown into rendered HTML pages, JSON model or PDF files. Create a New Website In this section we will build a simple documentation site on your local machine. Prerequisites Familiarity with the command line Install .NET SDK 6.0 or higher Make sure you have .NET SDK installed, then open a terminal and enter the following command to install the latest docfx: dotnet tool update -g docfx To create a new docset, run: docfx init --quiet This command creates a new docset under the docfx_project directory. To build the docset, run: docfx docfx_project/docfx.json --serve Now you can preview the website on http://localhost:8080. To preview your local changes, save changes then run this command in a new terminal to rebuild the website: docfx docfx_project/docfx.json Publish to GitHub Pages Docfx produces static HTML files under the _site folder ready for publishing to any static site hosting servers. To publish to GitHub Pages: Enable GitHub Pages. Upload _site folder to GitHub Pages using GitHub actions. This example uses peaceiris/actions-gh-pages to publish to the gh-pages branch: # Your GitHub workflow file under .github/workflows/ jobs: publish-docs: runs-on: ubuntu-latest steps: - name: Chekout uses: actions/checkout@v3 - name: Dotnet Setup uses: actions/setup-dotnet@v3 with: dotnet-version: 7.x - run: dotnet tool update -g docfx - run: docfx docfx_project/docfx.json - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: docs/_site Use the NuGet Library You can also use docfx as a NuGet library: <PackageReference Include=\"Microsoft.DocAsCode.App\" Version=\"2.60.0\" /> Then build a docset using: await Microsoft.DocAsCode.Docset.Build(\"docfx.json\"); See API References for additional APIs. Next Steps Write Articles Organize Contents Configure Website Add .NET API Docs"
  }
}