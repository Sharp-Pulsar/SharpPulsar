//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"

namespace SharpPulsar.Admin.v2
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial interface IPulsarAdminRESTAPIClient
    {
        /// <summary>
        /// Gets raw information for all the bookies in the cluster
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BookiesClusterInfo> GetAllBookiesAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets raw information for all the bookies in the cluster
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BookiesClusterInfo> GetAllBookiesAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Gets the rack placement information for all the bookies in the cluster
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, System.Collections.Generic.IDictionary<string, BookieInfo>>> GetBookiesRackInfoAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets the rack placement information for all the bookies in the cluster
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, System.Collections.Generic.IDictionary<string, BookieInfo>>> GetBookiesRackInfoAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Gets the rack placement information for a specific bookie in the cluster
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BookieInfo> GetBookieRackInfoAsync(string bookie);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets the rack placement information for a specific bookie in the cluster
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BookieInfo> GetBookieRackInfoAsync(string bookie, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Updates the rack placement information for a specific bookie in the cluster (note. bookie address format:`address:port`)
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateBookieRackInfoAsync(string bookie, string group);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates the rack placement information for a specific bookie in the cluster (note. bookie address format:`address:port`)
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateBookieRackInfoAsync(string bookie, string group, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Removed the rack placement information for a specific bookie in the cluster
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteBookieRackInfoAsync(string bookie);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Removed the rack placement information for a specific bookie in the cluster
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteBookieRackInfoAsync(string bookie, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the stats for the Netty allocator. Available allocators are 'default' and 'ml-cache'
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AllocatorStats> GetAllocatorStatsAsync(string allocator);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the stats for the Netty allocator. Available allocators are 'default' and 'ml-cache'
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AllocatorStats> GetAllocatorStatsAsync(string allocator, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get pending bookie client op stats by namespace
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, PendingBookieOpsStats>> GetPendingBookieOpsStatsAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get pending bookie client op stats by namespace
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, PendingBookieOpsStats>> GetPendingBookieOpsStatsAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Broker availability report
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, ResourceUnit>> GetBrokerResourceAvailabilityAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Broker availability report
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, ResourceUnit>> GetBrokerResourceAvailabilityAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get Load for this broker
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<LoadReport> GetLoadReportAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get Load for this broker
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<LoadReport> GetLoadReportAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get all the mbean details of this broker JVM
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Metrics>> GetMBeansAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get all the mbean details of this broker JVM
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Metrics>> GetMBeansAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Gets the metrics for Monitoring
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Metrics>> GetMetricsAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets the metrics for Monitoring
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Metrics>> GetMetricsAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get all the topic stats by namespace
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<OutputStream> GetTopics2Async();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get all the topic stats by namespace
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<OutputStream> GetTopics2Async(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the list of active brokers (web service addresses) in the local cluster.If authorization is not enabled
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetActiveBrokersAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of active brokers (web service addresses) in the local cluster.If authorization is not enabled
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetActiveBrokersAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// An REST endpoint to trigger backlogQuotaCheck
        /// </summary>
        /// <returns>Everything is OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task BacklogQuotaCheckAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// An REST endpoint to trigger backlogQuotaCheck
        /// </summary>
        /// <returns>Everything is OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task BacklogQuotaCheckAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get all updatable dynamic configurations's name
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDynamicConfigurationNameAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get all updatable dynamic configurations's name
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDynamicConfigurationNameAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get all runtime configurations. This operation requires Pulsar super-user privileges.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetRuntimeConfigurationAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get all runtime configurations. This operation requires Pulsar super-user privileges.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetRuntimeConfigurationAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get value of all dynamic configurations' value overridden on local config
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetAllDynamicConfigurationsAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get value of all dynamic configurations' value overridden on local config
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetAllDynamicConfigurationsAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete dynamic ServiceConfiguration into metadata only. This operation requires Pulsar super-user privileges.
        /// </summary>
        /// <returns>Service configuration updated successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteDynamicConfigurationAsync(string configName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete dynamic ServiceConfiguration into metadata only. This operation requires Pulsar super-user privileges.
        /// </summary>
        /// <returns>Service configuration updated successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteDynamicConfigurationAsync(string configName, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Update dynamic serviceconfiguration into zk only. This operation requires Pulsar super-user privileges.
        /// </summary>
        /// <returns>Service configuration updated successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateDynamicConfigurationAsync(string configName, string configValue);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update dynamic serviceconfiguration into zk only. This operation requires Pulsar super-user privileges.
        /// </summary>
        /// <returns>Service configuration updated successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateDynamicConfigurationAsync(string configName, string configValue, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Run a healthCheck against the broker
        /// </summary>
        /// <returns>Everything is OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task HealthCheckAsync(TopicVersion? topicVersion);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Run a healthCheck against the broker
        /// </summary>
        /// <returns>Everything is OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task HealthCheckAsync(TopicVersion? topicVersion, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the internal configuration data
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<InternalConfigurationData> GetInternalConfigurationDataAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the internal configuration data
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<InternalConfigurationData> GetInternalConfigurationDataAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the information of the leader broker.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BrokerInfo> GetLeaderBrokerAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the information of the leader broker.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BrokerInfo> GetLeaderBrokerAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Check if the broker is fully initialized
        /// </summary>
        /// <returns>Broker is ready</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task IsReadyAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Check if the broker is fully initialized
        /// </summary>
        /// <returns>Broker is ready</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task IsReadyAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Shutdown broker gracefully.
        /// </summary>
        /// <param name="maxConcurrentUnloadPerSec">if the value absent(value=0) means no concurrent limitation.</param>
        /// <returns>Execute shutdown command successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ShutDownBrokerGracefullyAsync(int? maxConcurrentUnloadPerSec, bool? forcedTerminateTopic);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Shutdown broker gracefully.
        /// </summary>
        /// <param name="maxConcurrentUnloadPerSec">if the value absent(value=0) means no concurrent limitation.</param>
        /// <returns>Execute shutdown command successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ShutDownBrokerGracefullyAsync(int? maxConcurrentUnloadPerSec, bool? forcedTerminateTopic, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get version of current broker
        /// </summary>
        /// <returns>Everything is OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> VersionAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get version of current broker
        /// </summary>
        /// <returns>Everything is OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> VersionAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the list of namespaces served by the specific broker
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, NamespaceOwnershipStatus>> GetOwnedNamespacesAsync(string clusterName, string broker_webserviceurl);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of namespaces served by the specific broker
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, NamespaceOwnershipStatus>> GetOwnedNamespacesAsync(string clusterName, string broker_webserviceurl, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the list of active brokers (web service addresses) in the cluster.If authorization is not enabled, any cluster name is valid.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetActiveBrokers2Async(string cluster);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of active brokers (web service addresses) in the cluster.If authorization is not enabled, any cluster name is valid.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetActiveBrokers2Async(string cluster, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the list of all the Pulsar clusters.
        /// </summary>
        /// <returns>Return a list of clusters.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetClustersAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of all the Pulsar clusters.
        /// </summary>
        /// <returns>Return a list of clusters.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetClustersAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the configuration for the specified cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>Return the cluster data.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ClusterData> GetClusterAsync(string cluster);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the configuration for the specified cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>Return the cluster data.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ClusterData> GetClusterAsync(string cluster, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Update the configuration for a cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="body">The cluster data</param>
        /// <returns>Cluster has been updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateClusterAsync(string cluster, ClusterData body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update the configuration for a cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="body">The cluster data</param>
        /// <returns>Cluster has been updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateClusterAsync(string cluster, ClusterData body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Create a new cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="body">The cluster data</param>
        /// <returns>Cluster has been created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreateClusterAsync(string cluster, ClusterData body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a new cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="body">The cluster data</param>
        /// <returns>Cluster has been created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreateClusterAsync(string cluster, ClusterData body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete an existing cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>Cluster has been deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteClusterAsync(string cluster);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete an existing cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>Cluster has been deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteClusterAsync(string cluster, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the cluster failure domains.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, FailureDomain>> GetFailureDomainsAsync(string cluster);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the cluster failure domains.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, FailureDomain>> GetFailureDomainsAsync(string cluster, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get a domain in a cluster
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="domainName">The failure domain name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FailureDomain> GetDomainAsync(string cluster, string domainName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get a domain in a cluster
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="domainName">The failure domain name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FailureDomain> GetDomainAsync(string cluster, string domainName, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set the failure domain of the cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="domainName">The failure domain name</param>
        /// <param name="body">The configuration data of a failure domain</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetFailureDomainAsync(string cluster, string domainName, FailureDomain body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set the failure domain of the cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="domainName">The failure domain name</param>
        /// <param name="body">The configuration data of a failure domain</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetFailureDomainAsync(string cluster, string domainName, FailureDomain body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete the failure domain of the cluster
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="domainName">The failure domain name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteFailureDomainAsync(string cluster, string domainName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete the failure domain of the cluster
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="domainName">The failure domain name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteFailureDomainAsync(string cluster, string domainName, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the namespace isolation policies assigned to the cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, NamespaceIsolationData>> GetNamespaceIsolationPoliciesAsync(string cluster);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the namespace isolation policies assigned to the cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, NamespaceIsolationData>> GetNamespaceIsolationPoliciesAsync(string cluster, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get list of brokers with namespace-isolation policies attached to them.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<BrokerNamespaceIsolationData>> GetBrokersWithNamespaceIsolationPolicyAsync(string cluster);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get list of brokers with namespace-isolation policies attached to them.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<BrokerNamespaceIsolationData>> GetBrokersWithNamespaceIsolationPolicyAsync(string cluster, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get a broker with namespace-isolation policies attached to it.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="broker">The broker name (&lt;broker-hostname&gt;:&lt;web-service-port&gt;)</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BrokerNamespaceIsolationData> GetBrokerWithNamespaceIsolationPolicyAsync(string cluster, string broker);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get a broker with namespace-isolation policies attached to it.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="broker">The broker name (&lt;broker-hostname&gt;:&lt;web-service-port&gt;)</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BrokerNamespaceIsolationData> GetBrokerWithNamespaceIsolationPolicyAsync(string cluster, string broker, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the single namespace isolation policy assigned to the cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="policyName">The name of the namespace isolation policy</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<NamespaceIsolationData> GetNamespaceIsolationPolicyAsync(string cluster, string policyName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the single namespace isolation policy assigned to the cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="policyName">The name of the namespace isolation policy</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<NamespaceIsolationData> GetNamespaceIsolationPolicyAsync(string cluster, string policyName, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set namespace isolation policy.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="policyName">The namespace isolation policy name</param>
        /// <param name="body">The namespace isolation policy data</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetNamespaceIsolationPolicyAsync(string cluster, string policyName, NamespaceIsolationData body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set namespace isolation policy.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="policyName">The namespace isolation policy name</param>
        /// <param name="body">The namespace isolation policy data</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetNamespaceIsolationPolicyAsync(string cluster, string policyName, NamespaceIsolationData body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete namespace isolation policy.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="policyName">The namespace isolation policy name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteNamespaceIsolationPolicyAsync(string cluster, string policyName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete namespace isolation policy.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="policyName">The namespace isolation policy name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteNamespaceIsolationPolicyAsync(string cluster, string policyName, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the peer-cluster data for the specified cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetPeerClusterAsync(string cluster);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the peer-cluster data for the specified cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetPeerClusterAsync(string cluster, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Update peer-cluster-list for a cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="body">The list of peer cluster names</param>
        /// <returns>Cluster has been updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetPeerClusterNamesAsync(string cluster, System.Collections.Generic.IEnumerable<string> body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update peer-cluster-list for a cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="body">The list of peer cluster names</param>
        /// <returns>Cluster has been updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetPeerClusterNamesAsync(string cluster, System.Collections.Generic.IEnumerable<string> body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get all namespaces that are grouped by given anti-affinity group in a given cluster. api can be only accessed by admin of any of the existing tenant
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetAntiAffinityNamespacesAsync(string cluster, string group, string tenant);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get all namespaces that are grouped by given anti-affinity group in a given cluster. api can be only accessed by admin of any of the existing tenant
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetAntiAffinityNamespacesAsync(string cluster, string group, string tenant, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the bookie-affinity-group from namespace-local policy.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BookieAffinityGroupData> GetBookieAffinityGroupAsync(string property, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the bookie-affinity-group from namespace-local policy.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BookieAffinityGroupData> GetBookieAffinityGroupAsync(string property, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete the bookie-affinity-group from namespace-local policy.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteBookieAffinityGroupAsync(string property, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete the bookie-affinity-group from namespace-local policy.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteBookieAffinityGroupAsync(string property, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the list of all the namespaces for a certain tenant.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetTenantNamespacesAsync(string tenant);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of all the namespaces for a certain tenant.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetTenantNamespacesAsync(string tenant, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the dump all the policies specified for a namespace.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Policies> GetPoliciesAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the dump all the policies specified for a namespace.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Policies> GetPoliciesAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Creates a new namespace with the specified policies
        /// </summary>
        /// <param name="body">Policies for the namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreateNamespaceAsync(string tenant, string @namespace, Policies body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates a new namespace with the specified policies
        /// </summary>
        /// <param name="body">Policies for the namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreateNamespaceAsync(string tenant, string @namespace, Policies body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete a namespace and all the topics under it.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteNamespaceAsync(string tenant, string @namespace, bool? force, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a namespace and all the topics under it.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteNamespaceAsync(string tenant, string @namespace, bool? force, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get anti-affinity group of a namespace.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> GetNamespaceAntiAffinityGroupAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get anti-affinity group of a namespace.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> GetNamespaceAntiAffinityGroupAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set anti-affinity group for a namespace
        /// </summary>
        /// <param name="body">Anti-affinity group for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetNamespaceAntiAffinityGroupAsync(string tenant, string @namespace, string body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set anti-affinity group for a namespace
        /// </summary>
        /// <param name="body">Anti-affinity group for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetNamespaceAntiAffinityGroupAsync(string tenant, string @namespace, string body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove anti-affinity group of a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveNamespaceAntiAffinityGroupAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove anti-affinity group of a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveNamespaceAntiAffinityGroupAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get autoSubscriptionCreation info in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetAutoSubscriptionCreationAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get autoSubscriptionCreation info in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetAutoSubscriptionCreationAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Override broker's allowAutoSubscriptionCreation setting for a namespace
        /// </summary>
        /// <param name="body">Settings for automatic subscription creation</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetAutoSubscriptionCreationAsync(string tenant, string @namespace, AutoSubscriptionCreationOverride body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Override broker's allowAutoSubscriptionCreation setting for a namespace
        /// </summary>
        /// <param name="body">Settings for automatic subscription creation</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetAutoSubscriptionCreationAsync(string tenant, string @namespace, AutoSubscriptionCreationOverride body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove override of broker's allowAutoSubscriptionCreation in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveAutoSubscriptionCreationAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove override of broker's allowAutoSubscriptionCreation in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveAutoSubscriptionCreationAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get autoTopicCreation info in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetAutoTopicCreationAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get autoTopicCreation info in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetAutoTopicCreationAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Override broker's allowAutoTopicCreation setting for a namespace
        /// </summary>
        /// <param name="body">Settings for automatic topic creation</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetAutoTopicCreationAsync(string tenant, string @namespace, AutoTopicCreationOverride body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Override broker's allowAutoTopicCreation setting for a namespace
        /// </summary>
        /// <param name="body">Settings for automatic topic creation</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetAutoTopicCreationAsync(string tenant, string @namespace, AutoTopicCreationOverride body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove override of broker's allowAutoTopicCreation in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveAutoTopicCreationAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove override of broker's allowAutoTopicCreation in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveAutoTopicCreationAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set a backlog quota for all the topics on a namespace.
        /// </summary>
        /// <param name="body">Backlog quota for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetBacklogQuotaAsync(string tenant, string @namespace, BacklogQuotaType? backlogQuotaType, BacklogQuota body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set a backlog quota for all the topics on a namespace.
        /// </summary>
        /// <param name="body">Backlog quota for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetBacklogQuotaAsync(string tenant, string @namespace, BacklogQuotaType? backlogQuotaType, BacklogQuota body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove a backlog quota policy from a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveBacklogQuotaAsync(string tenant, string @namespace, BacklogQuotaType2? backlogQuotaType);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove a backlog quota policy from a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveBacklogQuotaAsync(string tenant, string @namespace, BacklogQuotaType2? backlogQuotaType, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get backlog quota map on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetBacklogQuotaMapAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get backlog quota map on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetBacklogQuotaMapAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the bundles split data.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetBundlesDataAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the bundles split data.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetBundlesDataAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Clear backlog for all topics on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ClearNamespaceBacklogAsync(string tenant, string @namespace, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Clear backlog for all topics on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ClearNamespaceBacklogAsync(string tenant, string @namespace, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Clear backlog for a given subscription on all topics on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ClearNamespaceBacklogForSubscriptionAsync(string tenant, string @namespace, string subscription, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Clear backlog for a given subscription on all topics on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ClearNamespaceBacklogForSubscriptionAsync(string tenant, string @namespace, string subscription, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Maximum number of uncompacted bytes in topics before compaction is triggered.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetCompactionThresholdAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Maximum number of uncompacted bytes in topics before compaction is triggered.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetCompactionThresholdAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set maximum number of uncompacted bytes in a topic before compaction is triggered.
        /// </summary>
        /// <param name="body">Maximum number of uncompacted bytes in a topic of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetCompactionThresholdPUTAsync(string tenant, string @namespace, long body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maximum number of uncompacted bytes in a topic before compaction is triggered.
        /// </summary>
        /// <param name="body">Maximum number of uncompacted bytes in a topic of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetCompactionThresholdPUTAsync(string tenant, string @namespace, long body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete maximum number of uncompacted bytes in a topic before compaction is triggered.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteCompactionThresholdAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete maximum number of uncompacted bytes in a topic before compaction is triggered.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteCompactionThresholdAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get broker side deduplication for all topics in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDeduplicationAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get broker side deduplication for all topics in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDeduplicationAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Enable or disable broker side deduplication for all topics in a namespace
        /// </summary>
        /// <param name="body">Flag for disabling or enabling broker side deduplication for all topics in the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ModifyDeduplicationAsync(string tenant, string @namespace, bool body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Enable or disable broker side deduplication for all topics in a namespace
        /// </summary>
        /// <param name="body">Flag for disabling or enabling broker side deduplication for all topics in the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ModifyDeduplicationAsync(string tenant, string @namespace, bool body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove broker side deduplication for all topics in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveDeduplicationAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove broker side deduplication for all topics in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveDeduplicationAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get deduplicationSnapshotInterval config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDeduplicationSnapshotIntervalAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get deduplicationSnapshotInterval config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDeduplicationSnapshotIntervalAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set deduplicationSnapshotInterval config on a namespace.
        /// </summary>
        /// <param name="body">Interval to take deduplication snapshot per topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDeduplicationSnapshotIntervalAsync(string tenant, string @namespace, int body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set deduplicationSnapshotInterval config on a namespace.
        /// </summary>
        /// <param name="body">Interval to take deduplication snapshot per topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDeduplicationSnapshotIntervalAsync(string tenant, string @namespace, int body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get delayed delivery messages config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDelayedDeliveryPoliciesAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get delayed delivery messages config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDelayedDeliveryPoliciesAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set delayed delivery messages config on a namespace.
        /// </summary>
        /// <param name="body">Delayed delivery policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDelayedDeliveryPoliciesAsync(string tenant, string @namespace, DelayedDeliveryPolicies body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set delayed delivery messages config on a namespace.
        /// </summary>
        /// <param name="body">Delayed delivery policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDelayedDeliveryPoliciesAsync(string tenant, string @namespace, DelayedDeliveryPolicies body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete delayed delivery messages config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveDelayedDeliveryPoliciesAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete delayed delivery messages config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveDelayedDeliveryPoliciesAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get dispatch-rate configured for the namespace, null means dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDispatchRateAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get dispatch-rate configured for the namespace, null means dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDispatchRateAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <param name="body">Dispatch rate for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDispatchRateAsync(string tenant, string @namespace, DispatchRateImpl body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <param name="body">Dispatch rate for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDispatchRateAsync(string tenant, string @namespace, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteDispatchRateAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteDispatchRateAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get message encryption required status in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetEncryptionRequiredAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get message encryption required status in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetEncryptionRequiredAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Message encryption is required or not for all topics in a namespace
        /// </summary>
        /// <param name="body">Flag defining if message encryption is required</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ModifyEncryptionRequiredAsync(string tenant, string @namespace, bool body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Message encryption is required or not for all topics in a namespace
        /// </summary>
        /// <param name="body">Flag defining if message encryption is required</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ModifyEncryptionRequiredAsync(string tenant, string @namespace, bool body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get maxConsumersPerSubscription config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetEntryFiltersPerTopicAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxConsumersPerSubscription config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetEntryFiltersPerTopicAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set entry filters for namespace
        /// </summary>
        /// <param name="body">entry filters</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetEntryFiltersPerTopicAsync(string tenant, string @namespace, EntryFilters body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set entry filters for namespace
        /// </summary>
        /// <param name="body">entry filters</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetEntryFiltersPerTopicAsync(string tenant, string @namespace, EntryFilters body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove entry filters for namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveNamespaceEntryFiltersAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove entry filters for namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveNamespaceEntryFiltersAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get inactive topic policies config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetInactiveTopicPoliciesAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get inactive topic policies config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetInactiveTopicPoliciesAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set inactive topic policies config on a namespace.
        /// </summary>
        /// <param name="body">Inactive topic policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetInactiveTopicPoliciesPOSTAsync(string tenant, string @namespace, InactiveTopicPolicies body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set inactive topic policies config on a namespace.
        /// </summary>
        /// <param name="body">Inactive topic policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetInactiveTopicPoliciesPOSTAsync(string tenant, string @namespace, InactiveTopicPolicies body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove inactive topic policies from a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveInactiveTopicPoliciesAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove inactive topic policies from a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveInactiveTopicPoliciesAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// The flag of whether allow auto update schema
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetIsAllowAutoUpdateSchemaAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// The flag of whether allow auto update schema
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetIsAllowAutoUpdateSchemaAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Update flag of whether allow auto update schema
        /// </summary>
        /// <param name="body">Flag of whether to allow auto update schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetIsAllowAutoUpdateSchemaAsync(string tenant, string @namespace, bool body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update flag of whether allow auto update schema
        /// </summary>
        /// <param name="body">Flag of whether to allow auto update schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetIsAllowAutoUpdateSchemaAsync(string tenant, string @namespace, bool body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get maxConsumersPerSubscription config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxConsumersPerSubscriptionAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxConsumersPerSubscription config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxConsumersPerSubscriptionAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set maxConsumersPerSubscription configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum consumers per subscription</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxConsumersPerSubscriptionAsync(string tenant, string @namespace, int body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxConsumersPerSubscription configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum consumers per subscription</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxConsumersPerSubscriptionAsync(string tenant, string @namespace, int body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set maxConsumersPerSubscription configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxConsumersPerSubscriptionAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxConsumersPerSubscription configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxConsumersPerSubscriptionAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get maxConsumersPerTopic config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxConsumersPerTopicAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxConsumersPerTopic config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxConsumersPerTopicAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set maxConsumersPerTopic configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum consumers per topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxConsumersPerTopicAsync(string tenant, string @namespace, int body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxConsumersPerTopic configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum consumers per topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxConsumersPerTopicAsync(string tenant, string @namespace, int body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove maxConsumersPerTopic configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxConsumersPerTopicAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxConsumersPerTopic configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxConsumersPerTopicAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get maxProducersPerTopic config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxProducersPerTopicAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxProducersPerTopic config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxProducersPerTopicAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set maxProducersPerTopic configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum producers per topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxProducersPerTopicAsync(string tenant, string @namespace, int body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxProducersPerTopic configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum producers per topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxProducersPerTopicAsync(string tenant, string @namespace, int body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove maxProducersPerTopic configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxProducersPerTopicAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxProducersPerTopic configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxProducersPerTopicAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get maxSubscriptionsPerTopic config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxSubscriptionsPerTopicAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxSubscriptionsPerTopic config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxSubscriptionsPerTopicAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set maxSubscriptionsPerTopic configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum subscriptions per topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxSubscriptionsPerTopicAsync(string tenant, string @namespace, int body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxSubscriptionsPerTopic configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum subscriptions per topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxSubscriptionsPerTopicAsync(string tenant, string @namespace, int body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove maxSubscriptionsPerTopic configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxSubscriptionsPerTopicAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxSubscriptionsPerTopic configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxSubscriptionsPerTopicAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get maxTopicsPerNamespace config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxTopicsPerNamespaceAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxTopicsPerNamespace config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxTopicsPerNamespaceAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set maxTopicsPerNamespace config on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum topics for specific namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetInactiveTopicPoliciesPOST2Async(string tenant, string @namespace, int body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxTopicsPerNamespace config on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum topics for specific namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetInactiveTopicPoliciesPOST2Async(string tenant, string @namespace, int body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set maxTopicsPerNamespace config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetInactiveTopicPoliciesDELETEAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxTopicsPerNamespace config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetInactiveTopicPoliciesDELETEAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get maxUnackedMessagesPerConsumer config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxUnackedMessagesPerConsumerAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxUnackedMessagesPerConsumer config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxUnackedMessagesPerConsumerAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set maxConsumersPerTopic configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum unacked messages per consumer</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxUnackedMessagesPerConsumerAsync(string tenant, string @namespace, int body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxConsumersPerTopic configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum unacked messages per consumer</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxUnackedMessagesPerConsumerAsync(string tenant, string @namespace, int body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove maxUnackedMessagesPerConsumer config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxUnackedmessagesPerConsumerAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxUnackedMessagesPerConsumer config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxUnackedmessagesPerConsumerAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get maxUnackedMessagesPerSubscription config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxUnackedmessagesPerSubscriptionAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxUnackedMessagesPerSubscription config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxUnackedmessagesPerSubscriptionAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set maxUnackedMessagesPerSubscription configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum unacked messages per subscription</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxUnackedMessagesPerSubscriptionAsync(string tenant, string @namespace, int body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxUnackedMessagesPerSubscription configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum unacked messages per subscription</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxUnackedMessagesPerSubscriptionAsync(string tenant, string @namespace, int body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove maxUnackedMessagesPerSubscription config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxUnackedmessagesPerSubscriptionAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxUnackedMessagesPerSubscription config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxUnackedmessagesPerSubscriptionAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the message TTL for the namespace
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<int> GetNamespaceMessageTTLAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the message TTL for the namespace
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<int> GetNamespaceMessageTTLAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set message TTL in seconds for namespace
        /// </summary>
        /// <param name="body">TTL in seconds for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetNamespaceMessageTTLAsync(string tenant, string @namespace, int body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set message TTL in seconds for namespace
        /// </summary>
        /// <param name="body">TTL in seconds for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetNamespaceMessageTTLAsync(string tenant, string @namespace, int body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove message TTL in seconds for namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveNamespaceMessageTTLAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove message TTL in seconds for namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveNamespaceMessageTTLAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Number of milliseconds to wait before deleting a ledger segment which has been offloaded from the Pulsar cluster's local storage (i.e. BookKeeper)
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetOffloadDeletionLagAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Number of milliseconds to wait before deleting a ledger segment which has been offloaded from the Pulsar cluster's local storage (i.e. BookKeeper)
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetOffloadDeletionLagAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set number of milliseconds to wait before deleting a ledger segment which has been offloaded from the Pulsar cluster's local storage (i.e. BookKeeper)
        /// </summary>
        /// <param name="body">New number of milliseconds to wait before deleting a ledger segment which has been offloaded</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetOffloadDeletionLagAsync(string tenant, string @namespace, long body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set number of milliseconds to wait before deleting a ledger segment which has been offloaded from the Pulsar cluster's local storage (i.e. BookKeeper)
        /// </summary>
        /// <param name="body">New number of milliseconds to wait before deleting a ledger segment which has been offloaded</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetOffloadDeletionLagAsync(string tenant, string @namespace, long body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Clear the namespace configured offload deletion lag. The topics in the namespace will fallback to using the default configured deletion lag for the broker
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ClearOffloadDeletionLagAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Clear the namespace configured offload deletion lag. The topics in the namespace will fallback to using the default configured deletion lag for the broker
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ClearOffloadDeletionLagAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get offload configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetOffloadPoliciesAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get offload configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetOffloadPoliciesAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set offload configuration on a namespace.
        /// </summary>
        /// <param name="body">Offload policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetOffloadPoliciesAsync(string tenant, string @namespace, OffloadPoliciesImpl body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set offload configuration on a namespace.
        /// </summary>
        /// <param name="body">Offload policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetOffloadPoliciesAsync(string tenant, string @namespace, OffloadPoliciesImpl body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Maximum number of bytes stored on the pulsar cluster for a topic, before the broker will start offloading to longterm storage
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetOffloadThresholdAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Maximum number of bytes stored on the pulsar cluster for a topic, before the broker will start offloading to longterm storage
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetOffloadThresholdAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set maximum number of bytes stored on the pulsar cluster for a topic, before the broker will start offloading to longterm storage
        /// </summary>
        /// <param name="body">Maximum number of bytes stored on the pulsar cluster for a topic of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetOffloadThresholdAsync(string tenant, string @namespace, long body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maximum number of bytes stored on the pulsar cluster for a topic, before the broker will start offloading to longterm storage
        /// </summary>
        /// <param name="body">Maximum number of bytes stored on the pulsar cluster for a topic of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetOffloadThresholdAsync(string tenant, string @namespace, long body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Retrieve the permissions for a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPermissionsAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Retrieve the permissions for a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPermissionsAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Retrieve the permissions for a subscription.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPermissionOnSubscriptionAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Retrieve the permissions for a subscription.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPermissionOnSubscriptionAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Grant a new permission to a role on a namespace.
        /// </summary>
        /// <param name="body">List of permissions for the specified role</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GrantPermissionOnNamespaceAsync(string tenant, string @namespace, string role, System.Collections.Generic.IEnumerable<Anonymous> body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Grant a new permission to a role on a namespace.
        /// </summary>
        /// <param name="body">List of permissions for the specified role</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GrantPermissionOnNamespaceAsync(string tenant, string @namespace, string role, System.Collections.Generic.IEnumerable<Anonymous> body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Revoke all permissions to a role on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RevokePermissionsOnNamespaceAsync(string tenant, string @namespace, string role);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Revoke all permissions to a role on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RevokePermissionsOnNamespaceAsync(string tenant, string @namespace, string role, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the persistence configuration for a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPersistenceAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the persistence configuration for a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPersistenceAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set the persistence configuration for all the topics on a namespace.
        /// </summary>
        /// <param name="body">Persistence policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetPersistenceAsync(string tenant, string @namespace, PersistencePolicies body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set the persistence configuration for all the topics on a namespace.
        /// </summary>
        /// <param name="body">Persistence policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetPersistenceAsync(string tenant, string @namespace, PersistencePolicies body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete the persistence configuration for all topics on a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeletePersistenceAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete the persistence configuration for all topics on a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeletePersistenceAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set the bookie-affinity-group to namespace-persistent policy.
        /// </summary>
        /// <param name="body">Bookie affinity group for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetBookieAffinityGroupAsync(string tenant, string @namespace, BookieAffinityGroupData body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set the bookie-affinity-group to namespace-persistent policy.
        /// </summary>
        /// <param name="body">Bookie affinity group for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetBookieAffinityGroupAsync(string tenant, string @namespace, BookieAffinityGroupData body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get key value pair properties for a given namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPropertiesAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get key value pair properties for a given namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPropertiesAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Put key value pairs property on a namespace.
        /// </summary>
        /// <param name="body">Key value pair properties for the namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetPropertiesAsync(string tenant, string @namespace, System.Collections.Generic.IDictionary<string, string> body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Put key value pairs property on a namespace.
        /// </summary>
        /// <param name="body">Key value pair properties for the namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetPropertiesAsync(string tenant, string @namespace, System.Collections.Generic.IDictionary<string, string> body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Clear properties on a given namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ClearPropertiesAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Clear properties on a given namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ClearPropertiesAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get property value for a given key on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPropertyAsync(string tenant, string @namespace, string key);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get property value for a given key on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPropertyAsync(string tenant, string @namespace, string key, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get property value for a given key on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemovePropertyAsync(string tenant, string @namespace, string key);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get property value for a given key on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemovePropertyAsync(string tenant, string @namespace, string key, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Put a key value pair property on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetPropertyAsync(string tenant, string @namespace, string key, string value);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Put a key value pair property on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetPropertyAsync(string tenant, string @namespace, string key, string value, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set offload configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveOffloadPoliciesAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set offload configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveOffloadPoliciesAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the replication clusters for a namespace.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetNamespaceReplicationClustersAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the replication clusters for a namespace.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetNamespaceReplicationClustersAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set the replication clusters for a namespace.
        /// </summary>
        /// <param name="body">List of replication clusters</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetNamespaceReplicationClustersAsync(string tenant, string @namespace, System.Collections.Generic.IEnumerable<string> body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set the replication clusters for a namespace.
        /// </summary>
        /// <param name="body">List of replication clusters</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetNamespaceReplicationClustersAsync(string tenant, string @namespace, System.Collections.Generic.IEnumerable<string> body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get replicator dispatch-rate configured for the namespace, null means replicator dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetReplicatorDispatchRateAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get replicator dispatch-rate configured for the namespace, null means replicator dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetReplicatorDispatchRateAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set replicator dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <param name="body">Replicator dispatch rate for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetReplicatorDispatchRateAsync(string tenant, string @namespace, DispatchRateImpl body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set replicator dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <param name="body">Replicator dispatch rate for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetReplicatorDispatchRateAsync(string tenant, string @namespace, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove replicator dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveReplicatorDispatchRateAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove replicator dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveReplicatorDispatchRateAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the resource group attached to the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetNamespaceResourceGroupAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the resource group attached to the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetNamespaceResourceGroupAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete resourcegroup for a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveNamespaceResourceGroupAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete resourcegroup for a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveNamespaceResourceGroupAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set resourcegroup for a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetNamespaceResourceGroupAsync(string tenant, string @namespace, string resourcegroup);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set resourcegroup for a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetNamespaceResourceGroupAsync(string tenant, string @namespace, string resourcegroup, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get retention config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetRetentionAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get retention config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetRetentionAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set retention configuration on a namespace.
        /// </summary>
        /// <param name="body">Retention policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetRetentionAsync(string tenant, string @namespace, RetentionPolicies body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set retention configuration on a namespace.
        /// </summary>
        /// <param name="body">Retention policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetRetentionAsync(string tenant, string @namespace, RetentionPolicies body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove retention configuration on a namespace.
        /// </summary>
        /// <param name="body">Retention policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveRetentionAsync(string tenant, string @namespace, RetentionPolicies body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove retention configuration on a namespace.
        /// </summary>
        /// <param name="body">Retention policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveRetentionAsync(string tenant, string @namespace, RetentionPolicies body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Trigger the scan of offloaded Ledgers on the LedgerOffloader for the given namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ScanOffloadedLedgersAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Trigger the scan of offloaded Ledgers on the LedgerOffloader for the given namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ScanOffloadedLedgersAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// The strategy used to check the compatibility of new schemas, provided by producers, before automatically updating the schema
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response> GetSchemaAutoUpdateCompatibilityStrategyAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// The strategy used to check the compatibility of new schemas, provided by producers, before automatically updating the schema
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response> GetSchemaAutoUpdateCompatibilityStrategyAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Update the strategy used to check the compatibility of new schemas, provided by producers, before automatically updating the schema
        /// </summary>
        /// <param name="body">Strategy used to check the compatibility of new schemas</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSchemaAutoUpdateCompatibilityStrategyAsync(string tenant, string @namespace, string body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update the strategy used to check the compatibility of new schemas, provided by producers, before automatically updating the schema
        /// </summary>
        /// <param name="body">Strategy used to check the compatibility of new schemas</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSchemaAutoUpdateCompatibilityStrategyAsync(string tenant, string @namespace, string body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// The strategy of the namespace schema compatibility
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSchemaCompatibilityStrategyAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// The strategy of the namespace schema compatibility
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSchemaCompatibilityStrategyAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Update the strategy used to check the compatibility of new schema
        /// </summary>
        /// <param name="body">Strategy used to check the compatibility of new schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSchemaCompatibilityStrategyAsync(string tenant, string @namespace, string body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update the strategy used to check the compatibility of new schema
        /// </summary>
        /// <param name="body">Strategy used to check the compatibility of new schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSchemaCompatibilityStrategyAsync(string tenant, string @namespace, string body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get schema validation enforced flag for namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSchemaValidtionEnforcedAsync(string tenant, string @namespace, bool? applied);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get schema validation enforced flag for namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSchemaValidtionEnforcedAsync(string tenant, string @namespace, bool? applied, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set schema validation enforced flag on namespace.
        /// </summary>
        /// <param name="body">Flag of whether validation is enforced on the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSchemaValidationEnforcedAsync(string tenant, string @namespace, bool body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set schema validation enforced flag on namespace.
        /// </summary>
        /// <param name="body">Flag of whether validation is enforced on the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSchemaValidationEnforcedAsync(string tenant, string @namespace, bool body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get subscribe-rate configured for the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscribeRateAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get subscribe-rate configured for the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscribeRateAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set subscribe-rate throttling for all topics of the namespace
        /// </summary>
        /// <param name="body">Subscribe rate for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscribeRateAsync(string tenant, string @namespace, SubscribeRate body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set subscribe-rate throttling for all topics of the namespace
        /// </summary>
        /// <param name="body">Subscribe rate for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscribeRateAsync(string tenant, string @namespace, SubscribeRate body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete subscribe-rate throttling for all topics of the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteSubscribeRateAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete subscribe-rate throttling for all topics of the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteSubscribeRateAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get subscription auth mode in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionAuthModeAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get subscription auth mode in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionAuthModeAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set a subscription auth mode for all the topics on a namespace.
        /// </summary>
        /// <param name="body">Subscription auth mode for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscriptionAuthModeAsync(string tenant, string @namespace, string body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set a subscription auth mode for all the topics on a namespace.
        /// </summary>
        /// <param name="body">Subscription auth mode for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscriptionAuthModeAsync(string tenant, string @namespace, string body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get subscription dispatch-rate configured for the namespace, null means subscription dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionDispatchRateAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get subscription dispatch-rate configured for the namespace, null means subscription dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionDispatchRateAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set Subscription dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <param name="body">Subscription dispatch rate for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscriptionDispatchRateAsync(string tenant, string @namespace, DispatchRateImpl body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set Subscription dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <param name="body">Subscription dispatch rate for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscriptionDispatchRateAsync(string tenant, string @namespace, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete Subscription dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteSubscriptionDispatchRateAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete Subscription dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteSubscriptionDispatchRateAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the subscription expiration time for the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionExpirationTimeAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the subscription expiration time for the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionExpirationTimeAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set subscription expiration time in minutes for namespace
        /// </summary>
        /// <param name="body">Expiration time in minutes for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscriptionExpirationTimeAsync(string tenant, string @namespace, int body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set subscription expiration time in minutes for namespace
        /// </summary>
        /// <param name="body">Expiration time in minutes for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscriptionExpirationTimeAsync(string tenant, string @namespace, int body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove subscription expiration time for namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSubscriptionExpirationTimeAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove subscription expiration time for namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSubscriptionExpirationTimeAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// The set of whether allow subscription types
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionTypesEnabledAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// The set of whether allow subscription types
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionTypesEnabledAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Update set of whether allow share sub type
        /// </summary>
        /// <param name="body">Set of whether allow subscription types</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscriptionTypesEnabledAsync(string tenant, string @namespace, System.Collections.Generic.IEnumerable<Anonymous2> body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update set of whether allow share sub type
        /// </summary>
        /// <param name="body">Set of whether allow subscription types</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscriptionTypesEnabledAsync(string tenant, string @namespace, System.Collections.Generic.IEnumerable<Anonymous2> body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove subscription types enabled on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSubscriptionTypesEnabledAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove subscription types enabled on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSubscriptionTypesEnabledAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the list of all the topics under a certain namespace.
        /// </summary>
        /// <param name="includeSystemTopic">Include system topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetTopicsAsync(string tenant, string @namespace, Mode? mode, bool? includeSystemTopic);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of all the topics under a certain namespace.
        /// </summary>
        /// <param name="includeSystemTopic">Include system topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetTopicsAsync(string tenant, string @namespace, Mode? mode, bool? includeSystemTopic, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Unload namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UnloadNamespaceAsync(string tenant, string @namespace);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unload namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UnloadNamespaceAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Unsubscribes the given subscription on all topics on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UnsubscribeNamespaceAsync(string tenant, string @namespace, string subscription, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unsubscribes the given subscription on all topics on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UnsubscribeNamespaceAsync(string tenant, string @namespace, string subscription, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete a namespace bundle and all the topics under it.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteNamespaceBundleAsync(string tenant, string @namespace, string bundle, bool? force, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a namespace bundle and all the topics under it.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteNamespaceBundleAsync(string tenant, string @namespace, string bundle, bool? force, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Clear backlog for all topics on a namespace bundle.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ClearNamespaceBundleBacklogAsync(string tenant, string @namespace, string bundle, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Clear backlog for all topics on a namespace bundle.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ClearNamespaceBundleBacklogAsync(string tenant, string @namespace, string bundle, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Clear backlog for a given subscription on all topics on a namespace bundle.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ClearNamespaceBundleBacklogForSubscriptionAsync(string tenant, string @namespace, string subscription, string bundle, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Clear backlog for a given subscription on all topics on a namespace bundle.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ClearNamespaceBundleBacklogForSubscriptionAsync(string tenant, string @namespace, string subscription, string bundle, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Split a namespace bundle
        /// </summary>
        /// <param name="body">splitBoundaries</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SplitNamespaceBundleAsync(string tenant, string @namespace, string bundle, bool? authoritative, bool? unload, string splitAlgorithmName, System.Collections.Generic.IEnumerable<long> body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Split a namespace bundle
        /// </summary>
        /// <param name="body">splitBoundaries</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SplitNamespaceBundleAsync(string tenant, string @namespace, string bundle, bool? authoritative, bool? unload, string splitAlgorithmName, System.Collections.Generic.IEnumerable<long> body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get hash positions for topics
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetTopicHashPositionsAsync(string tenant, string @namespace, string bundle, System.Collections.Generic.IEnumerable<string> topics);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get hash positions for topics
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetTopicHashPositionsAsync(string tenant, string @namespace, string bundle, System.Collections.Generic.IEnumerable<string> topics, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Unload a namespace bundle
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UnloadNamespaceBundleAsync(string tenant, string @namespace, string bundle, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unload a namespace bundle
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UnloadNamespaceBundleAsync(string tenant, string @namespace, string bundle, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Unsubscribes the given subscription on all topics on a namespace bundle.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UnsubscribeNamespaceBundleAsync(string tenant, string @namespace, string subscription, string bundle, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unsubscribes the given subscription on all topics on a namespace bundle.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UnsubscribeNamespaceBundleAsync(string tenant, string @namespace, string subscription, string bundle, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the list of non-persistent topics under a namespace.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="bundle">Specify the bundle name</param>
        /// <param name="includeSystemTopic">Include system topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetListAsync(string tenant, string @namespace, string bundle, bool? includeSystemTopic);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of non-persistent topics under a namespace.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="bundle">Specify the bundle name</param>
        /// <param name="includeSystemTopic">Include system topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetListAsync(string tenant, string @namespace, string bundle, bool? includeSystemTopic, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the list of partitioned topics under a namespace.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="includeSystemTopic">Include system topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetPartitionedTopicListAsync(string tenant, string @namespace, bool? includeSystemTopic);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of partitioned topics under a namespace.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="includeSystemTopic">Include system topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetPartitionedTopicListAsync(string tenant, string @namespace, bool? includeSystemTopic, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the list of non-persistent topics under a namespace bundle.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="bundle">Bundle range of a topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetListFromBundleAsync(string tenant, string @namespace, string bundle);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of non-persistent topics under a namespace bundle.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="bundle">Bundle range of a topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetListFromBundleAsync(string tenant, string @namespace, string bundle, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Create a non-partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Key value pair properties for the topic metadata</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreateNonPartitionedTopicAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IDictionary<string, string> body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a non-partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Key value pair properties for the topic metadata</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreateNonPartitionedTopicAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IDictionary<string, string> body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="force">Stop all producer/consumer/replicator and delete topic forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteTopicAsync(string tenant, string @namespace, string topic, bool? force, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="force">Stop all producer/consumer/replicator and delete topic forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteTopicAsync(string tenant, string @namespace, string topic, bool? force, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Expiry messages on all subscriptions of topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="expireTimeInSeconds">Expires beyond the specified number of seconds</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExpireMessagesForAllSubscriptionsAsync(string tenant, string @namespace, string topic, int expireTimeInSeconds, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Expiry messages on all subscriptions of topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="expireTimeInSeconds">Expires beyond the specified number of seconds</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExpireMessagesForAllSubscriptionsAsync(string tenant, string @namespace, string topic, int expireTimeInSeconds, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get estimated backlog for offline topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetBacklogAsync(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get estimated backlog for offline topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetBacklogAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set a backlog quota for a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetBacklogQuota2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, BacklogQuotaType3? backlogQuotaType);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set a backlog quota for a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetBacklogQuota2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, BacklogQuotaType3? backlogQuotaType, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove a backlog quota policy from a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveBacklogQuota2Async(string tenant, string @namespace, string topic, BacklogQuotaType4? backlogQuotaType, bool? authoritative, bool? isGlobal);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove a backlog quota policy from a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveBacklogQuota2Async(string tenant, string @namespace, string topic, BacklogQuotaType4? backlogQuotaType, bool? authoritative, bool? isGlobal, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get backlog quota map on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetBacklogQuotaMap2Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative, bool? isGlobal);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get backlog quota map on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetBacklogQuotaMap2Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative, bool? isGlobal, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Calculate backlog size by a message ID (in bytes).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetBacklogSizeByMessageIdAsync(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Calculate backlog size by a message ID (in bytes).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetBacklogSizeByMessageIdAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the status of a compaction operation for a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CompactionStatusAsync(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the status of a compaction operation for a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CompactionStatusAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Trigger a compaction operation on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CompactAsync(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Trigger a compaction operation on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CompactAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetCompactionThreshold2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetCompactionThreshold2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetCompactionThresholdPOSTAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, long? body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetCompactionThresholdPOSTAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, long? body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveCompactionThresholdAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveCompactionThresholdAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Create missed partitions of an existing partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreateMissedPartitionsAsync(string tenant, string @namespace, string topic);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create missed partitions of an existing partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreateMissedPartitionsAsync(string tenant, string @namespace, string topic, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get deduplication configuration of a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDeduplication2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get deduplication configuration of a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDeduplication2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set deduplication enabled on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">DeduplicationEnabled policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDeduplicationAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, bool? body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set deduplication enabled on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">DeduplicationEnabled policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDeduplicationAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, bool? body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove deduplication configuration for specified topic.
        /// </summary>
        /// <param name="isGlobal">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveDeduplication2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove deduplication configuration for specified topic.
        /// </summary>
        /// <param name="isGlobal">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveDeduplication2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDeduplicationSnapshotInterval2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDeduplicationSnapshotInterval2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="body">Interval to take deduplication snapshot for the specified topic</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDeduplicationSnapshotInterval2Async(string tenant, string @namespace, string topic, int? body, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="body">Interval to take deduplication snapshot for the specified topic</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDeduplicationSnapshotInterval2Async(string tenant, string @namespace, string topic, int? body, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteDeduplicationSnapshotIntervalAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteDeduplicationSnapshotIntervalAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDelayedDeliveryPolicies2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDelayedDeliveryPolicies2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Delayed delivery policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDelayedDeliveryPolicies2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, DelayedDeliveryPolicies body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Delayed delivery policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDelayedDeliveryPolicies2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, DelayedDeliveryPolicies body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteDelayedDeliveryPoliciesAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteDelayedDeliveryPoliciesAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDispatchRate2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDispatchRate2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDispatchRate2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, DispatchRateImpl body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDispatchRate2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveDispatchRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveDispatchRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get entry filters for a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetEntryFiltersAsync(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get entry filters for a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetEntryFiltersAsync(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set entry filters for specified topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Enable sub types for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetEntryFiltersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, EntryFilters body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set entry filters for specified topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Enable sub types for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetEntryFiltersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, EntryFilters body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove entry filters for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected thiscall to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveEntryFiltersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove entry filters for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected thiscall to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveEntryFiltersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Examine a specific message on a topic by position relative to the earliest or the latest message.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="initialPosition">Relative start position to examine message.It can be 'latest' or 'earliest'</param>
        /// <param name="messagePosition">The position of messages (default 1)</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExamineMessageAsync(string tenant, string @namespace, string topic, InitialPosition? initialPosition, long? messagePosition, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Examine a specific message on a topic by position relative to the earliest or the latest message.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="initialPosition">Relative start position to examine message.It can be 'latest' or 'earliest'</param>
        /// <param name="messagePosition">The position of messages (default 1)</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExamineMessageAsync(string tenant, string @namespace, string topic, InitialPosition? initialPosition, long? messagePosition, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetInactiveTopicPolicies2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetInactiveTopicPolicies2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">inactive topic policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetInactiveTopicPoliciesPOST3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, InactiveTopicPolicies body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">inactive topic policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetInactiveTopicPoliciesPOST3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, InactiveTopicPolicies body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteInactiveTopicPoliciesAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteInactiveTopicPoliciesAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the stored topic metadata.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetManagedLedgerInfoAsync(string tenant, string @namespace, bool? authoritative, string topic);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the stored topic metadata.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetManagedLedgerInfoAsync(string tenant, string @namespace, bool? authoritative, string topic, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the internal stats for the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetInternalStatsAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? metadata);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the internal stats for the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetInternalStatsAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? metadata, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Return the last commit message id of topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetLastMessageIdAsync(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Return the last commit message id of topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetLastMessageIdAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get message by its messageId.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="ledgerId">The ledger id</param>
        /// <param name="entryId">The entry id</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMessageByIdAsync(string tenant, string @namespace, string topic, long ledgerId, long entryId, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get message by its messageId.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="ledgerId">The ledger id</param>
        /// <param name="entryId">The entry id</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMessageByIdAsync(string tenant, string @namespace, string topic, long ledgerId, long entryId, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxConsumersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxConsumersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max consumers of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxConsumersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max consumers of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxConsumersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxConsumersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxConsumersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxConsumersPerSubscription2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxConsumersPerSubscription2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxConsumersPerSubscription2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxConsumersPerSubscription2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxConsumersPerSubscription2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxConsumersPerSubscription2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxMessageSizeAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxMessageSizeAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max message size of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxMessageSizeAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max message size of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxMessageSizeAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxMessageSizeAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxMessageSizeAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxProducersAsync(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxProducersAsync(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max producers of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxProducersAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, int? body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max producers of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxProducersAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, int? body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxProducersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxProducersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxSubscriptionsPerTopic2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxSubscriptionsPerTopic2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max subscriptions of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxSubscriptionsPerTopic2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max subscriptions of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxSubscriptionsPerTopic2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxSubscriptionsPerTopic2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxSubscriptionsPerTopic2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxUnackedMessagesOnConsumerAsync(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxUnackedMessagesOnConsumerAsync(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Max unacked messages on consumer policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxUnackedMessagesOnConsumerAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Max unacked messages on consumer policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxUnackedMessagesOnConsumerAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteMaxUnackedMessagesOnConsumerAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteMaxUnackedMessagesOnConsumerAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxUnackedMessagesOnSubscriptionAsync(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxUnackedMessagesOnSubscriptionAsync(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Max unacked messages on subscription policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxUnackedMessagesOnSubscriptionAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Max unacked messages on subscription policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxUnackedMessagesOnSubscriptionAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteMaxUnackedMessagesOnSubscriptionAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteMaxUnackedMessagesOnSubscriptionAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get message TTL in seconds for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMessageTTLAsync(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get message TTL in seconds for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMessageTTLAsync(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set message TTL in seconds for a topic
        /// </summary>
        /// <param name="messageTTL">TTL in seconds for the specified namespace</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMessageTTLAsync(string tenant, string @namespace, string topic, int messageTTL, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set message TTL in seconds for a topic
        /// </summary>
        /// <param name="messageTTL">TTL in seconds for the specified namespace</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMessageTTLAsync(string tenant, string @namespace, string topic, int messageTTL, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove message TTL in seconds for a topic
        /// </summary>
        /// <param name="isGlobal">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMessageTTLAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove message TTL in seconds for a topic
        /// </summary>
        /// <param name="isGlobal">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMessageTTLAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get message ID published at or just after this absolute timestamp (in ms).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="timestamp">Specify the timestamp</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMessageIdByTimestampAsync(string tenant, string @namespace, string topic, long timestamp, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get message ID published at or just after this absolute timestamp (in ms).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="timestamp">Specify the timestamp</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMessageIdByTimestampAsync(string tenant, string @namespace, string topic, long timestamp, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Offload a prefix of a topic to long term storage
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task OffloadStatusAsync(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Offload a prefix of a topic to long term storage
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task OffloadStatusAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Offload a prefix of a topic to long term storage
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task TriggerOffloadAsync(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Offload a prefix of a topic to long term storage
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task TriggerOffloadAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetOffloadPolicies2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetOffloadPolicies2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Offload policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetOffloadPolicies2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, OffloadPoliciesImpl body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Offload policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetOffloadPolicies2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, OffloadPoliciesImpl body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveOffloadPolicies2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveOffloadPolicies2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the stats for the partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="perPartition">Get per partition stats</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="getPreciseBacklog">If return precise backlog or imprecise backlog</param>
        /// <param name="subscriptionBacklogSize">If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.</param>
        /// <param name="getEarliestTimeInBacklog">If return the earliest time in backlog</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPartitionedStatsAsync(string tenant, string @namespace, string topic, bool? perPartition, bool? authoritative, bool? getPreciseBacklog, bool? subscriptionBacklogSize, bool? getEarliestTimeInBacklog);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the stats for the partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="perPartition">Get per partition stats</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="getPreciseBacklog">If return precise backlog or imprecise backlog</param>
        /// <param name="subscriptionBacklogSize">If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.</param>
        /// <param name="getEarliestTimeInBacklog">If return the earliest time in backlog</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPartitionedStatsAsync(string tenant, string @namespace, string topic, bool? perPartition, bool? authoritative, bool? getPreciseBacklog, bool? subscriptionBacklogSize, bool? getEarliestTimeInBacklog, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get partitioned topic metadata.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="checkAllowAutoCreation">Is check configuration required to automatically create topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPartitionedMetadataAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? checkAllowAutoCreation);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get partitioned topic metadata.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="checkAllowAutoCreation">Is check configuration required to automatically create topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPartitionedMetadataAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? checkAllowAutoCreation, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Increment partitions of an existing partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The number of partitions for the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdatePartitionedTopicAsync(string tenant, string @namespace, string topic, bool? updateLocalTopicOnly, bool? authoritative, bool? force, int body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Increment partitions of an existing partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The number of partitions for the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdatePartitionedTopicAsync(string tenant, string @namespace, string topic, bool? updateLocalTopicOnly, bool? authoritative, bool? force, int body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Create a partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="body">The metadata for the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreatePartitionedTopicAsync(string tenant, string @namespace, string topic, PartitionedTopicMetadata body, bool? createLocalTopicOnly);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="body">The metadata for the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreatePartitionedTopicAsync(string tenant, string @namespace, string topic, PartitionedTopicMetadata body, bool? createLocalTopicOnly, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete a partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="force">Stop all producer/consumer/replicator and delete topic forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeletePartitionedTopicAsync(string tenant, string @namespace, string topic, bool? force, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="force">Stop all producer/consumer/replicator and delete topic forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeletePartitionedTopicAsync(string tenant, string @namespace, string topic, bool? force, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get permissions on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPermissionsOnTopicAsync(string tenant, string @namespace, string topic);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get permissions on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPermissionsOnTopicAsync(string tenant, string @namespace, string topic, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Grant a new permission to a role on a single topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="role">Client role to which grant permissions</param>
        /// <param name="body">Actions to be granted (produce,functions,consume)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GrantPermissionsOnTopicAsync(string tenant, string @namespace, string topic, string role, System.Collections.Generic.IEnumerable<Anonymous3> body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Grant a new permission to a role on a single topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="role">Client role to which grant permissions</param>
        /// <param name="body">Actions to be granted (produce,functions,consume)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GrantPermissionsOnTopicAsync(string tenant, string @namespace, string topic, string role, System.Collections.Generic.IEnumerable<Anonymous3> body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Revoke permissions on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="role">Client role to which grant permissions</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RevokePermissionsOnTopicAsync(string tenant, string @namespace, string topic, string role);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Revoke permissions on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="role">Client role to which grant permissions</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RevokePermissionsOnTopicAsync(string tenant, string @namespace, string topic, string role, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPersistence2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPersistence2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Bookkeeper persistence policies for specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetPersistence2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, PersistencePolicies body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Bookkeeper persistence policies for specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetPersistence2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, PersistencePolicies body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemovePersistenceAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemovePersistenceAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get topic properties.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetProperties2Async(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get topic properties.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetProperties2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Update the properties on the given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Key value pair properties for the topic metadata</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdatePropertiesAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IDictionary<string, string> body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update the properties on the given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Key value pair properties for the topic metadata</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdatePropertiesAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IDictionary<string, string> body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove the key in properties on the given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemovePropertiesAsync(string tenant, string @namespace, string topic, string key, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove the key in properties on the given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemovePropertiesAsync(string tenant, string @namespace, string topic, string key, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPublishRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPublishRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set message publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetPublishRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, PublishRate body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set message publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetPublishRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, PublishRate body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove message publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemovePublishRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove message publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemovePublishRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the replication clusters for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetReplicationClustersAsync(string tenant, string @namespace, string topic, bool? applied, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the replication clusters for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetReplicationClustersAsync(string tenant, string @namespace, string topic, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set the replication clusters for a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">List of replication clusters</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetReplicationClustersAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IEnumerable<string> body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set the replication clusters for a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">List of replication clusters</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetReplicationClustersAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IEnumerable<string> body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove the replication clusters from a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveReplicationClustersAsync(string tenant, string @namespace, string topic, BacklogQuotaType5? backlogQuotaType, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove the replication clusters from a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveReplicationClustersAsync(string tenant, string @namespace, string topic, BacklogQuotaType5? backlogQuotaType, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetReplicatorDispatchRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetReplicatorDispatchRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Replicator dispatch rate of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetReplicatorDispatchRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, DispatchRateImpl body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Replicator dispatch rate of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetReplicatorDispatchRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveReplicatorDispatchRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveReplicatorDispatchRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetRetention2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetRetention2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Retention policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetRetention2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, RetentionPolicies body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Retention policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetRetention2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, RetentionPolicies body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveRetention2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveRetention2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the cluster</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSchemaCompatibilityStrategy2Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the cluster</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSchemaCompatibilityStrategy2Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Strategy used to check the compatibility of new schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSchemaCompatibilityStrategy2Async(string tenant, string @namespace, string topic, bool? authoritative, string body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Strategy used to check the compatibility of new schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSchemaCompatibilityStrategy2Async(string tenant, string @namespace, string topic, bool? authoritative, string body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Strategy used to check the compatibility of new schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSchemaCompatibilityStrategyAsync(string tenant, string @namespace, string topic, bool? authoritative, string body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Strategy used to check the compatibility of new schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSchemaCompatibilityStrategyAsync(string tenant, string @namespace, string topic, bool? authoritative, string body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get schema validation enforced flag for topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSchemaValidationEnforcedAsync(string tenant, string @namespace, string topic, bool? applied, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get schema validation enforced flag for topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSchemaValidationEnforcedAsync(string tenant, string @namespace, string topic, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set schema validation enforced flag on topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSchemaValidationEnforced2Async(string tenant, string @namespace, string topic, bool? authoritative, bool body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set schema validation enforced flag on topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSchemaValidationEnforced2Async(string tenant, string @namespace, string topic, bool? authoritative, bool body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the shadow topic list for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetShadowTopicsAsync(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the shadow topic list for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetShadowTopicsAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set shadow topic list for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">List of shadow topics</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetShadowTopicsAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IEnumerable<string> body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set shadow topic list for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">List of shadow topics</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetShadowTopicsAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IEnumerable<string> body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete shadow topics for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteShadowTopicsAsync(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete shadow topics for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteShadowTopicsAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the stats for the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="getPreciseBacklog">If return precise backlog or imprecise backlog</param>
        /// <param name="subscriptionBacklogSize">If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.</param>
        /// <param name="getEarliestTimeInBacklog">If return time of the earliest message in backlog</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetStatsAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? getPreciseBacklog, bool? subscriptionBacklogSize, bool? getEarliestTimeInBacklog);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the stats for the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="getPreciseBacklog">If return precise backlog or imprecise backlog</param>
        /// <param name="subscriptionBacklogSize">If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.</param>
        /// <param name="getEarliestTimeInBacklog">If return time of the earliest message in backlog</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetStatsAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? getPreciseBacklog, bool? subscriptionBacklogSize, bool? getEarliestTimeInBacklog, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscribeRate2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscribeRate2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscribe rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscribeRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, SubscribeRate body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscribe rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscribeRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, SubscribeRate body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscribe rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSubscribeRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, SubscribeRate body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscribe rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSubscribeRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, SubscribeRate body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete a subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be deleted</param>
        /// <param name="force">Disconnect and close all consumers and delete subscription forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteSubscriptionAsync(string tenant, string @namespace, string topic, string subName, bool? force, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be deleted</param>
        /// <param name="force">Disconnect and close all consumers and delete subscription forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteSubscriptionAsync(string tenant, string @namespace, string topic, string subName, bool? force, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Analyse a subscription, by scanning all the unprocessed messages
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription</param>
        /// <param name="position">messageId to start the analysis</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task AnalyzeSubscriptionBacklogAsync(string tenant, string @namespace, string topic, string subName, ResetCursorData position, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Analyse a subscription, by scanning all the unprocessed messages
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription</param>
        /// <param name="position">messageId to start the analysis</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task AnalyzeSubscriptionBacklogAsync(string tenant, string @namespace, string topic, string subName, ResetCursorData position, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Expiry messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be Expiry messages on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId to reset back to (ledgerId:entryId)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExpireTopicMessagesAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, ResetCursorData messageId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Expiry messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be Expiry messages on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId to reset back to (ledgerId:entryId)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExpireTopicMessagesAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, ResetCursorData messageId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Expiry messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be Expiry messages on</param>
        /// <param name="expireTimeInSeconds">Expires beyond the specified number of seconds</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExpireTopicMessages2Async(string tenant, string @namespace, string topic, string subName, int expireTimeInSeconds, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Expiry messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be Expiry messages on</param>
        /// <param name="expireTimeInSeconds">Expires beyond the specified number of seconds</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExpireTopicMessages2Async(string tenant, string @namespace, string topic, string subName, int expireTimeInSeconds, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Peek nth message on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscribed message expired</param>
        /// <param name="messagePosition">The number of messages (default 1)</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PeekNthMessageAsync(string tenant, string @namespace, string topic, string subName, int messagePosition, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Peek nth message on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscribed message expired</param>
        /// <param name="messagePosition">The number of messages (default 1)</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PeekNthMessageAsync(string tenant, string @namespace, string topic, string subName, int messagePosition, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Return all the properties on the given subscription
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionPropertiesAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Return all the properties on the given subscription
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionPropertiesAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Replace all the properties on the given subscription
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to update</param>
        /// <param name="body">The new properties</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateSubscriptionPropertiesAsync(string tenant, string @namespace, string topic, string subName, System.Collections.Generic.IDictionary<string, string> body, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Replace all the properties on the given subscription
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to update</param>
        /// <param name="body">The new properties</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateSubscriptionPropertiesAsync(string tenant, string @namespace, string topic, string subName, System.Collections.Generic.IDictionary<string, string> body, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get replicated subscription status on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetReplicatedSubscriptionStatusAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get replicated subscription status on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetReplicatedSubscriptionStatusAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Enable or disable a replicated subscription on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Whether to enable replicated subscription</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetReplicatedSubscriptionStatusAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, bool body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Enable or disable a replicated subscription on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Whether to enable replicated subscription</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetReplicatedSubscriptionStatusAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, bool body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Reset subscription to message position closest to given position.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to reset position on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId to reset back to (ledgerId:entryId)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ResetCursorOnPositionAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, ResetCursorData messageId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Reset subscription to message position closest to given position.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to reset position on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId to reset back to (ledgerId:entryId)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ResetCursorOnPositionAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, ResetCursorData messageId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Reset subscription to message position closest to absolute timestamp (in ms).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to reset position on</param>
        /// <param name="timestamp">the timestamp to reset back</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ResetCursorAsync(string tenant, string @namespace, string topic, string subName, long timestamp, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Reset subscription to message position closest to absolute timestamp (in ms).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to reset position on</param>
        /// <param name="timestamp">the timestamp to reset back</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ResetCursorAsync(string tenant, string @namespace, string topic, string subName, long timestamp, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Skipping messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="numMessages">The number of messages to skip</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SkipMessagesAsync(string tenant, string @namespace, string topic, string subName, int numMessages, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Skipping messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="numMessages">The number of messages to skip</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SkipMessagesAsync(string tenant, string @namespace, string topic, string subName, int numMessages, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Skip all messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SkipAllMessagesAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Skip all messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SkipAllMessagesAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Create a subscription on the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subscriptionName">Subscription to create position on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId where to create the subscription. It can be 'latest', 'earliest' or (ledgerId:entryId)</param>
        /// <param name="replicated">Is replicated required to perform this operation</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreateSubscriptionAsync(string tenant, string @namespace, string topic, string subscriptionName, bool? authoritative, ResetCursorData messageId, bool? replicated);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a subscription on the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subscriptionName">Subscription to create position on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId where to create the subscription. It can be 'latest', 'earliest' or (ledgerId:entryId)</param>
        /// <param name="replicated">Is replicated required to perform this operation</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreateSubscriptionAsync(string tenant, string @namespace, string topic, string subscriptionName, bool? authoritative, ResetCursorData messageId, bool? replicated, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionDispatchRate2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionDispatchRate2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscription message dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscriptionDispatchRate2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, DispatchRateImpl body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscription message dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscriptionDispatchRate2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSubscriptionDispatchRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSubscriptionDispatchRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get is enable sub type fors specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionTypesEnabled2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get is enable sub type fors specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionTypesEnabled2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set is enable sub types for specified topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Enable sub types for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscriptionTypesEnabled2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Collections.Generic.IEnumerable<Anonymous4> body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set is enable sub types for specified topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Enable sub types for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscriptionTypesEnabled2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Collections.Generic.IEnumerable<Anonymous4> body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove subscription types enabled for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSubscriptionTypesEnabled2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove subscription types enabled for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSubscriptionTypesEnabled2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the list of persistent subscriptions for a given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionsAsync(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of persistent subscriptions for a given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionsAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Terminate a topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task TerminateAsync(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Terminate a topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task TerminateAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Terminate all partitioned topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task TerminatePartitionedTopicAsync(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Terminate all partitioned topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task TerminatePartitionedTopicAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Truncate a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task TruncateTopicAsync(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Truncate a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task TruncateTopicAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Unload a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UnloadTopicAsync(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unload a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UnloadTopicAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionLevelDispatchRateAsync(string tenant, string @namespace, string topic, string subName, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionLevelDispatchRateAsync(string tenant, string @namespace, string topic, string subName, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscription message dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscriptionLevelDispatchRateAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, bool? isGlobal, DispatchRateImpl body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscription message dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscriptionLevelDispatchRateAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, bool? isGlobal, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSubscriptionLevelDispatchRateAsync(string tenant, string @namespace, string topic, string subName, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSubscriptionLevelDispatchRateAsync(string tenant, string @namespace, string topic, string subName, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the list of topics under a namespace.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="bundle">Specify the bundle name</param>
        /// <param name="includeSystemTopic">Include system topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetList2Async(string tenant, string @namespace, string bundle, bool? includeSystemTopic);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of topics under a namespace.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="bundle">Specify the bundle name</param>
        /// <param name="includeSystemTopic">Include system topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetList2Async(string tenant, string @namespace, string bundle, bool? includeSystemTopic, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the list of partitioned topics under a namespace.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="includeSystemTopic">Include system topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetPartitionedTopicList2Async(string tenant, string @namespace, bool? includeSystemTopic);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of partitioned topics under a namespace.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="includeSystemTopic">Include system topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetPartitionedTopicList2Async(string tenant, string @namespace, bool? includeSystemTopic, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Create a non-partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Key value pair properties for the topic metadata</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreateNonPartitionedTopic2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IDictionary<string, string> body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a non-partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Key value pair properties for the topic metadata</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreateNonPartitionedTopic2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IDictionary<string, string> body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="force">Stop all producer/consumer/replicator and delete topic forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteTopic2Async(string tenant, string @namespace, string topic, bool? force, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="force">Stop all producer/consumer/replicator and delete topic forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteTopic2Async(string tenant, string @namespace, string topic, bool? force, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Expiry messages on all subscriptions of topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="expireTimeInSeconds">Expires beyond the specified number of seconds</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExpireMessagesForAllSubscriptions2Async(string tenant, string @namespace, string topic, int expireTimeInSeconds, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Expiry messages on all subscriptions of topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="expireTimeInSeconds">Expires beyond the specified number of seconds</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExpireMessagesForAllSubscriptions2Async(string tenant, string @namespace, string topic, int expireTimeInSeconds, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get estimated backlog for offline topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetBacklog2Async(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get estimated backlog for offline topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetBacklog2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set a backlog quota for a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetBacklogQuota3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, BacklogQuotaType6? backlogQuotaType);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set a backlog quota for a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetBacklogQuota3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, BacklogQuotaType6? backlogQuotaType, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove a backlog quota policy from a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveBacklogQuota3Async(string tenant, string @namespace, string topic, BacklogQuotaType7? backlogQuotaType, bool? authoritative, bool? isGlobal);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove a backlog quota policy from a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveBacklogQuota3Async(string tenant, string @namespace, string topic, BacklogQuotaType7? backlogQuotaType, bool? authoritative, bool? isGlobal, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get backlog quota map on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetBacklogQuotaMap3Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative, bool? isGlobal);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get backlog quota map on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetBacklogQuotaMap3Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative, bool? isGlobal, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Calculate backlog size by a message ID (in bytes).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetBacklogSizeByMessageId2Async(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Calculate backlog size by a message ID (in bytes).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetBacklogSizeByMessageId2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the status of a compaction operation for a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CompactionStatus2Async(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the status of a compaction operation for a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CompactionStatus2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Trigger a compaction operation on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task Compact2Async(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Trigger a compaction operation on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task Compact2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetCompactionThreshold3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetCompactionThreshold3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetCompactionThresholdPOST2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, long? body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetCompactionThresholdPOST2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, long? body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveCompactionThreshold2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveCompactionThreshold2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Create missed partitions of an existing partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreateMissedPartitions2Async(string tenant, string @namespace, string topic);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create missed partitions of an existing partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreateMissedPartitions2Async(string tenant, string @namespace, string topic, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get deduplication configuration of a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDeduplication3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get deduplication configuration of a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDeduplication3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set deduplication enabled on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">DeduplicationEnabled policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDeduplication2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, bool? body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set deduplication enabled on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">DeduplicationEnabled policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDeduplication2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, bool? body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove deduplication configuration for specified topic.
        /// </summary>
        /// <param name="isGlobal">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveDeduplication3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove deduplication configuration for specified topic.
        /// </summary>
        /// <param name="isGlobal">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveDeduplication3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDeduplicationSnapshotInterval3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDeduplicationSnapshotInterval3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="body">Interval to take deduplication snapshot for the specified topic</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDeduplicationSnapshotInterval3Async(string tenant, string @namespace, string topic, int? body, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="body">Interval to take deduplication snapshot for the specified topic</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDeduplicationSnapshotInterval3Async(string tenant, string @namespace, string topic, int? body, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteDeduplicationSnapshotInterval2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteDeduplicationSnapshotInterval2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDelayedDeliveryPolicies3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDelayedDeliveryPolicies3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Delayed delivery policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDelayedDeliveryPolicies3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, DelayedDeliveryPolicies body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Delayed delivery policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDelayedDeliveryPolicies3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, DelayedDeliveryPolicies body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteDelayedDeliveryPolicies2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteDelayedDeliveryPolicies2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDispatchRate3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetDispatchRate3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDispatchRate3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, DispatchRateImpl body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetDispatchRate3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveDispatchRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveDispatchRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get entry filters for a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetEntryFilters2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get entry filters for a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetEntryFilters2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set entry filters for specified topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected thiscall to this broker. For internal use.</param>
        /// <param name="body">Entry filters for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetEntryFilters2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, EntryFilters body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set entry filters for specified topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected thiscall to this broker. For internal use.</param>
        /// <param name="body">Entry filters for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetEntryFilters2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, EntryFilters body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove entry filters for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected thiscall to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveEntryFilters2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove entry filters for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected thiscall to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveEntryFilters2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Examine a specific message on a topic by position relative to the earliest or the latest message.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="initialPosition">Relative start position to examine message.It can be 'latest' or 'earliest'</param>
        /// <param name="messagePosition">The position of messages (default 1)</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExamineMessage2Async(string tenant, string @namespace, string topic, InitialPosition2? initialPosition, long? messagePosition, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Examine a specific message on a topic by position relative to the earliest or the latest message.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="initialPosition">Relative start position to examine message.It can be 'latest' or 'earliest'</param>
        /// <param name="messagePosition">The position of messages (default 1)</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExamineMessage2Async(string tenant, string @namespace, string topic, InitialPosition2? initialPosition, long? messagePosition, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetInactiveTopicPolicies3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetInactiveTopicPolicies3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">inactive topic policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetInactiveTopicPoliciesPOST4Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, InactiveTopicPolicies body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">inactive topic policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetInactiveTopicPoliciesPOST4Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, InactiveTopicPolicies body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteInactiveTopicPolicies2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteInactiveTopicPolicies2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the stored topic metadata.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetManagedLedgerInfo2Async(string tenant, string @namespace, bool? authoritative, string topic);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the stored topic metadata.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetManagedLedgerInfo2Async(string tenant, string @namespace, bool? authoritative, string topic, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the internal stats for the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetInternalStats2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? metadata);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the internal stats for the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetInternalStats2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? metadata, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Return the last commit message id of topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetLastMessageId2Async(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Return the last commit message id of topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetLastMessageId2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get message by its messageId.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="ledgerId">The ledger id</param>
        /// <param name="entryId">The entry id</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMessageById2Async(string tenant, string @namespace, string topic, long ledgerId, long entryId, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get message by its messageId.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="ledgerId">The ledger id</param>
        /// <param name="entryId">The entry id</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMessageById2Async(string tenant, string @namespace, string topic, long ledgerId, long entryId, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxConsumers2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxConsumers2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max consumers of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxConsumers2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max consumers of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxConsumers2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxConsumers2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxConsumers2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxConsumersPerSubscription3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxConsumersPerSubscription3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxConsumersPerSubscription3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxConsumersPerSubscription3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxConsumersPerSubscription3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxConsumersPerSubscription3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxMessageSize2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxMessageSize2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max message size of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxMessageSize2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max message size of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxMessageSize2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxMessageSize2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxMessageSize2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxProducers2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxProducers2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max producers of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxProducers2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, int? body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max producers of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxProducers2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, int? body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxProducers2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxProducers2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxSubscriptionsPerTopic3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxSubscriptionsPerTopic3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max subscriptions of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxSubscriptionsPerTopic3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max subscriptions of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxSubscriptionsPerTopic3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxSubscriptionsPerTopic3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaxSubscriptionsPerTopic3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxUnackedMessagesOnConsumer2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxUnackedMessagesOnConsumer2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Max unacked messages on consumer policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxUnackedMessagesOnConsumer2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Max unacked messages on consumer policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxUnackedMessagesOnConsumer2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteMaxUnackedMessagesOnConsumer2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteMaxUnackedMessagesOnConsumer2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxUnackedMessagesOnSubscription2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMaxUnackedMessagesOnSubscription2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Max unacked messages on subscription policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxUnackedMessagesOnSubscription2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Max unacked messages on subscription policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMaxUnackedMessagesOnSubscription2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteMaxUnackedMessagesOnSubscription2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteMaxUnackedMessagesOnSubscription2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get message TTL in seconds for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMessageTTL2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get message TTL in seconds for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMessageTTL2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set message TTL in seconds for a topic
        /// </summary>
        /// <param name="messageTTL">TTL in seconds for the specified namespace</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMessageTTL2Async(string tenant, string @namespace, string topic, int messageTTL, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set message TTL in seconds for a topic
        /// </summary>
        /// <param name="messageTTL">TTL in seconds for the specified namespace</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetMessageTTL2Async(string tenant, string @namespace, string topic, int messageTTL, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove message TTL in seconds for a topic
        /// </summary>
        /// <param name="isGlobal">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMessageTTL2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove message TTL in seconds for a topic
        /// </summary>
        /// <param name="isGlobal">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMessageTTL2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get message ID published at or just after this absolute timestamp (in ms).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="timestamp">Specify the timestamp</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMessageIdByTimestamp2Async(string tenant, string @namespace, string topic, long timestamp, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get message ID published at or just after this absolute timestamp (in ms).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="timestamp">Specify the timestamp</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetMessageIdByTimestamp2Async(string tenant, string @namespace, string topic, long timestamp, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Offload a prefix of a topic to long term storage
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task OffloadStatus2Async(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Offload a prefix of a topic to long term storage
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task OffloadStatus2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Offload a prefix of a topic to long term storage
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task TriggerOffload2Async(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Offload a prefix of a topic to long term storage
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task TriggerOffload2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetOffloadPolicies3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetOffloadPolicies3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Offload policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetOffloadPolicies3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, OffloadPoliciesImpl body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Offload policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetOffloadPolicies3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, OffloadPoliciesImpl body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveOffloadPolicies3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveOffloadPolicies3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the stats for the partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="perPartition">Get per partition stats</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="getPreciseBacklog">If return precise backlog or imprecise backlog</param>
        /// <param name="subscriptionBacklogSize">If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.</param>
        /// <param name="getEarliestTimeInBacklog">If return the earliest time in backlog</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPartitionedStats2Async(string tenant, string @namespace, string topic, bool? perPartition, bool? authoritative, bool? getPreciseBacklog, bool? subscriptionBacklogSize, bool? getEarliestTimeInBacklog);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the stats for the partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="perPartition">Get per partition stats</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="getPreciseBacklog">If return precise backlog or imprecise backlog</param>
        /// <param name="subscriptionBacklogSize">If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.</param>
        /// <param name="getEarliestTimeInBacklog">If return the earliest time in backlog</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPartitionedStats2Async(string tenant, string @namespace, string topic, bool? perPartition, bool? authoritative, bool? getPreciseBacklog, bool? subscriptionBacklogSize, bool? getEarliestTimeInBacklog, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get partitioned topic metadata.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="checkAllowAutoCreation">Is check configuration required to automatically create topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPartitionedMetadata2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? checkAllowAutoCreation);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get partitioned topic metadata.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="checkAllowAutoCreation">Is check configuration required to automatically create topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPartitionedMetadata2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? checkAllowAutoCreation, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Increment partitions of an existing partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The number of partitions for the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdatePartitionedTopic2Async(string tenant, string @namespace, string topic, bool? updateLocalTopicOnly, bool? authoritative, bool? force, int body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Increment partitions of an existing partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The number of partitions for the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdatePartitionedTopic2Async(string tenant, string @namespace, string topic, bool? updateLocalTopicOnly, bool? authoritative, bool? force, int body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Create a partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="body">The metadata for the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreatePartitionedTopic2Async(string tenant, string @namespace, string topic, PartitionedTopicMetadata body, bool? createLocalTopicOnly);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="body">The metadata for the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreatePartitionedTopic2Async(string tenant, string @namespace, string topic, PartitionedTopicMetadata body, bool? createLocalTopicOnly, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete a partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="force">Stop all producer/consumer/replicator and delete topic forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeletePartitionedTopic2Async(string tenant, string @namespace, string topic, bool? force, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="force">Stop all producer/consumer/replicator and delete topic forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeletePartitionedTopic2Async(string tenant, string @namespace, string topic, bool? force, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get permissions on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPermissionsOnTopic2Async(string tenant, string @namespace, string topic);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get permissions on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPermissionsOnTopic2Async(string tenant, string @namespace, string topic, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Grant a new permission to a role on a single topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="role">Client role to which grant permissions</param>
        /// <param name="body">Actions to be granted (produce,functions,consume)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GrantPermissionsOnTopic2Async(string tenant, string @namespace, string topic, string role, System.Collections.Generic.IEnumerable<Anonymous5> body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Grant a new permission to a role on a single topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="role">Client role to which grant permissions</param>
        /// <param name="body">Actions to be granted (produce,functions,consume)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GrantPermissionsOnTopic2Async(string tenant, string @namespace, string topic, string role, System.Collections.Generic.IEnumerable<Anonymous5> body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Revoke permissions on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="role">Client role to which grant permissions</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RevokePermissionsOnTopic2Async(string tenant, string @namespace, string topic, string role);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Revoke permissions on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="role">Client role to which grant permissions</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RevokePermissionsOnTopic2Async(string tenant, string @namespace, string topic, string role, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPersistence3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPersistence3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Bookkeeper persistence policies for specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetPersistence3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, PersistencePolicies body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Bookkeeper persistence policies for specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetPersistence3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, PersistencePolicies body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemovePersistence2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemovePersistence2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get topic properties.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetProperties3Async(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get topic properties.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetProperties3Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Update the properties on the given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Key value pair properties for the topic metadata</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateProperties2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IDictionary<string, string> body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update the properties on the given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Key value pair properties for the topic metadata</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateProperties2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IDictionary<string, string> body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove the key in properties on the given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveProperties2Async(string tenant, string @namespace, string topic, string key, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove the key in properties on the given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveProperties2Async(string tenant, string @namespace, string topic, string key, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPublishRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetPublishRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set message publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetPublishRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, PublishRate body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set message publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetPublishRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, PublishRate body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove message publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemovePublishRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove message publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemovePublishRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the replication clusters for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetReplicationClusters2Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the replication clusters for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetReplicationClusters2Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set the replication clusters for a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">List of replication clusters</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetReplicationClusters2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IEnumerable<string> body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set the replication clusters for a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">List of replication clusters</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetReplicationClusters2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IEnumerable<string> body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove the replication clusters from a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveReplicationClusters2Async(string tenant, string @namespace, string topic, BacklogQuotaType8? backlogQuotaType, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove the replication clusters from a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveReplicationClusters2Async(string tenant, string @namespace, string topic, BacklogQuotaType8? backlogQuotaType, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetReplicatorDispatchRate3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetReplicatorDispatchRate3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Replicator dispatch rate of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetReplicatorDispatchRate3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, DispatchRateImpl body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Replicator dispatch rate of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetReplicatorDispatchRate3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveReplicatorDispatchRate3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveReplicatorDispatchRate3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetRetention3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetRetention3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Retention policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetRetention3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, RetentionPolicies body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Retention policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetRetention3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, RetentionPolicies body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveRetention3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveRetention3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the cluster</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSchemaCompatibilityStrategy3Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the cluster</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSchemaCompatibilityStrategy3Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Strategy used to check the compatibility of new schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSchemaCompatibilityStrategy3Async(string tenant, string @namespace, string topic, bool? authoritative, string body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Strategy used to check the compatibility of new schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSchemaCompatibilityStrategy3Async(string tenant, string @namespace, string topic, bool? authoritative, string body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Strategy used to check the compatibility of new schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSchemaCompatibilityStrategy2Async(string tenant, string @namespace, string topic, bool? authoritative, string body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Strategy used to check the compatibility of new schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSchemaCompatibilityStrategy2Async(string tenant, string @namespace, string topic, bool? authoritative, string body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get schema validation enforced flag for topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSchemaValidationEnforced2Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get schema validation enforced flag for topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSchemaValidationEnforced2Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set schema validation enforced flag on topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSchemaValidationEnforced3Async(string tenant, string @namespace, string topic, bool? authoritative, bool body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set schema validation enforced flag on topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSchemaValidationEnforced3Async(string tenant, string @namespace, string topic, bool? authoritative, bool body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the shadow topic list for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetShadowTopics2Async(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the shadow topic list for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetShadowTopics2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set shadow topic list for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">List of shadow topics</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetShadowTopics2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IEnumerable<string> body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set shadow topic list for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">List of shadow topics</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetShadowTopics2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IEnumerable<string> body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete shadow topics for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteShadowTopics2Async(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete shadow topics for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteShadowTopics2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the stats for the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="getPreciseBacklog">If return precise backlog or imprecise backlog</param>
        /// <param name="subscriptionBacklogSize">If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.</param>
        /// <param name="getEarliestTimeInBacklog">If return time of the earliest message in backlog</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetStats2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? getPreciseBacklog, bool? subscriptionBacklogSize, bool? getEarliestTimeInBacklog);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the stats for the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="getPreciseBacklog">If return precise backlog or imprecise backlog</param>
        /// <param name="subscriptionBacklogSize">If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.</param>
        /// <param name="getEarliestTimeInBacklog">If return time of the earliest message in backlog</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetStats2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? getPreciseBacklog, bool? subscriptionBacklogSize, bool? getEarliestTimeInBacklog, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscribeRate3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscribeRate3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscribe rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscribeRate3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, SubscribeRate body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscribe rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscribeRate3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, SubscribeRate body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscribe rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSubscribeRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, SubscribeRate body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscribe rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSubscribeRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, SubscribeRate body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete a subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be deleted</param>
        /// <param name="force">Disconnect and close all consumers and delete subscription forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteSubscription2Async(string tenant, string @namespace, string topic, string subName, bool? force, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be deleted</param>
        /// <param name="force">Disconnect and close all consumers and delete subscription forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteSubscription2Async(string tenant, string @namespace, string topic, string subName, bool? force, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Analyse a subscription, by scanning all the unprocessed messages
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription</param>
        /// <param name="position">messageId to start the analysis</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task AnalyzeSubscriptionBacklog2Async(string tenant, string @namespace, string topic, string subName, ResetCursorData position, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Analyse a subscription, by scanning all the unprocessed messages
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription</param>
        /// <param name="position">messageId to start the analysis</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task AnalyzeSubscriptionBacklog2Async(string tenant, string @namespace, string topic, string subName, ResetCursorData position, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Expiry messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be Expiry messages on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId to reset back to (ledgerId:entryId)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExpireTopicMessages3Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, ResetCursorData messageId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Expiry messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be Expiry messages on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId to reset back to (ledgerId:entryId)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExpireTopicMessages3Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, ResetCursorData messageId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Expiry messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be Expiry messages on</param>
        /// <param name="expireTimeInSeconds">Expires beyond the specified number of seconds</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExpireTopicMessages4Async(string tenant, string @namespace, string topic, string subName, int expireTimeInSeconds, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Expiry messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be Expiry messages on</param>
        /// <param name="expireTimeInSeconds">Expires beyond the specified number of seconds</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExpireTopicMessages4Async(string tenant, string @namespace, string topic, string subName, int expireTimeInSeconds, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Peek nth message on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscribed message expired</param>
        /// <param name="messagePosition">The number of messages (default 1)</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PeekNthMessage2Async(string tenant, string @namespace, string topic, string subName, int messagePosition, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Peek nth message on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscribed message expired</param>
        /// <param name="messagePosition">The number of messages (default 1)</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PeekNthMessage2Async(string tenant, string @namespace, string topic, string subName, int messagePosition, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Return all the properties on the given subscription
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionProperties2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Return all the properties on the given subscription
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionProperties2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Replace all the properties on the given subscription
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to update</param>
        /// <param name="body">The new properties</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateSubscriptionProperties2Async(string tenant, string @namespace, string topic, string subName, System.Collections.Generic.IDictionary<string, string> body, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Replace all the properties on the given subscription
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to update</param>
        /// <param name="body">The new properties</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateSubscriptionProperties2Async(string tenant, string @namespace, string topic, string subName, System.Collections.Generic.IDictionary<string, string> body, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get replicated subscription status on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetReplicatedSubscriptionStatus2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get replicated subscription status on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetReplicatedSubscriptionStatus2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Enable or disable a replicated subscription on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Whether to enable replicated subscription</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetReplicatedSubscriptionStatus2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, bool body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Enable or disable a replicated subscription on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Whether to enable replicated subscription</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetReplicatedSubscriptionStatus2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, bool body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Reset subscription to message position closest to given position.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to reset position on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId to reset back to (ledgerId:entryId)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ResetCursorOnPosition2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, ResetCursorData messageId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Reset subscription to message position closest to given position.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to reset position on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId to reset back to (ledgerId:entryId)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ResetCursorOnPosition2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, ResetCursorData messageId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Reset subscription to message position closest to absolute timestamp (in ms).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to reset position on</param>
        /// <param name="timestamp">the timestamp to reset back</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ResetCursor2Async(string tenant, string @namespace, string topic, string subName, long timestamp, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Reset subscription to message position closest to absolute timestamp (in ms).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to reset position on</param>
        /// <param name="timestamp">the timestamp to reset back</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ResetCursor2Async(string tenant, string @namespace, string topic, string subName, long timestamp, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Skipping messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="numMessages">The number of messages to skip</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SkipMessages2Async(string tenant, string @namespace, string topic, string subName, int numMessages, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Skipping messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="numMessages">The number of messages to skip</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SkipMessages2Async(string tenant, string @namespace, string topic, string subName, int numMessages, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Skip all messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SkipAllMessages2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Skip all messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SkipAllMessages2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Create a subscription on the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subscriptionName">Subscription to create position on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId where to create the subscription. It can be 'latest', 'earliest' or (ledgerId:entryId)</param>
        /// <param name="replicated">Is replicated required to perform this operation</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreateSubscription2Async(string tenant, string @namespace, string topic, string subscriptionName, bool? authoritative, ResetCursorData messageId, bool? replicated);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a subscription on the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subscriptionName">Subscription to create position on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId where to create the subscription. It can be 'latest', 'earliest' or (ledgerId:entryId)</param>
        /// <param name="replicated">Is replicated required to perform this operation</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreateSubscription2Async(string tenant, string @namespace, string topic, string subscriptionName, bool? authoritative, ResetCursorData messageId, bool? replicated, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionDispatchRate3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionDispatchRate3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscription message dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscriptionDispatchRate3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, DispatchRateImpl body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscription message dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscriptionDispatchRate3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSubscriptionDispatchRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSubscriptionDispatchRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get is enable sub type fors specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionTypesEnabled3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get is enable sub type fors specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionTypesEnabled3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set is enable sub types for specified topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Enable sub types for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscriptionTypesEnabled3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Collections.Generic.IEnumerable<Anonymous6> body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set is enable sub types for specified topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Enable sub types for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscriptionTypesEnabled3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Collections.Generic.IEnumerable<Anonymous6> body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove subscription types enabled for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSubscriptionTypesEnabled3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove subscription types enabled for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSubscriptionTypesEnabled3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the list of persistent subscriptions for a given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptions2Async(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of persistent subscriptions for a given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptions2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Terminate a topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task Terminate2Async(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Terminate a topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task Terminate2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Terminate all partitioned topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task TerminatePartitionedTopic2Async(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Terminate all partitioned topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task TerminatePartitionedTopic2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Truncate a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task TruncateTopic2Async(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Truncate a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task TruncateTopic2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Unload a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UnloadTopic2Async(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unload a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UnloadTopic2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionLevelDispatchRate2Async(string tenant, string @namespace, string topic, string subName, bool? applied, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetSubscriptionLevelDispatchRate2Async(string tenant, string @namespace, string topic, string subName, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscription message dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscriptionLevelDispatchRate2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, bool? isGlobal, DispatchRateImpl body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscription message dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetSubscriptionLevelDispatchRate2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, bool? isGlobal, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSubscriptionLevelDispatchRate2Async(string tenant, string @namespace, string topic, string subName, bool? isGlobal, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveSubscriptionLevelDispatchRate2Async(string tenant, string @namespace, string topic, string subName, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the default quota
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetDefaultResourceQuotaAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the default quota
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetDefaultResourceQuotaAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set the default quota
        /// </summary>
        /// <param name="body">Default resource quota</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> SetDefaultResourceQuotaAsync(ResourceQuota body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set the default quota
        /// </summary>
        /// <param name="body">Default resource quota</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> SetDefaultResourceQuotaAsync(ResourceQuota body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get resource quota of a namespace bundle.
        /// </summary>
        /// <param name="tenant">Tenant name</param>
        /// <param name="namespace">Namespace name within the specified tenant</param>
        /// <param name="bundle">Namespace bundle range</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetNamespaceBundleResourceQuotaAsync(string tenant, string @namespace, string bundle);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get resource quota of a namespace bundle.
        /// </summary>
        /// <param name="tenant">Tenant name</param>
        /// <param name="namespace">Namespace name within the specified tenant</param>
        /// <param name="bundle">Namespace bundle range</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetNamespaceBundleResourceQuotaAsync(string tenant, string @namespace, string bundle, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Set resource quota on a namespace.
        /// </summary>
        /// <param name="tenant">Tenant name</param>
        /// <param name="namespace">Namespace name within the specified tenant</param>
        /// <param name="bundle">Namespace bundle range</param>
        /// <param name="body">Resource quota for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetNamespaceBundleResourceQuotaAsync(string tenant, string @namespace, string bundle, ResourceQuota body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set resource quota on a namespace.
        /// </summary>
        /// <param name="tenant">Tenant name</param>
        /// <param name="namespace">Namespace name within the specified tenant</param>
        /// <param name="bundle">Namespace bundle range</param>
        /// <param name="body">Resource quota for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetNamespaceBundleResourceQuotaAsync(string tenant, string @namespace, string bundle, ResourceQuota body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Remove resource quota for a namespace.
        /// </summary>
        /// <param name="tenant">Tenant name</param>
        /// <param name="namespace">Namespace name within the specified tenant</param>
        /// <param name="bundle">Namespace bundle range</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveNamespaceBundleResourceQuotaAsync(string tenant, string @namespace, string bundle);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove resource quota for a namespace.
        /// </summary>
        /// <param name="tenant">Tenant name</param>
        /// <param name="namespace">Namespace name within the specified tenant</param>
        /// <param name="bundle">Namespace bundle range</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveNamespaceBundleResourceQuotaAsync(string tenant, string @namespace, string bundle, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the list of all the resourcegroups.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetResourceGroupsAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of all the resourcegroups.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetResourceGroupsAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the rate limiters specified for a resourcegroup.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ResourceGroup> GetResourceGroupAsync(string resourcegroup);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the rate limiters specified for a resourcegroup.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ResourceGroup> GetResourceGroupAsync(string resourcegroup, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Creates a new resourcegroup with the specified rate limiters
        /// </summary>
        /// <param name="body">Rate limiters for the resourcegroup</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreateOrUpdateResourceGroupAsync(string resourcegroup, ResourceGroup body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates a new resourcegroup with the specified rate limiters
        /// </summary>
        /// <param name="body">Rate limiters for the resourcegroup</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreateOrUpdateResourceGroupAsync(string resourcegroup, ResourceGroup body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete a resourcegroup.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteResourceGroupAsync(string resourcegroup);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a resourcegroup.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteResourceGroupAsync(string resourcegroup, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// test the schema compatibility
        /// </summary>
        /// <param name="body">A JSON value presenting a schema payload. An example of the expected schema can be found down here.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<IsCompatibilityResponse> TestCompatibilityAsync(string tenant, string @namespace, string topic, PostSchemaPayload body, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// test the schema compatibility
        /// </summary>
        /// <param name="body">A JSON value presenting a schema payload. An example of the expected schema can be found down here.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<IsCompatibilityResponse> TestCompatibilityAsync(string tenant, string @namespace, string topic, PostSchemaPayload body, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the schema of a topic
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSchemaResponse> GetSchemaAsync(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the schema of a topic
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSchemaResponse> GetSchemaAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Update the schema of a topic
        /// </summary>
        /// <param name="body">A JSON value presenting a schema payload. An example of the expected schema can be found down here.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PostSchemaResponse> PostSchemaAsync(string tenant, string @namespace, string topic, PostSchemaPayload body, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update the schema of a topic
        /// </summary>
        /// <param name="body">A JSON value presenting a schema payload. An example of the expected schema can be found down here.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PostSchemaResponse> PostSchemaAsync(string tenant, string @namespace, string topic, PostSchemaPayload body, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete the schema of a topic
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteSchemaResponse> DeleteSchemaAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? force);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete the schema of a topic
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteSchemaResponse> DeleteSchemaAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? force, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the schema of a topic at a given version
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSchemaResponse> GetSchema2Async(string tenant, string @namespace, string topic, string version, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the schema of a topic at a given version
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSchemaResponse> GetSchema2Async(string tenant, string @namespace, string topic, string version, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the all schemas of a topic
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAllVersionsSchemaResponse> GetAllSchemasAsync(string tenant, string @namespace, string topic, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the all schemas of a topic
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAllVersionsSchemaResponse> GetAllSchemasAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// get the version of the schema
        /// </summary>
        /// <param name="body">A JSON value presenting a schema payload. An example of the expected schema can be found down here.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<LongSchemaVersion> GetVersionBySchemaAsync(string tenant, string @namespace, string topic, PostSchemaPayload body, bool? authoritative);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// get the version of the schema
        /// </summary>
        /// <param name="body">A JSON value presenting a schema payload. An example of the expected schema can be found down here.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<LongSchemaVersion> GetVersionBySchemaAsync(string tenant, string @namespace, string topic, PostSchemaPayload body, bool? authoritative, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the list of existing tenants.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetTenantsAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of existing tenants.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetTenantsAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the admin configuration for a given tenant.
        /// </summary>
        /// <param name="tenant">The tenant name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetTenantAdminAsync(string tenant);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the admin configuration for a given tenant.
        /// </summary>
        /// <param name="tenant">The tenant name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetTenantAdminAsync(string tenant, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Update the admins for a tenant.
        /// </summary>
        /// <param name="tenant">The tenant name</param>
        /// <param name="body">TenantInfo</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateTenantAsync(string tenant, TenantInfo body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update the admins for a tenant.
        /// </summary>
        /// <param name="tenant">The tenant name</param>
        /// <param name="body">TenantInfo</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateTenantAsync(string tenant, TenantInfo body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Create a new tenant.
        /// </summary>
        /// <param name="tenant">The tenant name</param>
        /// <param name="body">TenantInfo</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreateTenantAsync(string tenant, TenantInfo body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a new tenant.
        /// </summary>
        /// <param name="tenant">The tenant name</param>
        /// <param name="body">TenantInfo</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CreateTenantAsync(string tenant, TenantInfo body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Delete a tenant and all namespaces and topics under it.
        /// </summary>
        /// <param name="tenant">The tenant name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteTenantAsync(string tenant, bool? force);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a tenant and all namespaces and topics under it.
        /// </summary>
        /// <param name="tenant">The tenant name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteTenantAsync(string tenant, bool? force, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get metrics for all functions owned by worker
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<WorkerFunctionInstanceStats>> GetStatsAllAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get metrics for all functions owned by worker
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<WorkerFunctionInstanceStats>> GetStatsAllAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Gets the metrics for Monitoring
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Metrics>> GetMetrics2Async();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets the metrics for Monitoring
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Metrics>> GetMetrics2Async(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Fetches information about which Pulsar Functions are assigned to which Pulsar clusters
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, object>> GetAssignmentsAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fetches information about which Pulsar Functions are assigned to which Pulsar clusters
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, object>> GetAssignmentsAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Fetches information about the Pulsar cluster running Pulsar Functions
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<WorkerInfo>> GetClusterAllAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fetches information about the Pulsar cluster running Pulsar Functions
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<WorkerInfo>> GetClusterAllAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Fetches info about the leader node of the Pulsar cluster running Pulsar Functions
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkerInfo> GetClusterLeaderAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fetches info about the leader node of the Pulsar cluster running Pulsar Functions
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkerInfo> GetClusterLeaderAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Checks if this node is the leader and is ready to service requests
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<bool> IsLeaderReadyAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Checks if this node is the leader and is ready to service requests
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<bool> IsLeaderReadyAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Fetches a list of supported Pulsar IO connectors currently running in cluster mode
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<object>> GetConnectorsListAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fetches a list of supported Pulsar IO connectors currently running in cluster mode
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<object>> GetConnectorsListAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the status of any ongoing drain operation at this worker
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<LongRunningProcessStatus> GetDrainStatusAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the status of any ongoing drain operation at this worker
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<LongRunningProcessStatus> GetDrainStatusAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Drains this worker, i.e., moves its work-assignments to other workers
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DrainAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Drains this worker, i.e., moves its work-assignments to other workers
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DrainAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get the status of any ongoing drain operation at the specified worker
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<LongRunningProcessStatus> GetDrainStatusFromLeaderAsync(string workerId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the status of any ongoing drain operation at the specified worker
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<LongRunningProcessStatus> GetDrainStatusFromLeaderAsync(string workerId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Drains the specified worker, i.e., moves its work-assignments to other workers
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DrainAtLeaderAsync(string workerId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Drains the specified worker, i.e., moves its work-assignments to other workers
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DrainAtLeaderAsync(string workerId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Triggers a rebalance of functions to workers
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RebalanceAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Triggers a rebalance of functions to workers
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RebalanceAsync(System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class PulsarAdminRESTAPIClient : IPulsarAdminRESTAPIClient
    {
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public PulsarAdminRESTAPIClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// Gets raw information for all the bookies in the cluster
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<BookiesClusterInfo> GetAllBookiesAsync()
        {
            return GetAllBookiesAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets raw information for all the bookies in the cluster
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BookiesClusterInfo> GetAllBookiesAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("bookies/all");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BookiesClusterInfo>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Gets the rack placement information for all the bookies in the cluster
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, System.Collections.Generic.IDictionary<string, BookieInfo>>> GetBookiesRackInfoAsync()
        {
            return GetBookiesRackInfoAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets the rack placement information for all the bookies in the cluster
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, System.Collections.Generic.IDictionary<string, BookieInfo>>> GetBookiesRackInfoAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("bookies/racks-info");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, System.Collections.Generic.IDictionary<string, BookieInfo>>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Gets the rack placement information for a specific bookie in the cluster
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<BookieInfo> GetBookieRackInfoAsync(string bookie)
        {
            return GetBookieRackInfoAsync(bookie, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets the rack placement information for a specific bookie in the cluster
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BookieInfo> GetBookieRackInfoAsync(string bookie, System.Threading.CancellationToken cancellationToken)
        {
            if (bookie == null)
                throw new System.ArgumentNullException("bookie");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("bookies/racks-info/{bookie}");
            urlBuilder_.Replace("{bookie}", System.Uri.EscapeDataString(ConvertToString(bookie, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BookieInfo>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Updates the rack placement information for a specific bookie in the cluster (note. bookie address format:`address:port`)
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task UpdateBookieRackInfoAsync(string bookie, string group)
        {
            return UpdateBookieRackInfoAsync(bookie, group, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates the rack placement information for a specific bookie in the cluster (note. bookie address format:`address:port`)
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UpdateBookieRackInfoAsync(string bookie, string group, System.Threading.CancellationToken cancellationToken)
        {
            if (bookie == null)
                throw new System.ArgumentNullException("bookie");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("bookies/racks-info/{bookie}?");
            urlBuilder_.Replace("{bookie}", System.Uri.EscapeDataString(ConvertToString(bookie, System.Globalization.CultureInfo.InvariantCulture)));
            if (group != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("group") + "=").Append(System.Uri.EscapeDataString(ConvertToString(group, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Removed the rack placement information for a specific bookie in the cluster
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteBookieRackInfoAsync(string bookie)
        {
            return DeleteBookieRackInfoAsync(bookie, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Removed the rack placement information for a specific bookie in the cluster
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteBookieRackInfoAsync(string bookie, System.Threading.CancellationToken cancellationToken)
        {
            if (bookie == null)
                throw new System.ArgumentNullException("bookie");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("bookies/racks-info/{bookie}");
            urlBuilder_.Replace("{bookie}", System.Uri.EscapeDataString(ConvertToString(bookie, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the stats for the Netty allocator. Available allocators are 'default' and 'ml-cache'
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<AllocatorStats> GetAllocatorStatsAsync(string allocator)
        {
            return GetAllocatorStatsAsync(allocator, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the stats for the Netty allocator. Available allocators are 'default' and 'ml-cache'
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AllocatorStats> GetAllocatorStatsAsync(string allocator, System.Threading.CancellationToken cancellationToken)
        {
            if (allocator == null)
                throw new System.ArgumentNullException("allocator");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("broker-stats/allocator-stats/{allocator}");
            urlBuilder_.Replace("{allocator}", System.Uri.EscapeDataString(ConvertToString(allocator, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AllocatorStats>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get pending bookie client op stats by namespace
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, PendingBookieOpsStats>> GetPendingBookieOpsStatsAsync()
        {
            return GetPendingBookieOpsStatsAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get pending bookie client op stats by namespace
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, PendingBookieOpsStats>> GetPendingBookieOpsStatsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("broker-stats/bookieops");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, PendingBookieOpsStats>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Broker availability report
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, ResourceUnit>> GetBrokerResourceAvailabilityAsync(string tenant, string @namespace)
        {
            return GetBrokerResourceAvailabilityAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Broker availability report
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, ResourceUnit>> GetBrokerResourceAvailabilityAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("broker-stats/broker-resource-availability/{tenant}/{namespace}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, ResourceUnit>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Load-manager doesn\'t support operation", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get Load for this broker
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<LoadReport> GetLoadReportAsync()
        {
            return GetLoadReportAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get Load for this broker
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<LoadReport> GetLoadReportAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("broker-stats/load-report");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LoadReport>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get all the mbean details of this broker JVM
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Metrics>> GetMBeansAsync()
        {
            return GetMBeansAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get all the mbean details of this broker JVM
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Metrics>> GetMBeansAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("broker-stats/mbeans");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<Metrics>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Gets the metrics for Monitoring
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Metrics>> GetMetricsAsync()
        {
            return GetMetricsAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets the metrics for Monitoring
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Metrics>> GetMetricsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("broker-stats/metrics");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<Metrics>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get all the topic stats by namespace
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<OutputStream> GetTopics2Async()
        {
            return GetTopics2Async(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get all the topic stats by namespace
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<OutputStream> GetTopics2Async(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("broker-stats/topics");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<OutputStream>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the list of active brokers (web service addresses) in the local cluster.If authorization is not enabled
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetActiveBrokersAsync()
        {
            return GetActiveBrokersAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of active brokers (web service addresses) in the local cluster.If authorization is not enabled
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetActiveBrokersAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("brokers");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication required", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("This operation requires super-user access", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// An REST endpoint to trigger backlogQuotaCheck
        /// </summary>
        /// <returns>Everything is OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task BacklogQuotaCheckAsync()
        {
            return BacklogQuotaCheckAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// An REST endpoint to trigger backlogQuotaCheck
        /// </summary>
        /// <returns>Everything is OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task BacklogQuotaCheckAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("brokers/backlog-quota-check");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get all updatable dynamic configurations's name
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetDynamicConfigurationNameAsync()
        {
            return GetDynamicConfigurationNameAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get all updatable dynamic configurations's name
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetDynamicConfigurationNameAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("brokers/configuration");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("You don\'t have admin permission to get configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get all runtime configurations. This operation requires Pulsar super-user privileges.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetRuntimeConfigurationAsync()
        {
            return GetRuntimeConfigurationAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get all runtime configurations. This operation requires Pulsar super-user privileges.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetRuntimeConfigurationAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("brokers/configuration/runtime");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get value of all dynamic configurations' value overridden on local config
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetAllDynamicConfigurationsAsync()
        {
            return GetAllDynamicConfigurationsAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get value of all dynamic configurations' value overridden on local config
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetAllDynamicConfigurationsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("brokers/configuration/values");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("You don\'t have admin permission to view configuration", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Configuration not found", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete dynamic ServiceConfiguration into metadata only. This operation requires Pulsar super-user privileges.
        /// </summary>
        /// <returns>Service configuration updated successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteDynamicConfigurationAsync(string configName)
        {
            return DeleteDynamicConfigurationAsync(configName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete dynamic ServiceConfiguration into metadata only. This operation requires Pulsar super-user privileges.
        /// </summary>
        /// <returns>Service configuration updated successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteDynamicConfigurationAsync(string configName, System.Threading.CancellationToken cancellationToken)
        {
            if (configName == null)
                throw new System.ArgumentNullException("configName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("brokers/configuration/{configName}");
            urlBuilder_.Replace("{configName}", System.Uri.EscapeDataString(ConvertToString(configName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("You don\'t have admin permission to update service-configuration", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid dynamic-config value", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update dynamic serviceconfiguration into zk only. This operation requires Pulsar super-user privileges.
        /// </summary>
        /// <returns>Service configuration updated successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task UpdateDynamicConfigurationAsync(string configName, string configValue)
        {
            return UpdateDynamicConfigurationAsync(configName, configValue, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update dynamic serviceconfiguration into zk only. This operation requires Pulsar super-user privileges.
        /// </summary>
        /// <returns>Service configuration updated successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UpdateDynamicConfigurationAsync(string configName, string configValue, System.Threading.CancellationToken cancellationToken)
        {
            if (configName == null)
                throw new System.ArgumentNullException("configName");

            if (configValue == null)
                throw new System.ArgumentNullException("configValue");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("brokers/configuration/{configName}/{configValue}");
            urlBuilder_.Replace("{configName}", System.Uri.EscapeDataString(ConvertToString(configName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{configValue}", System.Uri.EscapeDataString(ConvertToString(configValue, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("You don\'t have admin permission to update service-configuration", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Configuration not found", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid dynamic-config value", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Run a healthCheck against the broker
        /// </summary>
        /// <returns>Everything is OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task HealthCheckAsync(TopicVersion? topicVersion)
        {
            return HealthCheckAsync(topicVersion, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Run a healthCheck against the broker
        /// </summary>
        /// <returns>Everything is OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task HealthCheckAsync(TopicVersion? topicVersion, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("brokers/health?");
            if (topicVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("topicVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(topicVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the internal configuration data
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<InternalConfigurationData> GetInternalConfigurationDataAsync()
        {
            return GetInternalConfigurationDataAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the internal configuration data
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<InternalConfigurationData> GetInternalConfigurationDataAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("brokers/internal-configuration");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InternalConfigurationData>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the information of the leader broker.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<BrokerInfo> GetLeaderBrokerAsync()
        {
            return GetLeaderBrokerAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the information of the leader broker.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BrokerInfo> GetLeaderBrokerAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("brokers/leaderBroker");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BrokerInfo>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication required", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("This operation requires super-user access", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Leader broker not found", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Check if the broker is fully initialized
        /// </summary>
        /// <returns>Broker is ready</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task IsReadyAsync()
        {
            return IsReadyAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Check if the broker is fully initialized
        /// </summary>
        /// <returns>Broker is ready</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task IsReadyAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("brokers/ready");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Broker is not ready", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Shutdown broker gracefully.
        /// </summary>
        /// <param name="maxConcurrentUnloadPerSec">if the value absent(value=0) means no concurrent limitation.</param>
        /// <returns>Execute shutdown command successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ShutDownBrokerGracefullyAsync(int? maxConcurrentUnloadPerSec, bool? forcedTerminateTopic)
        {
            return ShutDownBrokerGracefullyAsync(maxConcurrentUnloadPerSec, forcedTerminateTopic, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Shutdown broker gracefully.
        /// </summary>
        /// <param name="maxConcurrentUnloadPerSec">if the value absent(value=0) means no concurrent limitation.</param>
        /// <returns>Execute shutdown command successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ShutDownBrokerGracefullyAsync(int? maxConcurrentUnloadPerSec, bool? forcedTerminateTopic, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("brokers/shutdown?");
            if (maxConcurrentUnloadPerSec != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxConcurrentUnloadPerSec") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxConcurrentUnloadPerSec, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (forcedTerminateTopic != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("forcedTerminateTopic") + "=").Append(System.Uri.EscapeDataString(ConvertToString(forcedTerminateTopic, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("You don\'t have admin permission to update service-configuration", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get version of current broker
        /// </summary>
        /// <returns>Everything is OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<string> VersionAsync()
        {
            return VersionAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get version of current broker
        /// </summary>
        /// <returns>Everything is OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<string> VersionAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("brokers/version");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the list of namespaces served by the specific broker
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, NamespaceOwnershipStatus>> GetOwnedNamespacesAsync(string clusterName, string broker_webserviceurl)
        {
            return GetOwnedNamespacesAsync(clusterName, broker_webserviceurl, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of namespaces served by the specific broker
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, NamespaceOwnershipStatus>> GetOwnedNamespacesAsync(string clusterName, string broker_webserviceurl, System.Threading.CancellationToken cancellationToken)
        {
            if (clusterName == null)
                throw new System.ArgumentNullException("clusterName");

            if (broker_webserviceurl == null)
                throw new System.ArgumentNullException("broker_webserviceurl");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("brokers/{clusterName}/{broker-webserviceurl}/ownedNamespaces");
            urlBuilder_.Replace("{clusterName}", System.Uri.EscapeDataString(ConvertToString(clusterName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{broker-webserviceurl}", System.Uri.EscapeDataString(ConvertToString(broker_webserviceurl, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, NamespaceOwnershipStatus>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the cluster", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the list of active brokers (web service addresses) in the cluster.If authorization is not enabled, any cluster name is valid.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetActiveBrokers2Async(string cluster)
        {
            return GetActiveBrokers2Async(cluster, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of active brokers (web service addresses) in the cluster.If authorization is not enabled, any cluster name is valid.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetActiveBrokers2Async(string cluster, System.Threading.CancellationToken cancellationToken)
        {
            if (cluster == null)
                throw new System.ArgumentNullException("cluster");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("brokers/{cluster}");
            urlBuilder_.Replace("{cluster}", System.Uri.EscapeDataString(ConvertToString(cluster, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve this cluster", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication required", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("This operation requires super-user access", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster does not exist: cluster={clustername}", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the list of all the Pulsar clusters.
        /// </summary>
        /// <returns>Return a list of clusters.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetClustersAsync()
        {
            return GetClustersAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of all the Pulsar clusters.
        /// </summary>
        /// <returns>Return a list of clusters.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetClustersAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("clusters");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the configuration for the specified cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>Return the cluster data.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ClusterData> GetClusterAsync(string cluster)
        {
            return GetClusterAsync(cluster, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the configuration for the specified cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>Return the cluster data.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ClusterData> GetClusterAsync(string cluster, System.Threading.CancellationToken cancellationToken)
        {
            if (cluster == null)
                throw new System.ArgumentNullException("cluster");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("clusters/{cluster}");
            urlBuilder_.Replace("{cluster}", System.Uri.EscapeDataString(ConvertToString(cluster, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ClusterData>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster doesn\'t exist.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update the configuration for a cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="body">The cluster data</param>
        /// <returns>Cluster has been updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task UpdateClusterAsync(string cluster, ClusterData body)
        {
            return UpdateClusterAsync(cluster, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update the configuration for a cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="body">The cluster data</param>
        /// <returns>Cluster has been updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UpdateClusterAsync(string cluster, ClusterData body, System.Threading.CancellationToken cancellationToken)
        {
            if (cluster == null)
                throw new System.ArgumentNullException("cluster");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("clusters/{cluster}");
            urlBuilder_.Replace("{cluster}", System.Uri.EscapeDataString(ConvertToString(cluster, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission or policies are read-only.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster doesn\'t exist.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create a new cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="body">The cluster data</param>
        /// <returns>Cluster has been created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task CreateClusterAsync(string cluster, ClusterData body)
        {
            return CreateClusterAsync(cluster, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a new cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="body">The cluster data</param>
        /// <returns>Cluster has been created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task CreateClusterAsync(string cluster, ClusterData body, System.Threading.CancellationToken cancellationToken)
        {
            if (cluster == null)
                throw new System.ArgumentNullException("cluster");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("clusters/{cluster}");
            urlBuilder_.Replace("{cluster}", System.Uri.EscapeDataString(ConvertToString(cluster, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("You don\'t have admin permission to create the cluster.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster already exists.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster name is not valid.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete an existing cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>Cluster has been deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteClusterAsync(string cluster)
        {
            return DeleteClusterAsync(cluster, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete an existing cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>Cluster has been deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteClusterAsync(string cluster, System.Threading.CancellationToken cancellationToken)
        {
            if (cluster == null)
                throw new System.ArgumentNullException("cluster");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("clusters/{cluster}");
            urlBuilder_.Replace("{cluster}", System.Uri.EscapeDataString(ConvertToString(cluster, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission or policies are read-only.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster doesn\'t exist.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster is not empty.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the cluster failure domains.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, FailureDomain>> GetFailureDomainsAsync(string cluster)
        {
            return GetFailureDomainsAsync(cluster, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the cluster failure domains.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, FailureDomain>> GetFailureDomainsAsync(string cluster, System.Threading.CancellationToken cancellationToken)
        {
            if (cluster == null)
                throw new System.ArgumentNullException("cluster");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("clusters/{cluster}/failureDomains");
            urlBuilder_.Replace("{cluster}", System.Uri.EscapeDataString(ConvertToString(cluster, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, FailureDomain>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get a domain in a cluster
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="domainName">The failure domain name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FailureDomain> GetDomainAsync(string cluster, string domainName)
        {
            return GetDomainAsync(cluster, domainName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get a domain in a cluster
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="domainName">The failure domain name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FailureDomain> GetDomainAsync(string cluster, string domainName, System.Threading.CancellationToken cancellationToken)
        {
            if (cluster == null)
                throw new System.ArgumentNullException("cluster");

            if (domainName == null)
                throw new System.ArgumentNullException("domainName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("clusters/{cluster}/failureDomains/{domainName}");
            urlBuilder_.Replace("{cluster}", System.Uri.EscapeDataString(ConvertToString(cluster, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{domainName}", System.Uri.EscapeDataString(ConvertToString(domainName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FailureDomain>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("FailureDomain doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set the failure domain of the cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="domainName">The failure domain name</param>
        /// <param name="body">The configuration data of a failure domain</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetFailureDomainAsync(string cluster, string domainName, FailureDomain body)
        {
            return SetFailureDomainAsync(cluster, domainName, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set the failure domain of the cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="domainName">The failure domain name</param>
        /// <param name="body">The configuration data of a failure domain</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetFailureDomainAsync(string cluster, string domainName, FailureDomain body, System.Threading.CancellationToken cancellationToken)
        {
            if (cluster == null)
                throw new System.ArgumentNullException("cluster");

            if (domainName == null)
                throw new System.ArgumentNullException("domainName");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("clusters/{cluster}/failureDomains/{domainName}");
            urlBuilder_.Replace("{cluster}", System.Uri.EscapeDataString(ConvertToString(cluster, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{domainName}", System.Uri.EscapeDataString(ConvertToString(domainName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failure domain doesn\'t exist.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Broker already exists in another domain.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster doesn\'t exist.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error.", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete the failure domain of the cluster
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="domainName">The failure domain name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteFailureDomainAsync(string cluster, string domainName)
        {
            return DeleteFailureDomainAsync(cluster, domainName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete the failure domain of the cluster
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="domainName">The failure domain name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteFailureDomainAsync(string cluster, string domainName, System.Threading.CancellationToken cancellationToken)
        {
            if (cluster == null)
                throw new System.ArgumentNullException("cluster");

            if (domainName == null)
                throw new System.ArgumentNullException("domainName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("clusters/{cluster}/failureDomains/{domainName}");
            urlBuilder_.Replace("{cluster}", System.Uri.EscapeDataString(ConvertToString(cluster, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{domainName}", System.Uri.EscapeDataString(ConvertToString(domainName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission or policy is read only", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("FailureDomain doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the namespace isolation policies assigned to the cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, NamespaceIsolationData>> GetNamespaceIsolationPoliciesAsync(string cluster)
        {
            return GetNamespaceIsolationPoliciesAsync(cluster, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the namespace isolation policies assigned to the cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, NamespaceIsolationData>> GetNamespaceIsolationPoliciesAsync(string cluster, System.Threading.CancellationToken cancellationToken)
        {
            if (cluster == null)
                throw new System.ArgumentNullException("cluster");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("clusters/{cluster}/namespaceIsolationPolicies");
            urlBuilder_.Replace("{cluster}", System.Uri.EscapeDataString(ConvertToString(cluster, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, NamespaceIsolationData>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster doesn\'t exist.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get list of brokers with namespace-isolation policies attached to them.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<BrokerNamespaceIsolationData>> GetBrokersWithNamespaceIsolationPolicyAsync(string cluster)
        {
            return GetBrokersWithNamespaceIsolationPolicyAsync(cluster, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get list of brokers with namespace-isolation policies attached to them.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<BrokerNamespaceIsolationData>> GetBrokersWithNamespaceIsolationPolicyAsync(string cluster, System.Threading.CancellationToken cancellationToken)
        {
            if (cluster == null)
                throw new System.ArgumentNullException("cluster");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("clusters/{cluster}/namespaceIsolationPolicies/brokers");
            urlBuilder_.Replace("{cluster}", System.Uri.EscapeDataString(ConvertToString(cluster, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<BrokerNamespaceIsolationData>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace-isolation policies not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster doesn\'t exist.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get a broker with namespace-isolation policies attached to it.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="broker">The broker name (&lt;broker-hostname&gt;:&lt;web-service-port&gt;)</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<BrokerNamespaceIsolationData> GetBrokerWithNamespaceIsolationPolicyAsync(string cluster, string broker)
        {
            return GetBrokerWithNamespaceIsolationPolicyAsync(cluster, broker, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get a broker with namespace-isolation policies attached to it.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="broker">The broker name (&lt;broker-hostname&gt;:&lt;web-service-port&gt;)</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BrokerNamespaceIsolationData> GetBrokerWithNamespaceIsolationPolicyAsync(string cluster, string broker, System.Threading.CancellationToken cancellationToken)
        {
            if (cluster == null)
                throw new System.ArgumentNullException("cluster");

            if (broker == null)
                throw new System.ArgumentNullException("broker");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("clusters/{cluster}/namespaceIsolationPolicies/brokers/{broker}");
            urlBuilder_.Replace("{cluster}", System.Uri.EscapeDataString(ConvertToString(cluster, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{broker}", System.Uri.EscapeDataString(ConvertToString(broker, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BrokerNamespaceIsolationData>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace-isolation policies/ Broker not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster doesn\'t exist.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the single namespace isolation policy assigned to the cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="policyName">The name of the namespace isolation policy</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<NamespaceIsolationData> GetNamespaceIsolationPolicyAsync(string cluster, string policyName)
        {
            return GetNamespaceIsolationPolicyAsync(cluster, policyName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the single namespace isolation policy assigned to the cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="policyName">The name of the namespace isolation policy</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<NamespaceIsolationData> GetNamespaceIsolationPolicyAsync(string cluster, string policyName, System.Threading.CancellationToken cancellationToken)
        {
            if (cluster == null)
                throw new System.ArgumentNullException("cluster");

            if (policyName == null)
                throw new System.ArgumentNullException("policyName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("clusters/{cluster}/namespaceIsolationPolicies/{policyName}");
            urlBuilder_.Replace("{cluster}", System.Uri.EscapeDataString(ConvertToString(cluster, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{policyName}", System.Uri.EscapeDataString(ConvertToString(policyName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NamespaceIsolationData>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Policy doesn\'t exist.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster doesn\'t exist.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set namespace isolation policy.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="policyName">The namespace isolation policy name</param>
        /// <param name="body">The namespace isolation policy data</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetNamespaceIsolationPolicyAsync(string cluster, string policyName, NamespaceIsolationData body)
        {
            return SetNamespaceIsolationPolicyAsync(cluster, policyName, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set namespace isolation policy.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="policyName">The namespace isolation policy name</param>
        /// <param name="body">The namespace isolation policy data</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetNamespaceIsolationPolicyAsync(string cluster, string policyName, NamespaceIsolationData body, System.Threading.CancellationToken cancellationToken)
        {
            if (cluster == null)
                throw new System.ArgumentNullException("cluster");

            if (policyName == null)
                throw new System.ArgumentNullException("policyName");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("clusters/{cluster}/namespaceIsolationPolicies/{policyName}");
            urlBuilder_.Replace("{cluster}", System.Uri.EscapeDataString(ConvertToString(cluster, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{policyName}", System.Uri.EscapeDataString(ConvertToString(policyName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace isolation policy data is invalid.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission or policies are read-only.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace isolation policy doesn\'t exist.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster doesn\'t exist.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error.", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete namespace isolation policy.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="policyName">The namespace isolation policy name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteNamespaceIsolationPolicyAsync(string cluster, string policyName)
        {
            return DeleteNamespaceIsolationPolicyAsync(cluster, policyName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete namespace isolation policy.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="policyName">The namespace isolation policy name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteNamespaceIsolationPolicyAsync(string cluster, string policyName, System.Threading.CancellationToken cancellationToken)
        {
            if (cluster == null)
                throw new System.ArgumentNullException("cluster");

            if (policyName == null)
                throw new System.ArgumentNullException("policyName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("clusters/{cluster}/namespaceIsolationPolicies/{policyName}");
            urlBuilder_.Replace("{cluster}", System.Uri.EscapeDataString(ConvertToString(cluster, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{policyName}", System.Uri.EscapeDataString(ConvertToString(policyName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission or policies are read only.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace isolation policy doesn\'t exist.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster doesn\'t exist.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error.", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the peer-cluster data for the specified cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetPeerClusterAsync(string cluster)
        {
            return GetPeerClusterAsync(cluster, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the peer-cluster data for the specified cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetPeerClusterAsync(string cluster, System.Threading.CancellationToken cancellationToken)
        {
            if (cluster == null)
                throw new System.ArgumentNullException("cluster");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("clusters/{cluster}/peers");
            urlBuilder_.Replace("{cluster}", System.Uri.EscapeDataString(ConvertToString(cluster, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster doesn\'t exist.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update peer-cluster-list for a cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="body">The list of peer cluster names</param>
        /// <returns>Cluster has been updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetPeerClusterNamesAsync(string cluster, System.Collections.Generic.IEnumerable<string> body)
        {
            return SetPeerClusterNamesAsync(cluster, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update peer-cluster-list for a cluster.
        /// </summary>
        /// <param name="cluster">The cluster name</param>
        /// <param name="body">The list of peer cluster names</param>
        /// <returns>Cluster has been updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetPeerClusterNamesAsync(string cluster, System.Collections.Generic.IEnumerable<string> body, System.Threading.CancellationToken cancellationToken)
        {
            if (cluster == null)
                throw new System.ArgumentNullException("cluster");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("clusters/{cluster}/peers");
            urlBuilder_.Replace("{cluster}", System.Uri.EscapeDataString(ConvertToString(cluster, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission or policies are read-only.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster doesn\'t exist.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Peer cluster doesn\'t exist.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get all namespaces that are grouped by given anti-affinity group in a given cluster. api can be only accessed by admin of any of the existing tenant
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetAntiAffinityNamespacesAsync(string cluster, string group, string tenant)
        {
            return GetAntiAffinityNamespacesAsync(cluster, group, tenant, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get all namespaces that are grouped by given anti-affinity group in a given cluster. api can be only accessed by admin of any of the existing tenant
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetAntiAffinityNamespacesAsync(string cluster, string group, string tenant, System.Threading.CancellationToken cancellationToken)
        {
            if (cluster == null)
                throw new System.ArgumentNullException("cluster");

            if (group == null)
                throw new System.ArgumentNullException("group");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{cluster}/antiAffinity/{group}?");
            urlBuilder_.Replace("{cluster}", System.Uri.EscapeDataString(ConvertToString(cluster, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{group}", System.Uri.EscapeDataString(ConvertToString(group, System.Globalization.CultureInfo.InvariantCulture)));
            if (tenant != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenant") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cluster not exist/Anti-affinity group can\'t be empty.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the bookie-affinity-group from namespace-local policy.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<BookieAffinityGroupData> GetBookieAffinityGroupAsync(string property, string @namespace)
        {
            return GetBookieAffinityGroupAsync(property, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the bookie-affinity-group from namespace-local policy.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BookieAffinityGroupData> GetBookieAffinityGroupAsync(string property, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (property == null)
                throw new System.ArgumentNullException("property");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{property}/{namespace}/persistence/bookieAffinity");
            urlBuilder_.Replace("{property}", System.Uri.EscapeDataString(ConvertToString(property, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BookieAffinityGroupData>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete the bookie-affinity-group from namespace-local policy.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteBookieAffinityGroupAsync(string property, string @namespace)
        {
            return DeleteBookieAffinityGroupAsync(property, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete the bookie-affinity-group from namespace-local policy.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteBookieAffinityGroupAsync(string property, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (property == null)
                throw new System.ArgumentNullException("property");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{property}/{namespace}/persistence/bookieAffinity");
            urlBuilder_.Replace("{property}", System.Uri.EscapeDataString(ConvertToString(property, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the list of all the namespaces for a certain tenant.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetTenantNamespacesAsync(string tenant)
        {
            return GetTenantNamespacesAsync(tenant, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of all the namespaces for a certain tenant.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetTenantNamespacesAsync(string tenant, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the dump all the policies specified for a namespace.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Policies> GetPoliciesAsync(string tenant, string @namespace)
        {
            return GetPoliciesAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the dump all the policies specified for a namespace.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Policies> GetPoliciesAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Policies>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Creates a new namespace with the specified policies
        /// </summary>
        /// <param name="body">Policies for the namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task CreateNamespaceAsync(string tenant, string @namespace, Policies body)
        {
            return CreateNamespaceAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates a new namespace with the specified policies
        /// </summary>
        /// <param name="body">Policies for the namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task CreateNamespaceAsync(string tenant, string @namespace, Policies body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace already exists", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace name is not valid", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete a namespace and all the topics under it.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteNamespaceAsync(string tenant, string @namespace, bool? force, bool? authoritative)
        {
            return DeleteNamespaceAsync(tenant, @namespace, force, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a namespace and all the topics under it.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteNamespaceAsync(string tenant, string @namespace, bool? force, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (force != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("force") + "=").Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Broker doesn\'t allow forced deletion of namespaces", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace is not empty", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get anti-affinity group of a namespace.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<string> GetNamespaceAntiAffinityGroupAsync(string tenant, string @namespace)
        {
            return GetNamespaceAntiAffinityGroupAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get anti-affinity group of a namespace.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<string> GetNamespaceAntiAffinityGroupAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/antiAffinity");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set anti-affinity group for a namespace
        /// </summary>
        /// <param name="body">Anti-affinity group for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetNamespaceAntiAffinityGroupAsync(string tenant, string @namespace, string body)
        {
            return SetNamespaceAntiAffinityGroupAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set anti-affinity group for a namespace
        /// </summary>
        /// <param name="body">Anti-affinity group for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetNamespaceAntiAffinityGroupAsync(string tenant, string @namespace, string body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/antiAffinity");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid antiAffinityGroup", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove anti-affinity group of a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveNamespaceAntiAffinityGroupAsync(string tenant, string @namespace)
        {
            return RemoveNamespaceAntiAffinityGroupAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove anti-affinity group of a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveNamespaceAntiAffinityGroupAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/antiAffinity");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get autoSubscriptionCreation info in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetAutoSubscriptionCreationAsync(string tenant, string @namespace)
        {
            return GetAutoSubscriptionCreationAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get autoSubscriptionCreation info in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetAutoSubscriptionCreationAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/autoSubscriptionCreation");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Override broker's allowAutoSubscriptionCreation setting for a namespace
        /// </summary>
        /// <param name="body">Settings for automatic subscription creation</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetAutoSubscriptionCreationAsync(string tenant, string @namespace, AutoSubscriptionCreationOverride body)
        {
            return SetAutoSubscriptionCreationAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Override broker's allowAutoSubscriptionCreation setting for a namespace
        /// </summary>
        /// <param name="body">Settings for automatic subscription creation</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetAutoSubscriptionCreationAsync(string tenant, string @namespace, AutoSubscriptionCreationOverride body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/autoSubscriptionCreation");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid autoSubscriptionCreation override", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove override of broker's allowAutoSubscriptionCreation in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveAutoSubscriptionCreationAsync(string tenant, string @namespace)
        {
            return RemoveAutoSubscriptionCreationAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove override of broker's allowAutoSubscriptionCreation in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveAutoSubscriptionCreationAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/autoSubscriptionCreation");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get autoTopicCreation info in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetAutoTopicCreationAsync(string tenant, string @namespace)
        {
            return GetAutoTopicCreationAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get autoTopicCreation info in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetAutoTopicCreationAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/autoTopicCreation");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Override broker's allowAutoTopicCreation setting for a namespace
        /// </summary>
        /// <param name="body">Settings for automatic topic creation</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetAutoTopicCreationAsync(string tenant, string @namespace, AutoTopicCreationOverride body)
        {
            return SetAutoTopicCreationAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Override broker's allowAutoTopicCreation setting for a namespace
        /// </summary>
        /// <param name="body">Settings for automatic topic creation</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetAutoTopicCreationAsync(string tenant, string @namespace, AutoTopicCreationOverride body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/autoTopicCreation");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid autoTopicCreation override", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 406)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The number of partitions should be less than or equal to maxNumPartitionsPerPartitionedTopic", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove override of broker's allowAutoTopicCreation in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveAutoTopicCreationAsync(string tenant, string @namespace)
        {
            return RemoveAutoTopicCreationAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove override of broker's allowAutoTopicCreation in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveAutoTopicCreationAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/autoTopicCreation");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set a backlog quota for all the topics on a namespace.
        /// </summary>
        /// <param name="body">Backlog quota for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetBacklogQuotaAsync(string tenant, string @namespace, BacklogQuotaType? backlogQuotaType, BacklogQuota body)
        {
            return SetBacklogQuotaAsync(tenant, @namespace, backlogQuotaType, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set a backlog quota for all the topics on a namespace.
        /// </summary>
        /// <param name="body">Backlog quota for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetBacklogQuotaAsync(string tenant, string @namespace, BacklogQuotaType? backlogQuotaType, BacklogQuota body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/backlogQuota?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (backlogQuotaType != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("backlogQuotaType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(backlogQuotaType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Specified backlog quota exceeds retention quota. Increase retention quota and retry request", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove a backlog quota policy from a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveBacklogQuotaAsync(string tenant, string @namespace, BacklogQuotaType2? backlogQuotaType)
        {
            return RemoveBacklogQuotaAsync(tenant, @namespace, backlogQuotaType, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove a backlog quota policy from a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveBacklogQuotaAsync(string tenant, string @namespace, BacklogQuotaType2? backlogQuotaType, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/backlogQuota?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (backlogQuotaType != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("backlogQuotaType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(backlogQuotaType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get backlog quota map on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetBacklogQuotaMapAsync(string tenant, string @namespace)
        {
            return GetBacklogQuotaMapAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get backlog quota map on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetBacklogQuotaMapAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/backlogQuotaMap");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the bundles split data.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetBundlesDataAsync(string tenant, string @namespace)
        {
            return GetBundlesDataAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the bundles split data.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetBundlesDataAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/bundles");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace is not setup to split in bundles", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Clear backlog for all topics on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ClearNamespaceBacklogAsync(string tenant, string @namespace, bool? authoritative)
        {
            return ClearNamespaceBacklogAsync(tenant, @namespace, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Clear backlog for all topics on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ClearNamespaceBacklogAsync(string tenant, string @namespace, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/clearBacklog?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin or operate permission on the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Clear backlog for a given subscription on all topics on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ClearNamespaceBacklogForSubscriptionAsync(string tenant, string @namespace, string subscription, bool? authoritative)
        {
            return ClearNamespaceBacklogForSubscriptionAsync(tenant, @namespace, subscription, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Clear backlog for a given subscription on all topics on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ClearNamespaceBacklogForSubscriptionAsync(string tenant, string @namespace, string subscription, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (subscription == null)
                throw new System.ArgumentNullException("subscription");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/clearBacklog/{subscription}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subscription}", System.Uri.EscapeDataString(ConvertToString(subscription, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin or operate permission on the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Maximum number of uncompacted bytes in topics before compaction is triggered.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetCompactionThresholdAsync(string tenant, string @namespace)
        {
            return GetCompactionThresholdAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Maximum number of uncompacted bytes in topics before compaction is triggered.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetCompactionThresholdAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/compactionThreshold");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set maximum number of uncompacted bytes in a topic before compaction is triggered.
        /// </summary>
        /// <param name="body">Maximum number of uncompacted bytes in a topic of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetCompactionThresholdPUTAsync(string tenant, string @namespace, long body)
        {
            return SetCompactionThresholdPUTAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maximum number of uncompacted bytes in a topic before compaction is triggered.
        /// </summary>
        /// <param name="body">Maximum number of uncompacted bytes in a topic of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetCompactionThresholdPUTAsync(string tenant, string @namespace, long body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/compactionThreshold");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("compactionThreshold value is not valid", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete maximum number of uncompacted bytes in a topic before compaction is triggered.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteCompactionThresholdAsync(string tenant, string @namespace)
        {
            return DeleteCompactionThresholdAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete maximum number of uncompacted bytes in a topic before compaction is triggered.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteCompactionThresholdAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/compactionThreshold");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get broker side deduplication for all topics in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetDeduplicationAsync(string tenant, string @namespace)
        {
            return GetDeduplicationAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get broker side deduplication for all topics in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetDeduplicationAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/deduplication");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Enable or disable broker side deduplication for all topics in a namespace
        /// </summary>
        /// <param name="body">Flag for disabling or enabling broker side deduplication for all topics in the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ModifyDeduplicationAsync(string tenant, string @namespace, bool body)
        {
            return ModifyDeduplicationAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Enable or disable broker side deduplication for all topics in a namespace
        /// </summary>
        /// <param name="body">Flag for disabling or enabling broker side deduplication for all topics in the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ModifyDeduplicationAsync(string tenant, string @namespace, bool body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/deduplication");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove broker side deduplication for all topics in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveDeduplicationAsync(string tenant, string @namespace)
        {
            return RemoveDeduplicationAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove broker side deduplication for all topics in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveDeduplicationAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/deduplication");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get deduplicationSnapshotInterval config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetDeduplicationSnapshotIntervalAsync(string tenant, string @namespace)
        {
            return GetDeduplicationSnapshotIntervalAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get deduplicationSnapshotInterval config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetDeduplicationSnapshotIntervalAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/deduplicationSnapshotInterval");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set deduplicationSnapshotInterval config on a namespace.
        /// </summary>
        /// <param name="body">Interval to take deduplication snapshot per topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetDeduplicationSnapshotIntervalAsync(string tenant, string @namespace, int body)
        {
            return SetDeduplicationSnapshotIntervalAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set deduplicationSnapshotInterval config on a namespace.
        /// </summary>
        /// <param name="body">Interval to take deduplication snapshot per topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetDeduplicationSnapshotIntervalAsync(string tenant, string @namespace, int body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/deduplicationSnapshotInterval");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get delayed delivery messages config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetDelayedDeliveryPoliciesAsync(string tenant, string @namespace)
        {
            return GetDelayedDeliveryPoliciesAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get delayed delivery messages config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetDelayedDeliveryPoliciesAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/delayedDelivery");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set delayed delivery messages config on a namespace.
        /// </summary>
        /// <param name="body">Delayed delivery policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetDelayedDeliveryPoliciesAsync(string tenant, string @namespace, DelayedDeliveryPolicies body)
        {
            return SetDelayedDeliveryPoliciesAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set delayed delivery messages config on a namespace.
        /// </summary>
        /// <param name="body">Delayed delivery policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetDelayedDeliveryPoliciesAsync(string tenant, string @namespace, DelayedDeliveryPolicies body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/delayedDelivery");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete delayed delivery messages config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveDelayedDeliveryPoliciesAsync(string tenant, string @namespace)
        {
            return RemoveDelayedDeliveryPoliciesAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete delayed delivery messages config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveDelayedDeliveryPoliciesAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/delayedDelivery");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get dispatch-rate configured for the namespace, null means dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetDispatchRateAsync(string tenant, string @namespace)
        {
            return GetDispatchRateAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get dispatch-rate configured for the namespace, null means dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetDispatchRateAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/dispatchRate");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <param name="body">Dispatch rate for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetDispatchRateAsync(string tenant, string @namespace, DispatchRateImpl body)
        {
            return SetDispatchRateAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <param name="body">Dispatch rate for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetDispatchRateAsync(string tenant, string @namespace, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/dispatchRate");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteDispatchRateAsync(string tenant, string @namespace)
        {
            return DeleteDispatchRateAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteDispatchRateAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/dispatchRate");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get message encryption required status in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetEncryptionRequiredAsync(string tenant, string @namespace)
        {
            return GetEncryptionRequiredAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get message encryption required status in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetEncryptionRequiredAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/encryptionRequired");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Message encryption is required or not for all topics in a namespace
        /// </summary>
        /// <param name="body">Flag defining if message encryption is required</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ModifyEncryptionRequiredAsync(string tenant, string @namespace, bool body)
        {
            return ModifyEncryptionRequiredAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Message encryption is required or not for all topics in a namespace
        /// </summary>
        /// <param name="body">Flag defining if message encryption is required</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ModifyEncryptionRequiredAsync(string tenant, string @namespace, bool body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/encryptionRequired");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get maxConsumersPerSubscription config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetEntryFiltersPerTopicAsync(string tenant, string @namespace)
        {
            return GetEntryFiltersPerTopicAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxConsumersPerSubscription config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetEntryFiltersPerTopicAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/entryFilters");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set entry filters for namespace
        /// </summary>
        /// <param name="body">entry filters</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetEntryFiltersPerTopicAsync(string tenant, string @namespace, EntryFilters body)
        {
            return SetEntryFiltersPerTopicAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set entry filters for namespace
        /// </summary>
        /// <param name="body">entry filters</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetEntryFiltersPerTopicAsync(string tenant, string @namespace, EntryFilters body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/entryFilters");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove entry filters for namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveNamespaceEntryFiltersAsync(string tenant, string @namespace)
        {
            return RemoveNamespaceEntryFiltersAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove entry filters for namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveNamespaceEntryFiltersAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/entryFilters");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid TTL", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get inactive topic policies config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetInactiveTopicPoliciesAsync(string tenant, string @namespace)
        {
            return GetInactiveTopicPoliciesAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get inactive topic policies config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetInactiveTopicPoliciesAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/inactiveTopicPolicies");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set inactive topic policies config on a namespace.
        /// </summary>
        /// <param name="body">Inactive topic policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetInactiveTopicPoliciesPOSTAsync(string tenant, string @namespace, InactiveTopicPolicies body)
        {
            return SetInactiveTopicPoliciesPOSTAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set inactive topic policies config on a namespace.
        /// </summary>
        /// <param name="body">Inactive topic policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetInactiveTopicPoliciesPOSTAsync(string tenant, string @namespace, InactiveTopicPolicies body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/inactiveTopicPolicies");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove inactive topic policies from a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveInactiveTopicPoliciesAsync(string tenant, string @namespace)
        {
            return RemoveInactiveTopicPoliciesAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove inactive topic policies from a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveInactiveTopicPoliciesAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/inactiveTopicPolicies");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// The flag of whether allow auto update schema
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetIsAllowAutoUpdateSchemaAsync(string tenant, string @namespace)
        {
            return GetIsAllowAutoUpdateSchemaAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// The flag of whether allow auto update schema
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetIsAllowAutoUpdateSchemaAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/isAllowAutoUpdateSchema");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update flag of whether allow auto update schema
        /// </summary>
        /// <param name="body">Flag of whether to allow auto update schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetIsAllowAutoUpdateSchemaAsync(string tenant, string @namespace, bool body)
        {
            return SetIsAllowAutoUpdateSchemaAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update flag of whether allow auto update schema
        /// </summary>
        /// <param name="body">Flag of whether to allow auto update schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetIsAllowAutoUpdateSchemaAsync(string tenant, string @namespace, bool body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/isAllowAutoUpdateSchema");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get maxConsumersPerSubscription config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxConsumersPerSubscriptionAsync(string tenant, string @namespace)
        {
            return GetMaxConsumersPerSubscriptionAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxConsumersPerSubscription config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxConsumersPerSubscriptionAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxConsumersPerSubscription");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set maxConsumersPerSubscription configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum consumers per subscription</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMaxConsumersPerSubscriptionAsync(string tenant, string @namespace, int body)
        {
            return SetMaxConsumersPerSubscriptionAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxConsumersPerSubscription configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum consumers per subscription</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMaxConsumersPerSubscriptionAsync(string tenant, string @namespace, int body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxConsumersPerSubscription");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("maxConsumersPerSubscription value is not valid", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set maxConsumersPerSubscription configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveMaxConsumersPerSubscriptionAsync(string tenant, string @namespace)
        {
            return RemoveMaxConsumersPerSubscriptionAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxConsumersPerSubscription configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveMaxConsumersPerSubscriptionAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxConsumersPerSubscription");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("maxConsumersPerSubscription value is not valid", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get maxConsumersPerTopic config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxConsumersPerTopicAsync(string tenant, string @namespace)
        {
            return GetMaxConsumersPerTopicAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxConsumersPerTopic config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxConsumersPerTopicAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxConsumersPerTopic");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set maxConsumersPerTopic configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum consumers per topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMaxConsumersPerTopicAsync(string tenant, string @namespace, int body)
        {
            return SetMaxConsumersPerTopicAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxConsumersPerTopic configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum consumers per topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMaxConsumersPerTopicAsync(string tenant, string @namespace, int body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxConsumersPerTopic");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("maxConsumersPerTopic value is not valid", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove maxConsumersPerTopic configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveMaxConsumersPerTopicAsync(string tenant, string @namespace)
        {
            return RemoveMaxConsumersPerTopicAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxConsumersPerTopic configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveMaxConsumersPerTopicAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxConsumersPerTopic");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get maxProducersPerTopic config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxProducersPerTopicAsync(string tenant, string @namespace)
        {
            return GetMaxProducersPerTopicAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxProducersPerTopic config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxProducersPerTopicAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxProducersPerTopic");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set maxProducersPerTopic configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum producers per topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMaxProducersPerTopicAsync(string tenant, string @namespace, int body)
        {
            return SetMaxProducersPerTopicAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxProducersPerTopic configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum producers per topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMaxProducersPerTopicAsync(string tenant, string @namespace, int body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxProducersPerTopic");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("maxProducersPerTopic value is not valid", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove maxProducersPerTopic configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveMaxProducersPerTopicAsync(string tenant, string @namespace)
        {
            return RemoveMaxProducersPerTopicAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxProducersPerTopic configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveMaxProducersPerTopicAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxProducersPerTopic");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get maxSubscriptionsPerTopic config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxSubscriptionsPerTopicAsync(string tenant, string @namespace)
        {
            return GetMaxSubscriptionsPerTopicAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxSubscriptionsPerTopic config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxSubscriptionsPerTopicAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxSubscriptionsPerTopic");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set maxSubscriptionsPerTopic configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum subscriptions per topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMaxSubscriptionsPerTopicAsync(string tenant, string @namespace, int body)
        {
            return SetMaxSubscriptionsPerTopicAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxSubscriptionsPerTopic configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum subscriptions per topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMaxSubscriptionsPerTopicAsync(string tenant, string @namespace, int body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxSubscriptionsPerTopic");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("maxUnackedMessagesPerSubscription value is not valid", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove maxSubscriptionsPerTopic configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveMaxSubscriptionsPerTopicAsync(string tenant, string @namespace)
        {
            return RemoveMaxSubscriptionsPerTopicAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxSubscriptionsPerTopic configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveMaxSubscriptionsPerTopicAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxSubscriptionsPerTopic");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get maxTopicsPerNamespace config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxTopicsPerNamespaceAsync(string tenant, string @namespace)
        {
            return GetMaxTopicsPerNamespaceAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxTopicsPerNamespace config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxTopicsPerNamespaceAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxTopicsPerNamespace");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set maxTopicsPerNamespace config on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum topics for specific namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetInactiveTopicPoliciesPOST2Async(string tenant, string @namespace, int body)
        {
            return SetInactiveTopicPoliciesPOST2Async(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxTopicsPerNamespace config on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum topics for specific namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetInactiveTopicPoliciesPOST2Async(string tenant, string @namespace, int body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxTopicsPerNamespace");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set maxTopicsPerNamespace config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetInactiveTopicPoliciesDELETEAsync(string tenant, string @namespace)
        {
            return SetInactiveTopicPoliciesDELETEAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxTopicsPerNamespace config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetInactiveTopicPoliciesDELETEAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxTopicsPerNamespace");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get maxUnackedMessagesPerConsumer config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxUnackedMessagesPerConsumerAsync(string tenant, string @namespace)
        {
            return GetMaxUnackedMessagesPerConsumerAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxUnackedMessagesPerConsumer config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxUnackedMessagesPerConsumerAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxUnackedMessagesPerConsumer");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set maxConsumersPerTopic configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum unacked messages per consumer</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMaxUnackedMessagesPerConsumerAsync(string tenant, string @namespace, int body)
        {
            return SetMaxUnackedMessagesPerConsumerAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxConsumersPerTopic configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum unacked messages per consumer</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMaxUnackedMessagesPerConsumerAsync(string tenant, string @namespace, int body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxUnackedMessagesPerConsumer");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("maxUnackedMessagesPerConsumer value is not valid", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove maxUnackedMessagesPerConsumer config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveMaxUnackedmessagesPerConsumerAsync(string tenant, string @namespace)
        {
            return RemoveMaxUnackedmessagesPerConsumerAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxUnackedMessagesPerConsumer config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveMaxUnackedmessagesPerConsumerAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxUnackedMessagesPerConsumer");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get maxUnackedMessagesPerSubscription config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxUnackedmessagesPerSubscriptionAsync(string tenant, string @namespace)
        {
            return GetMaxUnackedmessagesPerSubscriptionAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxUnackedMessagesPerSubscription config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxUnackedmessagesPerSubscriptionAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxUnackedMessagesPerSubscription");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set maxUnackedMessagesPerSubscription configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum unacked messages per subscription</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMaxUnackedMessagesPerSubscriptionAsync(string tenant, string @namespace, int body)
        {
            return SetMaxUnackedMessagesPerSubscriptionAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxUnackedMessagesPerSubscription configuration on a namespace.
        /// </summary>
        /// <param name="body">Number of maximum unacked messages per subscription</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMaxUnackedMessagesPerSubscriptionAsync(string tenant, string @namespace, int body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxUnackedMessagesPerSubscription");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("maxUnackedMessagesPerSubscription value is not valid", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove maxUnackedMessagesPerSubscription config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveMaxUnackedmessagesPerSubscriptionAsync(string tenant, string @namespace)
        {
            return RemoveMaxUnackedmessagesPerSubscriptionAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxUnackedMessagesPerSubscription config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveMaxUnackedmessagesPerSubscriptionAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/maxUnackedMessagesPerSubscription");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the message TTL for the namespace
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<int> GetNamespaceMessageTTLAsync(string tenant, string @namespace)
        {
            return GetNamespaceMessageTTLAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the message TTL for the namespace
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<int> GetNamespaceMessageTTLAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/messageTTL");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<int>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set message TTL in seconds for namespace
        /// </summary>
        /// <param name="body">TTL in seconds for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetNamespaceMessageTTLAsync(string tenant, string @namespace, int body)
        {
            return SetNamespaceMessageTTLAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set message TTL in seconds for namespace
        /// </summary>
        /// <param name="body">TTL in seconds for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetNamespaceMessageTTLAsync(string tenant, string @namespace, int body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/messageTTL");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid TTL", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove message TTL in seconds for namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveNamespaceMessageTTLAsync(string tenant, string @namespace)
        {
            return RemoveNamespaceMessageTTLAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove message TTL in seconds for namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveNamespaceMessageTTLAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/messageTTL");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid TTL", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Number of milliseconds to wait before deleting a ledger segment which has been offloaded from the Pulsar cluster's local storage (i.e. BookKeeper)
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetOffloadDeletionLagAsync(string tenant, string @namespace)
        {
            return GetOffloadDeletionLagAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Number of milliseconds to wait before deleting a ledger segment which has been offloaded from the Pulsar cluster's local storage (i.e. BookKeeper)
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetOffloadDeletionLagAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/offloadDeletionLagMs");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set number of milliseconds to wait before deleting a ledger segment which has been offloaded from the Pulsar cluster's local storage (i.e. BookKeeper)
        /// </summary>
        /// <param name="body">New number of milliseconds to wait before deleting a ledger segment which has been offloaded</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetOffloadDeletionLagAsync(string tenant, string @namespace, long body)
        {
            return SetOffloadDeletionLagAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set number of milliseconds to wait before deleting a ledger segment which has been offloaded from the Pulsar cluster's local storage (i.e. BookKeeper)
        /// </summary>
        /// <param name="body">New number of milliseconds to wait before deleting a ledger segment which has been offloaded</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetOffloadDeletionLagAsync(string tenant, string @namespace, long body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/offloadDeletionLagMs");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("offloadDeletionLagMs value is not valid", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Clear the namespace configured offload deletion lag. The topics in the namespace will fallback to using the default configured deletion lag for the broker
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ClearOffloadDeletionLagAsync(string tenant, string @namespace)
        {
            return ClearOffloadDeletionLagAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Clear the namespace configured offload deletion lag. The topics in the namespace will fallback to using the default configured deletion lag for the broker
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ClearOffloadDeletionLagAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/offloadDeletionLagMs");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get offload configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetOffloadPoliciesAsync(string tenant, string @namespace)
        {
            return GetOffloadPoliciesAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get offload configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetOffloadPoliciesAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/offloadPolicies");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set offload configuration on a namespace.
        /// </summary>
        /// <param name="body">Offload policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetOffloadPoliciesAsync(string tenant, string @namespace, OffloadPoliciesImpl body)
        {
            return SetOffloadPoliciesAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set offload configuration on a namespace.
        /// </summary>
        /// <param name="body">Offload policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetOffloadPoliciesAsync(string tenant, string @namespace, OffloadPoliciesImpl body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/offloadPolicies");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("OffloadPolicies is empty or driver is not supported or bucket is not valid", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Maximum number of bytes stored on the pulsar cluster for a topic, before the broker will start offloading to longterm storage
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetOffloadThresholdAsync(string tenant, string @namespace)
        {
            return GetOffloadThresholdAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Maximum number of bytes stored on the pulsar cluster for a topic, before the broker will start offloading to longterm storage
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetOffloadThresholdAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/offloadThreshold");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set maximum number of bytes stored on the pulsar cluster for a topic, before the broker will start offloading to longterm storage
        /// </summary>
        /// <param name="body">Maximum number of bytes stored on the pulsar cluster for a topic of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetOffloadThresholdAsync(string tenant, string @namespace, long body)
        {
            return SetOffloadThresholdAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maximum number of bytes stored on the pulsar cluster for a topic, before the broker will start offloading to longterm storage
        /// </summary>
        /// <param name="body">Maximum number of bytes stored on the pulsar cluster for a topic of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetOffloadThresholdAsync(string tenant, string @namespace, long body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/offloadThreshold");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("offloadThreshold value is not valid", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Retrieve the permissions for a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetPermissionsAsync(string tenant, string @namespace)
        {
            return GetPermissionsAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Retrieve the permissions for a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetPermissionsAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/permissions");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace is not empty", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Retrieve the permissions for a subscription.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetPermissionOnSubscriptionAsync(string tenant, string @namespace)
        {
            return GetPermissionOnSubscriptionAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Retrieve the permissions for a subscription.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetPermissionOnSubscriptionAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/permissions/subscription");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace is not empty", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Grant a new permission to a role on a namespace.
        /// </summary>
        /// <param name="body">List of permissions for the specified role</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GrantPermissionOnNamespaceAsync(string tenant, string @namespace, string role, System.Collections.Generic.IEnumerable<Anonymous> body)
        {
            return GrantPermissionOnNamespaceAsync(tenant, @namespace, role, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Grant a new permission to a role on a namespace.
        /// </summary>
        /// <param name="body">List of permissions for the specified role</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GrantPermissionOnNamespaceAsync(string tenant, string @namespace, string role, System.Collections.Generic.IEnumerable<Anonymous> body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (role == null)
                throw new System.ArgumentNullException("role");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/permissions/{role}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{role}", System.Uri.EscapeDataString(ConvertToString(role, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 501)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authorization is not enabled", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Revoke all permissions to a role on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RevokePermissionsOnNamespaceAsync(string tenant, string @namespace, string role)
        {
            return RevokePermissionsOnNamespaceAsync(tenant, @namespace, role, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Revoke all permissions to a role on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RevokePermissionsOnNamespaceAsync(string tenant, string @namespace, string role, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (role == null)
                throw new System.ArgumentNullException("role");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/permissions/{role}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{role}", System.Uri.EscapeDataString(ConvertToString(role, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the persistence configuration for a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetPersistenceAsync(string tenant, string @namespace)
        {
            return GetPersistenceAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the persistence configuration for a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetPersistenceAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/persistence");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set the persistence configuration for all the topics on a namespace.
        /// </summary>
        /// <param name="body">Persistence policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetPersistenceAsync(string tenant, string @namespace, PersistencePolicies body)
        {
            return SetPersistenceAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set the persistence configuration for all the topics on a namespace.
        /// </summary>
        /// <param name="body">Persistence policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetPersistenceAsync(string tenant, string @namespace, PersistencePolicies body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/persistence");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid persistence policies", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete the persistence configuration for all topics on a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeletePersistenceAsync(string tenant, string @namespace)
        {
            return DeletePersistenceAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete the persistence configuration for all topics on a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeletePersistenceAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/persistence");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set the bookie-affinity-group to namespace-persistent policy.
        /// </summary>
        /// <param name="body">Bookie affinity group for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetBookieAffinityGroupAsync(string tenant, string @namespace, BookieAffinityGroupData body)
        {
            return SetBookieAffinityGroupAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set the bookie-affinity-group to namespace-persistent policy.
        /// </summary>
        /// <param name="body">Bookie affinity group for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetBookieAffinityGroupAsync(string tenant, string @namespace, BookieAffinityGroupData body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/persistence/bookieAffinity");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get key value pair properties for a given namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetPropertiesAsync(string tenant, string @namespace)
        {
            return GetPropertiesAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get key value pair properties for a given namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetPropertiesAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/properties");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Put key value pairs property on a namespace.
        /// </summary>
        /// <param name="body">Key value pair properties for the namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetPropertiesAsync(string tenant, string @namespace, System.Collections.Generic.IDictionary<string, string> body)
        {
            return SetPropertiesAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Put key value pairs property on a namespace.
        /// </summary>
        /// <param name="body">Key value pair properties for the namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetPropertiesAsync(string tenant, string @namespace, System.Collections.Generic.IDictionary<string, string> body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/properties");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Clear properties on a given namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ClearPropertiesAsync(string tenant, string @namespace)
        {
            return ClearPropertiesAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Clear properties on a given namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ClearPropertiesAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/properties");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get property value for a given key on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetPropertyAsync(string tenant, string @namespace, string key)
        {
            return GetPropertyAsync(tenant, @namespace, key, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get property value for a given key on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetPropertyAsync(string tenant, string @namespace, string key, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (key == null)
                throw new System.ArgumentNullException("key");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/property/{key}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{key}", System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get property value for a given key on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemovePropertyAsync(string tenant, string @namespace, string key)
        {
            return RemovePropertyAsync(tenant, @namespace, key, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get property value for a given key on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemovePropertyAsync(string tenant, string @namespace, string key, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (key == null)
                throw new System.ArgumentNullException("key");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/property/{key}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{key}", System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Put a key value pair property on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetPropertyAsync(string tenant, string @namespace, string key, string value)
        {
            return SetPropertyAsync(tenant, @namespace, key, value, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Put a key value pair property on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetPropertyAsync(string tenant, string @namespace, string key, string value, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (key == null)
                throw new System.ArgumentNullException("key");

            if (value == null)
                throw new System.ArgumentNullException("value");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/property/{key}/{value}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{key}", System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{value}", System.Uri.EscapeDataString(ConvertToString(value, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set offload configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveOffloadPoliciesAsync(string tenant, string @namespace)
        {
            return RemoveOffloadPoliciesAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set offload configuration on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveOffloadPoliciesAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/removeOffloadPolicies");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("OffloadPolicies is empty or driver is not supported or bucket is not valid", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the replication clusters for a namespace.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetNamespaceReplicationClustersAsync(string tenant, string @namespace)
        {
            return GetNamespaceReplicationClustersAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the replication clusters for a namespace.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetNamespaceReplicationClustersAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/replication");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace is not global", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set the replication clusters for a namespace.
        /// </summary>
        /// <param name="body">List of replication clusters</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetNamespaceReplicationClustersAsync(string tenant, string @namespace, System.Collections.Generic.IEnumerable<string> body)
        {
            return SetNamespaceReplicationClustersAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set the replication clusters for a namespace.
        /// </summary>
        /// <param name="body">List of replication clusters</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetNamespaceReplicationClustersAsync(string tenant, string @namespace, System.Collections.Generic.IEnumerable<string> body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/replication");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Peer-cluster can\'t be part of replication-cluster", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace is not global or invalid cluster ids", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get replicator dispatch-rate configured for the namespace, null means replicator dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetReplicatorDispatchRateAsync(string tenant, string @namespace)
        {
            return GetReplicatorDispatchRateAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get replicator dispatch-rate configured for the namespace, null means replicator dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetReplicatorDispatchRateAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/replicatorDispatchRate");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set replicator dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <param name="body">Replicator dispatch rate for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetReplicatorDispatchRateAsync(string tenant, string @namespace, DispatchRateImpl body)
        {
            return SetReplicatorDispatchRateAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set replicator dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <param name="body">Replicator dispatch rate for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetReplicatorDispatchRateAsync(string tenant, string @namespace, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/replicatorDispatchRate");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove replicator dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveReplicatorDispatchRateAsync(string tenant, string @namespace)
        {
            return RemoveReplicatorDispatchRateAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove replicator dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveReplicatorDispatchRateAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/replicatorDispatchRate");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the resource group attached to the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetNamespaceResourceGroupAsync(string tenant, string @namespace)
        {
            return GetNamespaceResourceGroupAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the resource group attached to the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetNamespaceResourceGroupAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/resourcegroup");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete resourcegroup for a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveNamespaceResourceGroupAsync(string tenant, string @namespace)
        {
            return RemoveNamespaceResourceGroupAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete resourcegroup for a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveNamespaceResourceGroupAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/resourcegroup");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid resourcegroup", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set resourcegroup for a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetNamespaceResourceGroupAsync(string tenant, string @namespace, string resourcegroup)
        {
            return SetNamespaceResourceGroupAsync(tenant, @namespace, resourcegroup, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set resourcegroup for a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetNamespaceResourceGroupAsync(string tenant, string @namespace, string resourcegroup, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (resourcegroup == null)
                throw new System.ArgumentNullException("resourcegroup");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/resourcegroup/{resourcegroup}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{resourcegroup}", System.Uri.EscapeDataString(ConvertToString(resourcegroup, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid resourcegroup", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get retention config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetRetentionAsync(string tenant, string @namespace)
        {
            return GetRetentionAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get retention config on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetRetentionAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/retention");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set retention configuration on a namespace.
        /// </summary>
        /// <param name="body">Retention policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetRetentionAsync(string tenant, string @namespace, RetentionPolicies body)
        {
            return SetRetentionAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set retention configuration on a namespace.
        /// </summary>
        /// <param name="body">Retention policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetRetentionAsync(string tenant, string @namespace, RetentionPolicies body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/retention");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Retention Quota must exceed backlog quota", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove retention configuration on a namespace.
        /// </summary>
        /// <param name="body">Retention policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveRetentionAsync(string tenant, string @namespace, RetentionPolicies body)
        {
            return RemoveRetentionAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove retention configuration on a namespace.
        /// </summary>
        /// <param name="body">Retention policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveRetentionAsync(string tenant, string @namespace, RetentionPolicies body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/retention");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Retention Quota must exceed backlog quota", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Trigger the scan of offloaded Ledgers on the LedgerOffloader for the given namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ScanOffloadedLedgersAsync(string tenant, string @namespace)
        {
            return ScanOffloadedLedgersAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Trigger the scan of offloaded Ledgers on the LedgerOffloader for the given namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ScanOffloadedLedgersAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/scanOffloadedLedgers");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// The strategy used to check the compatibility of new schemas, provided by producers, before automatically updating the schema
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response> GetSchemaAutoUpdateCompatibilityStrategyAsync(string tenant, string @namespace)
        {
            return GetSchemaAutoUpdateCompatibilityStrategyAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// The strategy used to check the compatibility of new schemas, provided by producers, before automatically updating the schema
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response> GetSchemaAutoUpdateCompatibilityStrategyAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/schemaAutoUpdateCompatibilityStrategy");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update the strategy used to check the compatibility of new schemas, provided by producers, before automatically updating the schema
        /// </summary>
        /// <param name="body">Strategy used to check the compatibility of new schemas</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetSchemaAutoUpdateCompatibilityStrategyAsync(string tenant, string @namespace, string body)
        {
            return SetSchemaAutoUpdateCompatibilityStrategyAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update the strategy used to check the compatibility of new schemas, provided by producers, before automatically updating the schema
        /// </summary>
        /// <param name="body">Strategy used to check the compatibility of new schemas</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetSchemaAutoUpdateCompatibilityStrategyAsync(string tenant, string @namespace, string body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/schemaAutoUpdateCompatibilityStrategy");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// The strategy of the namespace schema compatibility
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSchemaCompatibilityStrategyAsync(string tenant, string @namespace)
        {
            return GetSchemaCompatibilityStrategyAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// The strategy of the namespace schema compatibility
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSchemaCompatibilityStrategyAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/schemaCompatibilityStrategy");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update the strategy used to check the compatibility of new schema
        /// </summary>
        /// <param name="body">Strategy used to check the compatibility of new schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetSchemaCompatibilityStrategyAsync(string tenant, string @namespace, string body)
        {
            return SetSchemaCompatibilityStrategyAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update the strategy used to check the compatibility of new schema
        /// </summary>
        /// <param name="body">Strategy used to check the compatibility of new schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetSchemaCompatibilityStrategyAsync(string tenant, string @namespace, string body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/schemaCompatibilityStrategy");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get schema validation enforced flag for namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSchemaValidtionEnforcedAsync(string tenant, string @namespace, bool? applied)
        {
            return GetSchemaValidtionEnforcedAsync(tenant, @namespace, applied, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get schema validation enforced flag for namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSchemaValidtionEnforcedAsync(string tenant, string @namespace, bool? applied, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/schemaValidationEnforced?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenants or Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set schema validation enforced flag on namespace.
        /// </summary>
        /// <param name="body">Flag of whether validation is enforced on the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetSchemaValidationEnforcedAsync(string tenant, string @namespace, bool body)
        {
            return SetSchemaValidationEnforcedAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set schema validation enforced flag on namespace.
        /// </summary>
        /// <param name="body">Flag of whether validation is enforced on the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetSchemaValidationEnforcedAsync(string tenant, string @namespace, bool body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/schemaValidationEnforced");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("schemaValidationEnforced value is not valid", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get subscribe-rate configured for the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSubscribeRateAsync(string tenant, string @namespace)
        {
            return GetSubscribeRateAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get subscribe-rate configured for the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSubscribeRateAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/subscribeRate");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set subscribe-rate throttling for all topics of the namespace
        /// </summary>
        /// <param name="body">Subscribe rate for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetSubscribeRateAsync(string tenant, string @namespace, SubscribeRate body)
        {
            return SetSubscribeRateAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set subscribe-rate throttling for all topics of the namespace
        /// </summary>
        /// <param name="body">Subscribe rate for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetSubscribeRateAsync(string tenant, string @namespace, SubscribeRate body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/subscribeRate");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete subscribe-rate throttling for all topics of the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteSubscribeRateAsync(string tenant, string @namespace)
        {
            return DeleteSubscribeRateAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete subscribe-rate throttling for all topics of the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteSubscribeRateAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/subscribeRate");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get subscription auth mode in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSubscriptionAuthModeAsync(string tenant, string @namespace)
        {
            return GetSubscriptionAuthModeAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get subscription auth mode in a namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSubscriptionAuthModeAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/subscriptionAuthMode");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set a subscription auth mode for all the topics on a namespace.
        /// </summary>
        /// <param name="body">Subscription auth mode for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetSubscriptionAuthModeAsync(string tenant, string @namespace, string body)
        {
            return SetSubscriptionAuthModeAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set a subscription auth mode for all the topics on a namespace.
        /// </summary>
        /// <param name="body">Subscription auth mode for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetSubscriptionAuthModeAsync(string tenant, string @namespace, string body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/subscriptionAuthMode");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get subscription dispatch-rate configured for the namespace, null means subscription dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSubscriptionDispatchRateAsync(string tenant, string @namespace)
        {
            return GetSubscriptionDispatchRateAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get subscription dispatch-rate configured for the namespace, null means subscription dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSubscriptionDispatchRateAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/subscriptionDispatchRate");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set Subscription dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <param name="body">Subscription dispatch rate for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetSubscriptionDispatchRateAsync(string tenant, string @namespace, DispatchRateImpl body)
        {
            return SetSubscriptionDispatchRateAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set Subscription dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <param name="body">Subscription dispatch rate for all topics of the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetSubscriptionDispatchRateAsync(string tenant, string @namespace, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/subscriptionDispatchRate");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete Subscription dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteSubscriptionDispatchRateAsync(string tenant, string @namespace)
        {
            return DeleteSubscriptionDispatchRateAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete Subscription dispatch-rate throttling for all topics of the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteSubscriptionDispatchRateAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/subscriptionDispatchRate");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the subscription expiration time for the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSubscriptionExpirationTimeAsync(string tenant, string @namespace)
        {
            return GetSubscriptionExpirationTimeAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the subscription expiration time for the namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSubscriptionExpirationTimeAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/subscriptionExpirationTime");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set subscription expiration time in minutes for namespace
        /// </summary>
        /// <param name="body">Expiration time in minutes for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetSubscriptionExpirationTimeAsync(string tenant, string @namespace, int body)
        {
            return SetSubscriptionExpirationTimeAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set subscription expiration time in minutes for namespace
        /// </summary>
        /// <param name="body">Expiration time in minutes for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetSubscriptionExpirationTimeAsync(string tenant, string @namespace, int body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/subscriptionExpirationTime");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid expiration time", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove subscription expiration time for namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveSubscriptionExpirationTimeAsync(string tenant, string @namespace)
        {
            return RemoveSubscriptionExpirationTimeAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove subscription expiration time for namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveSubscriptionExpirationTimeAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/subscriptionExpirationTime");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// The set of whether allow subscription types
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSubscriptionTypesEnabledAsync(string tenant, string @namespace)
        {
            return GetSubscriptionTypesEnabledAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// The set of whether allow subscription types
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSubscriptionTypesEnabledAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/subscriptionTypesEnabled");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update set of whether allow share sub type
        /// </summary>
        /// <param name="body">Set of whether allow subscription types</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetSubscriptionTypesEnabledAsync(string tenant, string @namespace, System.Collections.Generic.IEnumerable<Anonymous2> body)
        {
            return SetSubscriptionTypesEnabledAsync(tenant, @namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update set of whether allow share sub type
        /// </summary>
        /// <param name="body">Set of whether allow subscription types</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetSubscriptionTypesEnabledAsync(string tenant, string @namespace, System.Collections.Generic.IEnumerable<Anonymous2> body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/subscriptionTypesEnabled");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove subscription types enabled on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveSubscriptionTypesEnabledAsync(string tenant, string @namespace)
        {
            return RemoveSubscriptionTypesEnabledAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove subscription types enabled on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveSubscriptionTypesEnabledAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/subscriptionTypesEnabled");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the list of all the topics under a certain namespace.
        /// </summary>
        /// <param name="includeSystemTopic">Include system topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetTopicsAsync(string tenant, string @namespace, Mode? mode, bool? includeSystemTopic)
        {
            return GetTopicsAsync(tenant, @namespace, mode, includeSystemTopic, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of all the topics under a certain namespace.
        /// </summary>
        /// <param name="includeSystemTopic">Include system topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetTopicsAsync(string tenant, string @namespace, Mode? mode, bool? includeSystemTopic, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/topics?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (mode != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("mode") + "=").Append(System.Uri.EscapeDataString(ConvertToString(mode, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (includeSystemTopic != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("includeSystemTopic") + "=").Append(System.Uri.EscapeDataString(ConvertToString(includeSystemTopic, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin or operate permission on the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Unload namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task UnloadNamespaceAsync(string tenant, string @namespace)
        {
            return UnloadNamespaceAsync(tenant, @namespace, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unload namespace
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UnloadNamespaceAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/unload");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace is already unloaded or Namespace has bundles activated", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Unsubscribes the given subscription on all topics on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task UnsubscribeNamespaceAsync(string tenant, string @namespace, string subscription, bool? authoritative)
        {
            return UnsubscribeNamespaceAsync(tenant, @namespace, subscription, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unsubscribes the given subscription on all topics on a namespace.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UnsubscribeNamespaceAsync(string tenant, string @namespace, string subscription, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (subscription == null)
                throw new System.ArgumentNullException("subscription");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/unsubscribe/{subscription}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subscription}", System.Uri.EscapeDataString(ConvertToString(subscription, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin or operate permission on the namespacen", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete a namespace bundle and all the topics under it.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteNamespaceBundleAsync(string tenant, string @namespace, string bundle, bool? force, bool? authoritative)
        {
            return DeleteNamespaceBundleAsync(tenant, @namespace, bundle, force, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a namespace bundle and all the topics under it.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteNamespaceBundleAsync(string tenant, string @namespace, string bundle, bool? force, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (bundle == null)
                throw new System.ArgumentNullException("bundle");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/{bundle}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{bundle}", System.Uri.EscapeDataString(ConvertToString(bundle, System.Globalization.CultureInfo.InvariantCulture)));
            if (force != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("force") + "=").Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace bundle is not empty", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Clear backlog for all topics on a namespace bundle.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ClearNamespaceBundleBacklogAsync(string tenant, string @namespace, string bundle, bool? authoritative)
        {
            return ClearNamespaceBundleBacklogAsync(tenant, @namespace, bundle, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Clear backlog for all topics on a namespace bundle.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ClearNamespaceBundleBacklogAsync(string tenant, string @namespace, string bundle, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (bundle == null)
                throw new System.ArgumentNullException("bundle");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/{bundle}/clearBacklog?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{bundle}", System.Uri.EscapeDataString(ConvertToString(bundle, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin or operate permission on the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Clear backlog for a given subscription on all topics on a namespace bundle.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ClearNamespaceBundleBacklogForSubscriptionAsync(string tenant, string @namespace, string subscription, string bundle, bool? authoritative)
        {
            return ClearNamespaceBundleBacklogForSubscriptionAsync(tenant, @namespace, subscription, bundle, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Clear backlog for a given subscription on all topics on a namespace bundle.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ClearNamespaceBundleBacklogForSubscriptionAsync(string tenant, string @namespace, string subscription, string bundle, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (subscription == null)
                throw new System.ArgumentNullException("subscription");

            if (bundle == null)
                throw new System.ArgumentNullException("bundle");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/{bundle}/clearBacklog/{subscription}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subscription}", System.Uri.EscapeDataString(ConvertToString(subscription, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{bundle}", System.Uri.EscapeDataString(ConvertToString(bundle, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin or operate permission on the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Split a namespace bundle
        /// </summary>
        /// <param name="body">splitBoundaries</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SplitNamespaceBundleAsync(string tenant, string @namespace, string bundle, bool? authoritative, bool? unload, string splitAlgorithmName, System.Collections.Generic.IEnumerable<long> body)
        {
            return SplitNamespaceBundleAsync(tenant, @namespace, bundle, authoritative, unload, splitAlgorithmName, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Split a namespace bundle
        /// </summary>
        /// <param name="body">splitBoundaries</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SplitNamespaceBundleAsync(string tenant, string @namespace, string bundle, bool? authoritative, bool? unload, string splitAlgorithmName, System.Collections.Generic.IEnumerable<long> body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (bundle == null)
                throw new System.ArgumentNullException("bundle");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/{bundle}/split?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{bundle}", System.Uri.EscapeDataString(ConvertToString(bundle, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (unload != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("unload") + "=").Append(System.Uri.EscapeDataString(ConvertToString(unload, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (splitAlgorithmName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("splitAlgorithmName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(splitAlgorithmName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get hash positions for topics
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetTopicHashPositionsAsync(string tenant, string @namespace, string bundle, System.Collections.Generic.IEnumerable<string> topics)
        {
            return GetTopicHashPositionsAsync(tenant, @namespace, bundle, topics, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get hash positions for topics
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetTopicHashPositionsAsync(string tenant, string @namespace, string bundle, System.Collections.Generic.IEnumerable<string> topics, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (bundle == null)
                throw new System.ArgumentNullException("bundle");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/{bundle}/topicHashPositions?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{bundle}", System.Uri.EscapeDataString(ConvertToString(bundle, System.Globalization.CultureInfo.InvariantCulture)));
            if (topics != null)
            {
                foreach (var item_ in topics) { urlBuilder_.Append(System.Uri.EscapeDataString("topics") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Unload a namespace bundle
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task UnloadNamespaceBundleAsync(string tenant, string @namespace, string bundle, bool? authoritative)
        {
            return UnloadNamespaceBundleAsync(tenant, @namespace, bundle, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unload a namespace bundle
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UnloadNamespaceBundleAsync(string tenant, string @namespace, string bundle, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (bundle == null)
                throw new System.ArgumentNullException("bundle");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/{bundle}/unload?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{bundle}", System.Uri.EscapeDataString(ConvertToString(bundle, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Unsubscribes the given subscription on all topics on a namespace bundle.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task UnsubscribeNamespaceBundleAsync(string tenant, string @namespace, string subscription, string bundle, bool? authoritative)
        {
            return UnsubscribeNamespaceBundleAsync(tenant, @namespace, subscription, bundle, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unsubscribes the given subscription on all topics on a namespace bundle.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UnsubscribeNamespaceBundleAsync(string tenant, string @namespace, string subscription, string bundle, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (subscription == null)
                throw new System.ArgumentNullException("subscription");

            if (bundle == null)
                throw new System.ArgumentNullException("bundle");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("namespaces/{tenant}/{namespace}/{bundle}/unsubscribe/{subscription}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subscription}", System.Uri.EscapeDataString(ConvertToString(subscription, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{bundle}", System.Uri.EscapeDataString(ConvertToString(bundle, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin or operate permission on the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the list of non-persistent topics under a namespace.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="bundle">Specify the bundle name</param>
        /// <param name="includeSystemTopic">Include system topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetListAsync(string tenant, string @namespace, string bundle, bool? includeSystemTopic)
        {
            return GetListAsync(tenant, @namespace, bundle, includeSystemTopic, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of non-persistent topics under a namespace.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="bundle">Specify the bundle name</param>
        /// <param name="includeSystemTopic">Include system topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetListAsync(string tenant, string @namespace, string bundle, bool? includeSystemTopic, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (bundle != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("bundle") + "=").Append(System.Uri.EscapeDataString(ConvertToString(bundle, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (includeSystemTopic != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("includeSystemTopic") + "=").Append(System.Uri.EscapeDataString(ConvertToString(includeSystemTopic, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to manage resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The tenant/namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the list of partitioned topics under a namespace.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="includeSystemTopic">Include system topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetPartitionedTopicListAsync(string tenant, string @namespace, bool? includeSystemTopic)
        {
            return GetPartitionedTopicListAsync(tenant, @namespace, includeSystemTopic, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of partitioned topics under a namespace.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="includeSystemTopic">Include system topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetPartitionedTopicListAsync(string tenant, string @namespace, bool? includeSystemTopic, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/partitioned?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (includeSystemTopic != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("includeSystemTopic") + "=").Append(System.Uri.EscapeDataString(ConvertToString(includeSystemTopic, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin or operate permission on the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("tenant/namespace/topic doesn\'t exit", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the list of non-persistent topics under a namespace bundle.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="bundle">Bundle range of a topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetListFromBundleAsync(string tenant, string @namespace, string bundle)
        {
            return GetListFromBundleAsync(tenant, @namespace, bundle, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of non-persistent topics under a namespace bundle.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="bundle">Bundle range of a topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetListFromBundleAsync(string tenant, string @namespace, string bundle, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (bundle == null)
                throw new System.ArgumentNullException("bundle");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{bundle}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{bundle}", System.Uri.EscapeDataString(ConvertToString(bundle, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to manage resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create a non-partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Key value pair properties for the topic metadata</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task CreateNonPartitionedTopicAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IDictionary<string, string> body)
        {
            return CreateNonPartitionedTopicAsync(tenant, @namespace, topic, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a non-partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Key value pair properties for the topic metadata</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task CreateNonPartitionedTopicAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IDictionary<string, string> body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic already exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed Reason : Name is invalid or Namespace does not have any clusters configured", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="force">Stop all producer/consumer/replicator and delete topic forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteTopicAsync(string tenant, string @namespace, string topic, bool? force, bool? authoritative)
        {
            return DeleteTopicAsync(tenant, @namespace, topic, force, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="force">Stop all producer/consumer/replicator and delete topic forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteTopicAsync(string tenant, string @namespace, string topic, bool? force, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (force != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("force") + "=").Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic has active producers/subscriptions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Expiry messages on all subscriptions of topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="expireTimeInSeconds">Expires beyond the specified number of seconds</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ExpireMessagesForAllSubscriptionsAsync(string tenant, string @namespace, string topic, int expireTimeInSeconds, bool? authoritative)
        {
            return ExpireMessagesForAllSubscriptionsAsync(tenant, @namespace, topic, expireTimeInSeconds, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Expiry messages on all subscriptions of topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="expireTimeInSeconds">Expires beyond the specified number of seconds</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ExpireMessagesForAllSubscriptionsAsync(string tenant, string @namespace, string topic, int expireTimeInSeconds, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (expireTimeInSeconds == null)
                throw new System.ArgumentNullException("expireTimeInSeconds");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/all_subscription/expireMessages/{expireTimeInSeconds}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{expireTimeInSeconds}", System.Uri.EscapeDataString(ConvertToString(expireTimeInSeconds, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic or subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Expiry messages on a non-persistent topic is not allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Can\'t find owner for topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get estimated backlog for offline topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetBacklogAsync(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return GetBacklogAsync(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get estimated backlog for offline topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetBacklogAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/backlog?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set a backlog quota for a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetBacklogQuota2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, BacklogQuotaType3? backlogQuotaType)
        {
            return SetBacklogQuota2Async(tenant, @namespace, topic, authoritative, isGlobal, backlogQuotaType, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set a backlog quota for a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetBacklogQuota2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, BacklogQuotaType3? backlogQuotaType, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/backlogQuota?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (backlogQuotaType != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("backlogQuotaType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(backlogQuotaType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Specified backlog quota exceeds retention quota. Increase retention quota and retry request", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove a backlog quota policy from a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveBacklogQuota2Async(string tenant, string @namespace, string topic, BacklogQuotaType4? backlogQuotaType, bool? authoritative, bool? isGlobal)
        {
            return RemoveBacklogQuota2Async(tenant, @namespace, topic, backlogQuotaType, authoritative, isGlobal, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove a backlog quota policy from a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveBacklogQuota2Async(string tenant, string @namespace, string topic, BacklogQuotaType4? backlogQuotaType, bool? authoritative, bool? isGlobal, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/backlogQuota?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (backlogQuotaType != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("backlogQuotaType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(backlogQuotaType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get backlog quota map on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetBacklogQuotaMap2Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative, bool? isGlobal)
        {
            return GetBacklogQuotaMap2Async(tenant, @namespace, topic, applied, authoritative, isGlobal, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get backlog quota map on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetBacklogQuotaMap2Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative, bool? isGlobal, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/backlogQuotaMap?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic policy does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Calculate backlog size by a message ID (in bytes).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetBacklogSizeByMessageIdAsync(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return GetBacklogSizeByMessageIdAsync(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Calculate backlog size by a message ID (in bytes).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetBacklogSizeByMessageIdAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/backlogSize?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the status of a compaction operation for a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task CompactionStatusAsync(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return CompactionStatusAsync(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the status of a compaction operation for a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task CompactionStatusAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/compaction?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist, or compaction hasn\'t run", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Operation is not allowed on the persistent topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Trigger a compaction operation on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task CompactAsync(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return CompactAsync(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Trigger a compaction operation on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task CompactAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/compaction?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Operation is not allowed on the persistent topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Compaction already running", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetCompactionThreshold2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetCompactionThreshold2Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetCompactionThreshold2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/compactionThreshold?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetCompactionThresholdPOSTAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, long? body)
        {
            return SetCompactionThresholdPOSTAsync(tenant, @namespace, topic, authoritative, isGlobal, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetCompactionThresholdPOSTAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, long? body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/compactionThreshold?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveCompactionThresholdAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveCompactionThresholdAsync(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveCompactionThresholdAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/compactionThreshold?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create missed partitions of an existing partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task CreateMissedPartitionsAsync(string tenant, string @namespace, string topic)
        {
            return CreateMissedPartitionsAsync(tenant, @namespace, topic, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create missed partitions of an existing partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task CreateMissedPartitionsAsync(string tenant, string @namespace, string topic, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/createMissedPartitions");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic name is invalid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get deduplication configuration of a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetDeduplication2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetDeduplication2Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get deduplication configuration of a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetDeduplication2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set deduplication enabled on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">DeduplicationEnabled policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetDeduplicationAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, bool? body)
        {
            return SetDeduplicationAsync(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set deduplication enabled on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">DeduplicationEnabled policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetDeduplicationAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, bool? body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove deduplication configuration for specified topic.
        /// </summary>
        /// <param name="isGlobal">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveDeduplication2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveDeduplication2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove deduplication configuration for specified topic.
        /// </summary>
        /// <param name="isGlobal">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveDeduplication2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetDeduplicationSnapshotInterval2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return GetDeduplicationSnapshotInterval2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetDeduplicationSnapshotInterval2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="body">Interval to take deduplication snapshot for the specified topic</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetDeduplicationSnapshotInterval2Async(string tenant, string @namespace, string topic, int? body, bool? isGlobal, bool? authoritative)
        {
            return SetDeduplicationSnapshotInterval2Async(tenant, @namespace, topic, body, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="body">Interval to take deduplication snapshot for the specified topic</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetDeduplicationSnapshotInterval2Async(string tenant, string @namespace, string topic, int? body, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteDeduplicationSnapshotIntervalAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return DeleteDeduplicationSnapshotIntervalAsync(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteDeduplicationSnapshotIntervalAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetDelayedDeliveryPolicies2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative)
        {
            return GetDelayedDeliveryPolicies2Async(tenant, @namespace, topic, isGlobal, applied, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetDelayedDeliveryPolicies2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/delayedDelivery?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Delayed delivery policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetDelayedDeliveryPolicies2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, DelayedDeliveryPolicies body)
        {
            return SetDelayedDeliveryPolicies2Async(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Delayed delivery policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetDelayedDeliveryPolicies2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, DelayedDeliveryPolicies body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/delayedDelivery?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteDelayedDeliveryPoliciesAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return DeleteDelayedDeliveryPoliciesAsync(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteDelayedDeliveryPoliciesAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/delayedDelivery?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetDispatchRate2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetDispatchRate2Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetDispatchRate2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/dispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetDispatchRate2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, DispatchRateImpl body)
        {
            return SetDispatchRate2Async(tenant, @namespace, topic, authoritative, isGlobal, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetDispatchRate2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/dispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveDispatchRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveDispatchRateAsync(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveDispatchRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/dispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get entry filters for a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetEntryFiltersAsync(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetEntryFiltersAsync(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get entry filters for a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetEntryFiltersAsync(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/entryFilters?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenants or Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set entry filters for specified topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Enable sub types for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetEntryFiltersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, EntryFilters body)
        {
            return SetEntryFiltersAsync(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set entry filters for specified topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Enable sub types for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetEntryFiltersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, EntryFilters body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/entryFilters?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove entry filters for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected thiscall to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveEntryFiltersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveEntryFiltersAsync(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove entry filters for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected thiscall to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveEntryFiltersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/entryFilters?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Examine a specific message on a topic by position relative to the earliest or the latest message.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="initialPosition">Relative start position to examine message.It can be 'latest' or 'earliest'</param>
        /// <param name="messagePosition">The position of messages (default 1)</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ExamineMessageAsync(string tenant, string @namespace, string topic, InitialPosition? initialPosition, long? messagePosition, bool? authoritative)
        {
            return ExamineMessageAsync(tenant, @namespace, topic, initialPosition, messagePosition, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Examine a specific message on a topic by position relative to the earliest or the latest message.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="initialPosition">Relative start position to examine message.It can be 'latest' or 'earliest'</param>
        /// <param name="messagePosition">The position of messages (default 1)</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ExamineMessageAsync(string tenant, string @namespace, string topic, InitialPosition? initialPosition, long? messagePosition, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/examinemessage?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (initialPosition != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("initialPosition") + "=").Append(System.Uri.EscapeDataString(ConvertToString(initialPosition, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (messagePosition != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("messagePosition") + "=").Append(System.Uri.EscapeDataString(ConvertToString(messagePosition, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic, the message position does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("If given partitioned topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetInactiveTopicPolicies2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetInactiveTopicPolicies2Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetInactiveTopicPolicies2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">inactive topic policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetInactiveTopicPoliciesPOST3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, InactiveTopicPolicies body)
        {
            return SetInactiveTopicPoliciesPOST3Async(tenant, @namespace, topic, authoritative, isGlobal, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">inactive topic policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetInactiveTopicPoliciesPOST3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, InactiveTopicPolicies body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteInactiveTopicPoliciesAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return DeleteInactiveTopicPoliciesAsync(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteInactiveTopicPoliciesAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the stored topic metadata.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetManagedLedgerInfoAsync(string tenant, string @namespace, bool? authoritative, string topic)
        {
            return GetManagedLedgerInfoAsync(tenant, @namespace, authoritative, topic, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the stored topic metadata.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetManagedLedgerInfoAsync(string tenant, string @namespace, bool? authoritative, string topic, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/internal-info?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the internal stats for the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetInternalStatsAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? metadata)
        {
            return GetInternalStatsAsync(tenant, @namespace, topic, authoritative, metadata, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the internal stats for the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetInternalStatsAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? metadata, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/internalStats?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (metadata != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("metadata") + "=").Append(System.Uri.EscapeDataString(ConvertToString(metadata, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to manage resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The tenant/namespace/topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Return the last commit message id of topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetLastMessageIdAsync(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return GetLastMessageIdAsync(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Return the last commit message id of topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetLastMessageIdAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/lastMessageId?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Operation is not allowed on the persistent topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get message by its messageId.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="ledgerId">The ledger id</param>
        /// <param name="entryId">The entry id</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMessageByIdAsync(string tenant, string @namespace, string topic, long ledgerId, long entryId, bool? authoritative)
        {
            return GetMessageByIdAsync(tenant, @namespace, topic, ledgerId, entryId, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get message by its messageId.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="ledgerId">The ledger id</param>
        /// <param name="entryId">The entry id</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMessageByIdAsync(string tenant, string @namespace, string topic, long ledgerId, long entryId, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (ledgerId == null)
                throw new System.ArgumentNullException("ledgerId");

            if (entryId == null)
                throw new System.ArgumentNullException("entryId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/ledger/{ledgerId}/entry/{entryId}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{ledgerId}", System.Uri.EscapeDataString(ConvertToString(ledgerId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", System.Uri.EscapeDataString(ConvertToString(entryId, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic, subscription or the message position does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Skipping messages on a non-persistent topic is not allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxConsumersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative)
        {
            return GetMaxConsumersAsync(tenant, @namespace, topic, isGlobal, applied, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxConsumersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxConsumers?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max consumers of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMaxConsumersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body)
        {
            return SetMaxConsumersAsync(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max consumers of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMaxConsumersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxConsumers?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid value of maxConsumers", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveMaxConsumersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveMaxConsumersAsync(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveMaxConsumersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxConsumers?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxConsumersPerSubscription2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return GetMaxConsumersPerSubscription2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxConsumersPerSubscription2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMaxConsumersPerSubscription2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body)
        {
            return SetMaxConsumersPerSubscription2Async(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMaxConsumersPerSubscription2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveMaxConsumersPerSubscription2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveMaxConsumersPerSubscription2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveMaxConsumersPerSubscription2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxMessageSizeAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return GetMaxMessageSizeAsync(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxMessageSizeAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxMessageSize?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max message size of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMaxMessageSizeAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body)
        {
            return SetMaxMessageSizeAsync(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max message size of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMaxMessageSizeAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxMessageSize?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid value of maxConsumers", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveMaxMessageSizeAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveMaxMessageSizeAsync(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveMaxMessageSizeAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxMessageSize?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxProducersAsync(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetMaxProducersAsync(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxProducersAsync(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxProducers?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max producers of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMaxProducersAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, int? body)
        {
            return SetMaxProducersAsync(tenant, @namespace, topic, authoritative, isGlobal, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max producers of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMaxProducersAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, int? body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxProducers?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid value of maxProducers", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveMaxProducersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveMaxProducersAsync(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveMaxProducersAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxProducers?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxSubscriptionsPerTopic2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return GetMaxSubscriptionsPerTopic2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxSubscriptionsPerTopic2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max subscriptions of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMaxSubscriptionsPerTopic2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body)
        {
            return SetMaxSubscriptionsPerTopic2Async(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max subscriptions of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMaxSubscriptionsPerTopic2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid value of maxSubscriptionsPerTopic", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveMaxSubscriptionsPerTopic2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveMaxSubscriptionsPerTopic2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveMaxSubscriptionsPerTopic2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxUnackedMessagesOnConsumerAsync(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetMaxUnackedMessagesOnConsumerAsync(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxUnackedMessagesOnConsumerAsync(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Max unacked messages on consumer policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMaxUnackedMessagesOnConsumerAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body)
        {
            return SetMaxUnackedMessagesOnConsumerAsync(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Max unacked messages on consumer policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMaxUnackedMessagesOnConsumerAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteMaxUnackedMessagesOnConsumerAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return DeleteMaxUnackedMessagesOnConsumerAsync(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteMaxUnackedMessagesOnConsumerAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxUnackedMessagesOnSubscriptionAsync(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetMaxUnackedMessagesOnSubscriptionAsync(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxUnackedMessagesOnSubscriptionAsync(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Max unacked messages on subscription policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMaxUnackedMessagesOnSubscriptionAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body)
        {
            return SetMaxUnackedMessagesOnSubscriptionAsync(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Max unacked messages on subscription policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMaxUnackedMessagesOnSubscriptionAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteMaxUnackedMessagesOnSubscriptionAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return DeleteMaxUnackedMessagesOnSubscriptionAsync(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteMaxUnackedMessagesOnSubscriptionAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get message TTL in seconds for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMessageTTLAsync(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetMessageTTLAsync(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get message TTL in seconds for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMessageTTLAsync(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/messageTTL?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set message TTL in seconds for a topic
        /// </summary>
        /// <param name="messageTTL">TTL in seconds for the specified namespace</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMessageTTLAsync(string tenant, string @namespace, string topic, int messageTTL, bool? isGlobal, bool? authoritative)
        {
            return SetMessageTTLAsync(tenant, @namespace, topic, messageTTL, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set message TTL in seconds for a topic
        /// </summary>
        /// <param name="messageTTL">TTL in seconds for the specified namespace</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMessageTTLAsync(string tenant, string @namespace, string topic, int messageTTL, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (messageTTL == null)
                throw new System.ArgumentNullException("messageTTL");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/messageTTL?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Append(System.Uri.EscapeDataString("messageTTL") + "=").Append(System.Uri.EscapeDataString(ConvertToString(messageTTL, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not authenticate to perform the request or policy is read only", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid message TTL value", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove message TTL in seconds for a topic
        /// </summary>
        /// <param name="isGlobal">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveMessageTTLAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveMessageTTLAsync(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove message TTL in seconds for a topic
        /// </summary>
        /// <param name="isGlobal">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveMessageTTLAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/messageTTL?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not authenticate to perform the request or policy is read only", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid message TTL value", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get message ID published at or just after this absolute timestamp (in ms).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="timestamp">Specify the timestamp</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMessageIdByTimestampAsync(string tenant, string @namespace, string topic, long timestamp, bool? authoritative)
        {
            return GetMessageIdByTimestampAsync(tenant, @namespace, topic, timestamp, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get message ID published at or just after this absolute timestamp (in ms).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="timestamp">Specify the timestamp</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMessageIdByTimestampAsync(string tenant, string @namespace, string topic, long timestamp, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (timestamp == null)
                throw new System.ArgumentNullException("timestamp");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/messageid/{timestamp}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{timestamp}", System.Uri.EscapeDataString(ConvertToString(timestamp, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic is not non-partitioned and persistent", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Offload a prefix of a topic to long term storage
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task OffloadStatusAsync(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return OffloadStatusAsync(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Offload a prefix of a topic to long term storage
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task OffloadStatusAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/offload?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Operation is not allowed on the persistent topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Offload a prefix of a topic to long term storage
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task TriggerOffloadAsync(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return TriggerOffloadAsync(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Offload a prefix of a topic to long term storage
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task TriggerOffloadAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/offload?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Message ID is null", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Operation is not allowed on the persistent topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Offload already running", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetOffloadPolicies2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetOffloadPolicies2Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetOffloadPolicies2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/offloadPolicies?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Offload policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetOffloadPolicies2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, OffloadPoliciesImpl body)
        {
            return SetOffloadPolicies2Async(tenant, @namespace, topic, authoritative, isGlobal, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Offload policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetOffloadPolicies2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, OffloadPoliciesImpl body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/offloadPolicies?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveOffloadPolicies2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveOffloadPolicies2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveOffloadPolicies2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/offloadPolicies?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the stats for the partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="perPartition">Get per partition stats</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="getPreciseBacklog">If return precise backlog or imprecise backlog</param>
        /// <param name="subscriptionBacklogSize">If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.</param>
        /// <param name="getEarliestTimeInBacklog">If return the earliest time in backlog</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetPartitionedStatsAsync(string tenant, string @namespace, string topic, bool? perPartition, bool? authoritative, bool? getPreciseBacklog, bool? subscriptionBacklogSize, bool? getEarliestTimeInBacklog)
        {
            return GetPartitionedStatsAsync(tenant, @namespace, topic, perPartition, authoritative, getPreciseBacklog, subscriptionBacklogSize, getEarliestTimeInBacklog, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the stats for the partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="perPartition">Get per partition stats</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="getPreciseBacklog">If return precise backlog or imprecise backlog</param>
        /// <param name="subscriptionBacklogSize">If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.</param>
        /// <param name="getEarliestTimeInBacklog">If return the earliest time in backlog</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetPartitionedStatsAsync(string tenant, string @namespace, string topic, bool? perPartition, bool? authoritative, bool? getPreciseBacklog, bool? subscriptionBacklogSize, bool? getEarliestTimeInBacklog, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/partitioned-stats?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (perPartition != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("perPartition") + "=").Append(System.Uri.EscapeDataString(ConvertToString(perPartition, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (getPreciseBacklog != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("getPreciseBacklog") + "=").Append(System.Uri.EscapeDataString(ConvertToString(getPreciseBacklog, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (subscriptionBacklogSize != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("subscriptionBacklogSize") + "=").Append(System.Uri.EscapeDataString(ConvertToString(subscriptionBacklogSize, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (getEarliestTimeInBacklog != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("getEarliestTimeInBacklog") + "=").Append(System.Uri.EscapeDataString(ConvertToString(getEarliestTimeInBacklog, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic name is invalid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get partitioned topic metadata.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="checkAllowAutoCreation">Is check configuration required to automatically create topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetPartitionedMetadataAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? checkAllowAutoCreation)
        {
            return GetPartitionedMetadataAsync(tenant, @namespace, topic, authoritative, checkAllowAutoCreation, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get partitioned topic metadata.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="checkAllowAutoCreation">Is check configuration required to automatically create topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetPartitionedMetadataAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? checkAllowAutoCreation, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/partitions?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (checkAllowAutoCreation != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("checkAllowAutoCreation") + "=").Append(System.Uri.EscapeDataString(ConvertToString(checkAllowAutoCreation, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to manage resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The tenant/namespace/topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Increment partitions of an existing partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The number of partitions for the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task UpdatePartitionedTopicAsync(string tenant, string @namespace, string topic, bool? updateLocalTopicOnly, bool? authoritative, bool? force, int body)
        {
            return UpdatePartitionedTopicAsync(tenant, @namespace, topic, updateLocalTopicOnly, authoritative, force, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Increment partitions of an existing partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The number of partitions for the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UpdatePartitionedTopicAsync(string tenant, string @namespace, string topic, bool? updateLocalTopicOnly, bool? authoritative, bool? force, int body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/partitions?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (updateLocalTopicOnly != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("updateLocalTopicOnly") + "=").Append(System.Uri.EscapeDataString(ConvertToString(updateLocalTopicOnly, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (force != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("force") + "=").Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 406)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The number of partitions should be more than 0 and less than or equal to maxNumPartitionsPerPartitionedTopic and number of new partitions must be greater than existing number of partitions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic name is invalid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create a partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="body">The metadata for the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task CreatePartitionedTopicAsync(string tenant, string @namespace, string topic, PartitionedTopicMetadata body, bool? createLocalTopicOnly)
        {
            return CreatePartitionedTopicAsync(tenant, @namespace, topic, body, createLocalTopicOnly, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="body">The metadata for the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task CreatePartitionedTopicAsync(string tenant, string @namespace, string topic, PartitionedTopicMetadata body, bool? createLocalTopicOnly, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/partitions?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (createLocalTopicOnly != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("createLocalTopicOnly") + "=").Append(System.Uri.EscapeDataString(ConvertToString(createLocalTopicOnly, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/vnd.partitioned-topic-metadata+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 406)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The number of partitions should be more than 0 and less than or equal to maxNumPartitionsPerPartitionedTopic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic already exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed Reason : Name is invalid or Namespace does not have any clusters configured", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete a partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="force">Stop all producer/consumer/replicator and delete topic forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeletePartitionedTopicAsync(string tenant, string @namespace, string topic, bool? force, bool? authoritative)
        {
            return DeletePartitionedTopicAsync(tenant, @namespace, topic, force, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="force">Stop all producer/consumer/replicator and delete topic forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeletePartitionedTopicAsync(string tenant, string @namespace, string topic, bool? force, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/partitions?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (force != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("force") + "=").Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic name is invalid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get permissions on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetPermissionsOnTopicAsync(string tenant, string @namespace, string topic)
        {
            return GetPermissionsOnTopicAsync(tenant, @namespace, topic, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get permissions on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetPermissionsOnTopicAsync(string tenant, string @namespace, string topic, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/permissions");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("tenant/namespace/topic doesn\'t exit", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Grant a new permission to a role on a single topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="role">Client role to which grant permissions</param>
        /// <param name="body">Actions to be granted (produce,functions,consume)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GrantPermissionsOnTopicAsync(string tenant, string @namespace, string topic, string role, System.Collections.Generic.IEnumerable<Anonymous3> body)
        {
            return GrantPermissionsOnTopicAsync(tenant, @namespace, topic, role, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Grant a new permission to a role on a single topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="role">Client role to which grant permissions</param>
        /// <param name="body">Actions to be granted (produce,functions,consume)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GrantPermissionsOnTopicAsync(string tenant, string @namespace, string topic, string role, System.Collections.Generic.IEnumerable<Anonymous3> body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (role == null)
                throw new System.ArgumentNullException("role");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/permissions/{role}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{role}", System.Uri.EscapeDataString(ConvertToString(role, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("tenant/namespace/topic doesn\'t exit", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Revoke permissions on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="role">Client role to which grant permissions</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RevokePermissionsOnTopicAsync(string tenant, string @namespace, string topic, string role)
        {
            return RevokePermissionsOnTopicAsync(tenant, @namespace, topic, role, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Revoke permissions on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="role">Client role to which grant permissions</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RevokePermissionsOnTopicAsync(string tenant, string @namespace, string topic, string role, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (role == null)
                throw new System.ArgumentNullException("role");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/permissions/{role}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{role}", System.Uri.EscapeDataString(ConvertToString(role, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("tenant/namespace/topic doesn\'t exit", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Permissions are not set at the topic level", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetPersistence2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetPersistence2Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetPersistence2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/persistence?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Bookkeeper persistence policies for specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetPersistence2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, PersistencePolicies body)
        {
            return SetPersistence2Async(tenant, @namespace, topic, authoritative, isGlobal, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Bookkeeper persistence policies for specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetPersistence2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, PersistencePolicies body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/persistence?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid persistence policies", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemovePersistenceAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemovePersistenceAsync(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemovePersistenceAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/persistence?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get topic properties.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetProperties2Async(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return GetProperties2Async(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get topic properties.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetProperties2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/properties?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is invalid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update the properties on the given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Key value pair properties for the topic metadata</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task UpdatePropertiesAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IDictionary<string, string> body)
        {
            return UpdatePropertiesAsync(tenant, @namespace, topic, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update the properties on the given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Key value pair properties for the topic metadata</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UpdatePropertiesAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IDictionary<string, string> body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/properties?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic/Subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Method Not Allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove the key in properties on the given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemovePropertiesAsync(string tenant, string @namespace, string topic, string key, bool? authoritative)
        {
            return RemovePropertiesAsync(tenant, @namespace, topic, key, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove the key in properties on the given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemovePropertiesAsync(string tenant, string @namespace, string topic, string key, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/properties?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (key != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("key") + "=").Append(System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic name is invalid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetPublishRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return GetPublishRateAsync(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetPublishRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/publishRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set message publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetPublishRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, PublishRate body)
        {
            return SetPublishRateAsync(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set message publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetPublishRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, PublishRate body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/publishRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove message publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemovePublishRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemovePublishRateAsync(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove message publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemovePublishRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/publishRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the replication clusters for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetReplicationClustersAsync(string tenant, string @namespace, string topic, bool? applied, bool? authoritative)
        {
            return GetReplicationClustersAsync(tenant, @namespace, topic, applied, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the replication clusters for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetReplicationClustersAsync(string tenant, string @namespace, string topic, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/replication?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set the replication clusters for a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">List of replication clusters</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetReplicationClustersAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IEnumerable<string> body)
        {
            return SetReplicationClustersAsync(tenant, @namespace, topic, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set the replication clusters for a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">List of replication clusters</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetReplicationClustersAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IEnumerable<string> body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/replication?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic is not global or invalid cluster ids", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove the replication clusters from a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveReplicationClustersAsync(string tenant, string @namespace, string topic, BacklogQuotaType5? backlogQuotaType, bool? authoritative)
        {
            return RemoveReplicationClustersAsync(tenant, @namespace, topic, backlogQuotaType, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove the replication clusters from a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveReplicationClustersAsync(string tenant, string @namespace, string topic, BacklogQuotaType5? backlogQuotaType, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/replication?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (backlogQuotaType != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("backlogQuotaType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(backlogQuotaType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetReplicatorDispatchRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative)
        {
            return GetReplicatorDispatchRate2Async(tenant, @namespace, topic, isGlobal, applied, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetReplicatorDispatchRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Replicator dispatch rate of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetReplicatorDispatchRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, DispatchRateImpl body)
        {
            return SetReplicatorDispatchRate2Async(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Replicator dispatch rate of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetReplicatorDispatchRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid value of replicatorDispatchRate", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveReplicatorDispatchRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveReplicatorDispatchRate2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveReplicatorDispatchRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetRetention2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative)
        {
            return GetRetention2Async(tenant, @namespace, topic, isGlobal, applied, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetRetention2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/retention?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Retention policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetRetention2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, RetentionPolicies body)
        {
            return SetRetention2Async(tenant, @namespace, topic, authoritative, isGlobal, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Retention policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetRetention2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, RetentionPolicies body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/retention?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Retention Quota must exceed backlog quota", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveRetention2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveRetention2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveRetention2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/retention?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Retention Quota must exceed backlog quota", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the cluster</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSchemaCompatibilityStrategy2Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative)
        {
            return GetSchemaCompatibilityStrategy2Async(tenant, @namespace, topic, applied, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the cluster</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSchemaCompatibilityStrategy2Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Operation not allowed on persistent topic", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Strategy used to check the compatibility of new schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetSchemaCompatibilityStrategy2Async(string tenant, string @namespace, string topic, bool? authoritative, string body)
        {
            return SetSchemaCompatibilityStrategy2Async(tenant, @namespace, topic, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Strategy used to check the compatibility of new schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetSchemaCompatibilityStrategy2Async(string tenant, string @namespace, string topic, bool? authoritative, string body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Operation not allowed on persistent topic", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Strategy used to check the compatibility of new schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveSchemaCompatibilityStrategyAsync(string tenant, string @namespace, string topic, bool? authoritative, string body)
        {
            return RemoveSchemaCompatibilityStrategyAsync(tenant, @namespace, topic, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Strategy used to check the compatibility of new schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveSchemaCompatibilityStrategyAsync(string tenant, string @namespace, string topic, bool? authoritative, string body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Operation not allowed on persistent topic", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get schema validation enforced flag for topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSchemaValidationEnforcedAsync(string tenant, string @namespace, string topic, bool? applied, bool? authoritative)
        {
            return GetSchemaValidationEnforcedAsync(tenant, @namespace, topic, applied, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get schema validation enforced flag for topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSchemaValidationEnforcedAsync(string tenant, string @namespace, string topic, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/schemaValidationEnforced?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenants or Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set schema validation enforced flag on topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetSchemaValidationEnforced2Async(string tenant, string @namespace, string topic, bool? authoritative, bool body)
        {
            return SetSchemaValidationEnforced2Async(tenant, @namespace, topic, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set schema validation enforced flag on topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetSchemaValidationEnforced2Async(string tenant, string @namespace, string topic, bool? authoritative, bool body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/schemaValidationEnforced?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("schemaValidationEnforced value is not valid", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the shadow topic list for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetShadowTopicsAsync(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return GetShadowTopicsAsync(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the shadow topic list for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetShadowTopicsAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/shadowTopics?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set shadow topic list for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">List of shadow topics</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetShadowTopicsAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IEnumerable<string> body)
        {
            return SetShadowTopicsAsync(tenant, @namespace, topic, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set shadow topic list for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">List of shadow topics</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetShadowTopicsAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IEnumerable<string> body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/shadowTopics?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete shadow topics for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteShadowTopicsAsync(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return DeleteShadowTopicsAsync(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete shadow topics for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteShadowTopicsAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/shadowTopics?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the stats for the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="getPreciseBacklog">If return precise backlog or imprecise backlog</param>
        /// <param name="subscriptionBacklogSize">If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.</param>
        /// <param name="getEarliestTimeInBacklog">If return time of the earliest message in backlog</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetStatsAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? getPreciseBacklog, bool? subscriptionBacklogSize, bool? getEarliestTimeInBacklog)
        {
            return GetStatsAsync(tenant, @namespace, topic, authoritative, getPreciseBacklog, subscriptionBacklogSize, getEarliestTimeInBacklog, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the stats for the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="getPreciseBacklog">If return precise backlog or imprecise backlog</param>
        /// <param name="subscriptionBacklogSize">If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.</param>
        /// <param name="getEarliestTimeInBacklog">If return time of the earliest message in backlog</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetStatsAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? getPreciseBacklog, bool? subscriptionBacklogSize, bool? getEarliestTimeInBacklog, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/stats?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (getPreciseBacklog != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("getPreciseBacklog") + "=").Append(System.Uri.EscapeDataString(ConvertToString(getPreciseBacklog, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (subscriptionBacklogSize != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("subscriptionBacklogSize") + "=").Append(System.Uri.EscapeDataString(ConvertToString(subscriptionBacklogSize, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (getEarliestTimeInBacklog != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("getEarliestTimeInBacklog") + "=").Append(System.Uri.EscapeDataString(ConvertToString(getEarliestTimeInBacklog, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSubscribeRate2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetSubscribeRate2Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSubscribeRate2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscribeRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscribe rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetSubscribeRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, SubscribeRate body)
        {
            return SetSubscribeRate2Async(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscribe rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetSubscribeRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, SubscribeRate body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscribeRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscribe rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveSubscribeRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, SubscribeRate body)
        {
            return RemoveSubscribeRateAsync(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscribe rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveSubscribeRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, SubscribeRate body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscribeRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete a subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be deleted</param>
        /// <param name="force">Disconnect and close all consumers and delete subscription forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteSubscriptionAsync(string tenant, string @namespace, string topic, string subName, bool? force, bool? authoritative)
        {
            return DeleteSubscriptionAsync(tenant, @namespace, topic, subName, force, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be deleted</param>
        /// <param name="force">Disconnect and close all consumers and delete subscription forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteSubscriptionAsync(string tenant, string @namespace, string topic, string subName, bool? force, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (force != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("force") + "=").Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Subscription has active consumers", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Analyse a subscription, by scanning all the unprocessed messages
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription</param>
        /// <param name="position">messageId to start the analysis</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task AnalyzeSubscriptionBacklogAsync(string tenant, string @namespace, string topic, string subName, ResetCursorData position, bool? authoritative)
        {
            return AnalyzeSubscriptionBacklogAsync(tenant, @namespace, topic, subName, position, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Analyse a subscription, by scanning all the unprocessed messages
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription</param>
        /// <param name="position">messageId to start the analysis</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task AnalyzeSubscriptionBacklogAsync(string tenant, string @namespace, string topic, string subName, ResetCursorData position, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/analyzeBacklog?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(position, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic/Subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Method Not Allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Expiry messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be Expiry messages on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId to reset back to (ledgerId:entryId)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ExpireTopicMessagesAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, ResetCursorData messageId)
        {
            return ExpireTopicMessagesAsync(tenant, @namespace, topic, subName, authoritative, messageId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Expiry messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be Expiry messages on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId to reset back to (ledgerId:entryId)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ExpireTopicMessagesAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, ResetCursorData messageId, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/expireMessages?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(messageId, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic or subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Expiry messages on a non-persistent topic is not allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Expiry messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be Expiry messages on</param>
        /// <param name="expireTimeInSeconds">Expires beyond the specified number of seconds</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ExpireTopicMessages2Async(string tenant, string @namespace, string topic, string subName, int expireTimeInSeconds, bool? authoritative)
        {
            return ExpireTopicMessages2Async(tenant, @namespace, topic, subName, expireTimeInSeconds, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Expiry messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be Expiry messages on</param>
        /// <param name="expireTimeInSeconds">Expires beyond the specified number of seconds</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ExpireTopicMessages2Async(string tenant, string @namespace, string topic, string subName, int expireTimeInSeconds, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            if (expireTimeInSeconds == null)
                throw new System.ArgumentNullException("expireTimeInSeconds");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/expireMessages/{expireTimeInSeconds}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{expireTimeInSeconds}", System.Uri.EscapeDataString(ConvertToString(expireTimeInSeconds, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic or subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Expiry messages on a non-persistent topic is not allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Peek nth message on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscribed message expired</param>
        /// <param name="messagePosition">The number of messages (default 1)</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PeekNthMessageAsync(string tenant, string @namespace, string topic, string subName, int messagePosition, bool? authoritative)
        {
            return PeekNthMessageAsync(tenant, @namespace, topic, subName, messagePosition, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Peek nth message on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscribed message expired</param>
        /// <param name="messagePosition">The number of messages (default 1)</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PeekNthMessageAsync(string tenant, string @namespace, string topic, string subName, int messagePosition, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            if (messagePosition == null)
                throw new System.ArgumentNullException("messagePosition");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/position/{messagePosition}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{messagePosition}", System.Uri.EscapeDataString(ConvertToString(messagePosition, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic, subscription or the message position does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Skipping messages on a non-persistent topic is not allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Return all the properties on the given subscription
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSubscriptionPropertiesAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative)
        {
            return GetSubscriptionPropertiesAsync(tenant, @namespace, topic, subName, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Return all the properties on the given subscription
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSubscriptionPropertiesAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/properties?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic/Subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Method Not Allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Replace all the properties on the given subscription
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to update</param>
        /// <param name="body">The new properties</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task UpdateSubscriptionPropertiesAsync(string tenant, string @namespace, string topic, string subName, System.Collections.Generic.IDictionary<string, string> body, bool? authoritative)
        {
            return UpdateSubscriptionPropertiesAsync(tenant, @namespace, topic, subName, body, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Replace all the properties on the given subscription
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to update</param>
        /// <param name="body">The new properties</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UpdateSubscriptionPropertiesAsync(string tenant, string @namespace, string topic, string subName, System.Collections.Generic.IDictionary<string, string> body, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/properties?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic/Subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Method Not Allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get replicated subscription status on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetReplicatedSubscriptionStatusAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative)
        {
            return GetReplicatedSubscriptionStatusAsync(tenant, @namespace, topic, subName, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get replicated subscription status on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetReplicatedSubscriptionStatusAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/replicatedSubscriptionStatus?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Can\'t find owner for topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Enable or disable a replicated subscription on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Whether to enable replicated subscription</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetReplicatedSubscriptionStatusAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, bool body)
        {
            return SetReplicatedSubscriptionStatusAsync(tenant, @namespace, topic, subName, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Enable or disable a replicated subscription on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Whether to enable replicated subscription</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetReplicatedSubscriptionStatusAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, bool body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/replicatedSubscriptionStatus?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant or subscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic or subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Operation not allowed on this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Can\'t find owner for topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Reset subscription to message position closest to given position.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to reset position on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId to reset back to (ledgerId:entryId)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ResetCursorOnPositionAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, ResetCursorData messageId)
        {
            return ResetCursorOnPositionAsync(tenant, @namespace, topic, subName, authoritative, messageId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Reset subscription to message position closest to given position.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to reset position on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId to reset back to (ledgerId:entryId)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ResetCursorOnPositionAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, ResetCursorData messageId, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/resetcursor?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(messageId, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic/Subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not supported for partitioned topics", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unable to find position for position specified", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Reset subscription to message position closest to absolute timestamp (in ms).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to reset position on</param>
        /// <param name="timestamp">the timestamp to reset back</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ResetCursorAsync(string tenant, string @namespace, string topic, string subName, long timestamp, bool? authoritative)
        {
            return ResetCursorAsync(tenant, @namespace, topic, subName, timestamp, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Reset subscription to message position closest to absolute timestamp (in ms).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to reset position on</param>
        /// <param name="timestamp">the timestamp to reset back</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ResetCursorAsync(string tenant, string @namespace, string topic, string subName, long timestamp, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            if (timestamp == null)
                throw new System.ArgumentNullException("timestamp");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/resetcursor/{timestamp}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{timestamp}", System.Uri.EscapeDataString(ConvertToString(timestamp, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic/Subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Method Not Allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to reset cursor on subscription or Unable to find position for timestamp specified", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Skipping messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="numMessages">The number of messages to skip</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SkipMessagesAsync(string tenant, string @namespace, string topic, string subName, int numMessages, bool? authoritative)
        {
            return SkipMessagesAsync(tenant, @namespace, topic, subName, numMessages, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Skipping messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="numMessages">The number of messages to skip</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SkipMessagesAsync(string tenant, string @namespace, string topic, string subName, int numMessages, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            if (numMessages == null)
                throw new System.ArgumentNullException("numMessages");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/skip/{numMessages}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{numMessages}", System.Uri.EscapeDataString(ConvertToString(numMessages, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic or subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Skipping messages on a partitioned topic is not allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Skip all messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SkipAllMessagesAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative)
        {
            return SkipAllMessagesAsync(tenant, @namespace, topic, subName, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Skip all messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SkipAllMessagesAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/skip_all?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic or subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Operation not allowed on non-persistent topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Can\'t find owner for topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create a subscription on the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subscriptionName">Subscription to create position on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId where to create the subscription. It can be 'latest', 'earliest' or (ledgerId:entryId)</param>
        /// <param name="replicated">Is replicated required to perform this operation</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task CreateSubscriptionAsync(string tenant, string @namespace, string topic, string subscriptionName, bool? authoritative, ResetCursorData messageId, bool? replicated)
        {
            return CreateSubscriptionAsync(tenant, @namespace, topic, subscriptionName, authoritative, messageId, replicated, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a subscription on the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subscriptionName">Subscription to create position on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId where to create the subscription. It can be 'latest', 'earliest' or (ledgerId:entryId)</param>
        /// <param name="replicated">Is replicated required to perform this operation</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task CreateSubscriptionAsync(string tenant, string @namespace, string topic, string subscriptionName, bool? authoritative, ResetCursorData messageId, bool? replicated, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subscriptionName == null)
                throw new System.ArgumentNullException("subscriptionName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscription/{subscriptionName}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subscriptionName}", System.Uri.EscapeDataString(ConvertToString(subscriptionName, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (replicated != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("replicated") + "=").Append(System.Uri.EscapeDataString(ConvertToString(replicated, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(messageId, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Create subscription on non persistent topic is not supported", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic/Subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not supported for partitioned topics", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSubscriptionDispatchRate2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetSubscriptionDispatchRate2Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSubscriptionDispatchRate2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscription message dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetSubscriptionDispatchRate2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, DispatchRateImpl body)
        {
            return SetSubscriptionDispatchRate2Async(tenant, @namespace, topic, authoritative, isGlobal, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscription message dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetSubscriptionDispatchRate2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveSubscriptionDispatchRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveSubscriptionDispatchRateAsync(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveSubscriptionDispatchRateAsync(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get is enable sub type fors specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSubscriptionTypesEnabled2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return GetSubscriptionTypesEnabled2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get is enable sub type fors specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSubscriptionTypesEnabled2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set is enable sub types for specified topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Enable sub types for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetSubscriptionTypesEnabled2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Collections.Generic.IEnumerable<Anonymous4> body)
        {
            return SetSubscriptionTypesEnabled2Async(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set is enable sub types for specified topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Enable sub types for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetSubscriptionTypesEnabled2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Collections.Generic.IEnumerable<Anonymous4> body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove subscription types enabled for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveSubscriptionTypesEnabled2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveSubscriptionTypesEnabled2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove subscription types enabled for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveSubscriptionTypesEnabled2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the list of persistent subscriptions for a given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSubscriptionsAsync(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return GetSubscriptionsAsync(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of persistent subscriptions for a given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSubscriptionsAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/subscriptions?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Terminate a topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task TerminateAsync(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return TerminateAsync(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Terminate a topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task TerminateAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/terminate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Termination of a partitioned topic is not allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 406)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Need to provide a persistent topic name", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Terminate all partitioned topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task TerminatePartitionedTopicAsync(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return TerminatePartitionedTopicAsync(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Terminate all partitioned topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task TerminatePartitionedTopicAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/terminate/partitions?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Termination of a non-partitioned topic is not allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Truncate a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task TruncateTopicAsync(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return TruncateTopicAsync(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Truncate a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task TruncateTopicAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/truncate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("NonPersistentTopic does not support truncate.", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Unload a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task UnloadTopicAsync(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return UnloadTopicAsync(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unload a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UnloadTopicAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/unload?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("This operation requires super-user access", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The tenant/namespace/topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSubscriptionLevelDispatchRateAsync(string tenant, string @namespace, string topic, string subName, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetSubscriptionLevelDispatchRateAsync(tenant, @namespace, topic, subName, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSubscriptionLevelDispatchRateAsync(string tenant, string @namespace, string topic, string subName, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscription message dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetSubscriptionLevelDispatchRateAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, bool? isGlobal, DispatchRateImpl body)
        {
            return SetSubscriptionLevelDispatchRateAsync(tenant, @namespace, topic, subName, authoritative, isGlobal, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscription message dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetSubscriptionLevelDispatchRateAsync(string tenant, string @namespace, string topic, string subName, bool? authoritative, bool? isGlobal, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveSubscriptionLevelDispatchRateAsync(string tenant, string @namespace, string topic, string subName, bool? isGlobal, bool? authoritative)
        {
            return RemoveSubscriptionLevelDispatchRateAsync(tenant, @namespace, topic, subName, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveSubscriptionLevelDispatchRateAsync(string tenant, string @namespace, string topic, string subName, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("non-persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the list of topics under a namespace.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="bundle">Specify the bundle name</param>
        /// <param name="includeSystemTopic">Include system topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetList2Async(string tenant, string @namespace, string bundle, bool? includeSystemTopic)
        {
            return GetList2Async(tenant, @namespace, bundle, includeSystemTopic, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of topics under a namespace.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="bundle">Specify the bundle name</param>
        /// <param name="includeSystemTopic">Include system topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetList2Async(string tenant, string @namespace, string bundle, bool? includeSystemTopic, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (bundle != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("bundle") + "=").Append(System.Uri.EscapeDataString(ConvertToString(bundle, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (includeSystemTopic != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("includeSystemTopic") + "=").Append(System.Uri.EscapeDataString(ConvertToString(includeSystemTopic, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin or operate permission on the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("tenant/namespace/topic doesn\'t exit", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the list of partitioned topics under a namespace.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="includeSystemTopic">Include system topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetPartitionedTopicList2Async(string tenant, string @namespace, bool? includeSystemTopic)
        {
            return GetPartitionedTopicList2Async(tenant, @namespace, includeSystemTopic, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of partitioned topics under a namespace.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="includeSystemTopic">Include system topic</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetPartitionedTopicList2Async(string tenant, string @namespace, bool? includeSystemTopic, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/partitioned?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (includeSystemTopic != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("includeSystemTopic") + "=").Append(System.Uri.EscapeDataString(ConvertToString(includeSystemTopic, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin or operate permission on the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("tenant/namespace/topic doesn\'t exit", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create a non-partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Key value pair properties for the topic metadata</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task CreateNonPartitionedTopic2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IDictionary<string, string> body)
        {
            return CreateNonPartitionedTopic2Async(tenant, @namespace, topic, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a non-partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Key value pair properties for the topic metadata</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task CreateNonPartitionedTopic2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IDictionary<string, string> body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic already exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed Reason : Name is invalid or Namespace does not have any clusters configured", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="force">Stop all producer/consumer/replicator and delete topic forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteTopic2Async(string tenant, string @namespace, string topic, bool? force, bool? authoritative)
        {
            return DeleteTopic2Async(tenant, @namespace, topic, force, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="force">Stop all producer/consumer/replicator and delete topic forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteTopic2Async(string tenant, string @namespace, string topic, bool? force, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (force != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("force") + "=").Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic has active producers/subscriptions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Expiry messages on all subscriptions of topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="expireTimeInSeconds">Expires beyond the specified number of seconds</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ExpireMessagesForAllSubscriptions2Async(string tenant, string @namespace, string topic, int expireTimeInSeconds, bool? authoritative)
        {
            return ExpireMessagesForAllSubscriptions2Async(tenant, @namespace, topic, expireTimeInSeconds, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Expiry messages on all subscriptions of topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="expireTimeInSeconds">Expires beyond the specified number of seconds</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ExpireMessagesForAllSubscriptions2Async(string tenant, string @namespace, string topic, int expireTimeInSeconds, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (expireTimeInSeconds == null)
                throw new System.ArgumentNullException("expireTimeInSeconds");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/all_subscription/expireMessages/{expireTimeInSeconds}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{expireTimeInSeconds}", System.Uri.EscapeDataString(ConvertToString(expireTimeInSeconds, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic or subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Expiry messages on a non-persistent topic is not allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Can\'t find owner for topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get estimated backlog for offline topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetBacklog2Async(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return GetBacklog2Async(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get estimated backlog for offline topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetBacklog2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/backlog?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set a backlog quota for a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetBacklogQuota3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, BacklogQuotaType6? backlogQuotaType)
        {
            return SetBacklogQuota3Async(tenant, @namespace, topic, authoritative, isGlobal, backlogQuotaType, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set a backlog quota for a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetBacklogQuota3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, BacklogQuotaType6? backlogQuotaType, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/backlogQuota?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (backlogQuotaType != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("backlogQuotaType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(backlogQuotaType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Specified backlog quota exceeds retention quota. Increase retention quota and retry request", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove a backlog quota policy from a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveBacklogQuota3Async(string tenant, string @namespace, string topic, BacklogQuotaType7? backlogQuotaType, bool? authoritative, bool? isGlobal)
        {
            return RemoveBacklogQuota3Async(tenant, @namespace, topic, backlogQuotaType, authoritative, isGlobal, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove a backlog quota policy from a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveBacklogQuota3Async(string tenant, string @namespace, string topic, BacklogQuotaType7? backlogQuotaType, bool? authoritative, bool? isGlobal, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/backlogQuota?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (backlogQuotaType != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("backlogQuotaType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(backlogQuotaType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get backlog quota map on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetBacklogQuotaMap3Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative, bool? isGlobal)
        {
            return GetBacklogQuotaMap3Async(tenant, @namespace, topic, applied, authoritative, isGlobal, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get backlog quota map on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetBacklogQuotaMap3Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative, bool? isGlobal, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/backlogQuotaMap?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic policy does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Calculate backlog size by a message ID (in bytes).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetBacklogSizeByMessageId2Async(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return GetBacklogSizeByMessageId2Async(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Calculate backlog size by a message ID (in bytes).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetBacklogSizeByMessageId2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/backlogSize?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the status of a compaction operation for a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task CompactionStatus2Async(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return CompactionStatus2Async(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the status of a compaction operation for a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task CompactionStatus2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/compaction?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist, or compaction hasn\'t run", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Operation is not allowed on the persistent topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Trigger a compaction operation on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task Compact2Async(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return Compact2Async(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Trigger a compaction operation on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task Compact2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/compaction?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Operation is not allowed on the persistent topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Compaction already running", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetCompactionThreshold3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetCompactionThreshold3Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetCompactionThreshold3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/compactionThreshold?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetCompactionThresholdPOST2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, long? body)
        {
            return SetCompactionThresholdPOST2Async(tenant, @namespace, topic, authoritative, isGlobal, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetCompactionThresholdPOST2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, long? body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/compactionThreshold?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveCompactionThreshold2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveCompactionThreshold2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove compaction threshold configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveCompactionThreshold2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/compactionThreshold?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create missed partitions of an existing partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task CreateMissedPartitions2Async(string tenant, string @namespace, string topic)
        {
            return CreateMissedPartitions2Async(tenant, @namespace, topic, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create missed partitions of an existing partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task CreateMissedPartitions2Async(string tenant, string @namespace, string topic, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/createMissedPartitions");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic name is invalid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get deduplication configuration of a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetDeduplication3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetDeduplication3Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get deduplication configuration of a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetDeduplication3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set deduplication enabled on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">DeduplicationEnabled policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetDeduplication2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, bool? body)
        {
            return SetDeduplication2Async(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set deduplication enabled on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">DeduplicationEnabled policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetDeduplication2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, bool? body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove deduplication configuration for specified topic.
        /// </summary>
        /// <param name="isGlobal">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveDeduplication3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveDeduplication3Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove deduplication configuration for specified topic.
        /// </summary>
        /// <param name="isGlobal">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveDeduplication3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetDeduplicationSnapshotInterval3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return GetDeduplicationSnapshotInterval3Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetDeduplicationSnapshotInterval3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="body">Interval to take deduplication snapshot for the specified topic</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetDeduplicationSnapshotInterval3Async(string tenant, string @namespace, string topic, int? body, bool? isGlobal, bool? authoritative)
        {
            return SetDeduplicationSnapshotInterval3Async(tenant, @namespace, topic, body, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="body">Interval to take deduplication snapshot for the specified topic</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetDeduplicationSnapshotInterval3Async(string tenant, string @namespace, string topic, int? body, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteDeduplicationSnapshotInterval2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return DeleteDeduplicationSnapshotInterval2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete deduplicationSnapshotInterval config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteDeduplicationSnapshotInterval2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetDelayedDeliveryPolicies3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative)
        {
            return GetDelayedDeliveryPolicies3Async(tenant, @namespace, topic, isGlobal, applied, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetDelayedDeliveryPolicies3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/delayedDelivery?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Delayed delivery policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetDelayedDeliveryPolicies3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, DelayedDeliveryPolicies body)
        {
            return SetDelayedDeliveryPolicies3Async(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Delayed delivery policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetDelayedDeliveryPolicies3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, DelayedDeliveryPolicies body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/delayedDelivery?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteDelayedDeliveryPolicies2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return DeleteDelayedDeliveryPolicies2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set delayed delivery messages config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteDelayedDeliveryPolicies2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/delayedDelivery?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetDispatchRate3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetDispatchRate3Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetDispatchRate3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/dispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetDispatchRate3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, DispatchRateImpl body)
        {
            return SetDispatchRate3Async(tenant, @namespace, topic, authoritative, isGlobal, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetDispatchRate3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/dispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveDispatchRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveDispatchRate2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveDispatchRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/dispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get entry filters for a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetEntryFilters2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetEntryFilters2Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get entry filters for a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetEntryFilters2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/entryFilters?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenants or Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set entry filters for specified topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected thiscall to this broker. For internal use.</param>
        /// <param name="body">Entry filters for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetEntryFilters2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, EntryFilters body)
        {
            return SetEntryFilters2Async(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set entry filters for specified topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected thiscall to this broker. For internal use.</param>
        /// <param name="body">Entry filters for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetEntryFilters2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, EntryFilters body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/entryFilters?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove entry filters for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected thiscall to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveEntryFilters2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveEntryFilters2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove entry filters for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected thiscall to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveEntryFilters2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/entryFilters?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Examine a specific message on a topic by position relative to the earliest or the latest message.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="initialPosition">Relative start position to examine message.It can be 'latest' or 'earliest'</param>
        /// <param name="messagePosition">The position of messages (default 1)</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ExamineMessage2Async(string tenant, string @namespace, string topic, InitialPosition2? initialPosition, long? messagePosition, bool? authoritative)
        {
            return ExamineMessage2Async(tenant, @namespace, topic, initialPosition, messagePosition, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Examine a specific message on a topic by position relative to the earliest or the latest message.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="initialPosition">Relative start position to examine message.It can be 'latest' or 'earliest'</param>
        /// <param name="messagePosition">The position of messages (default 1)</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ExamineMessage2Async(string tenant, string @namespace, string topic, InitialPosition2? initialPosition, long? messagePosition, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/examinemessage?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (initialPosition != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("initialPosition") + "=").Append(System.Uri.EscapeDataString(ConvertToString(initialPosition, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (messagePosition != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("messagePosition") + "=").Append(System.Uri.EscapeDataString(ConvertToString(messagePosition, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic, the message position does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("If given partitioned topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetInactiveTopicPolicies3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetInactiveTopicPolicies3Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetInactiveTopicPolicies3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">inactive topic policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetInactiveTopicPoliciesPOST4Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, InactiveTopicPolicies body)
        {
            return SetInactiveTopicPoliciesPOST4Async(tenant, @namespace, topic, authoritative, isGlobal, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">inactive topic policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetInactiveTopicPoliciesPOST4Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, InactiveTopicPolicies body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteInactiveTopicPolicies2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return DeleteInactiveTopicPolicies2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete inactive topic policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteInactiveTopicPolicies2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the stored topic metadata.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetManagedLedgerInfo2Async(string tenant, string @namespace, bool? authoritative, string topic)
        {
            return GetManagedLedgerInfo2Async(tenant, @namespace, authoritative, topic, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the stored topic metadata.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetManagedLedgerInfo2Async(string tenant, string @namespace, bool? authoritative, string topic, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/internal-info?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the internal stats for the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetInternalStats2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? metadata)
        {
            return GetInternalStats2Async(tenant, @namespace, topic, authoritative, metadata, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the internal stats for the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetInternalStats2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? metadata, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/internalStats?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (metadata != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("metadata") + "=").Append(System.Uri.EscapeDataString(ConvertToString(metadata, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Return the last commit message id of topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetLastMessageId2Async(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return GetLastMessageId2Async(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Return the last commit message id of topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetLastMessageId2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/lastMessageId?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Operation is not allowed on the persistent topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get message by its messageId.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="ledgerId">The ledger id</param>
        /// <param name="entryId">The entry id</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMessageById2Async(string tenant, string @namespace, string topic, long ledgerId, long entryId, bool? authoritative)
        {
            return GetMessageById2Async(tenant, @namespace, topic, ledgerId, entryId, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get message by its messageId.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="ledgerId">The ledger id</param>
        /// <param name="entryId">The entry id</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMessageById2Async(string tenant, string @namespace, string topic, long ledgerId, long entryId, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (ledgerId == null)
                throw new System.ArgumentNullException("ledgerId");

            if (entryId == null)
                throw new System.ArgumentNullException("entryId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/ledger/{ledgerId}/entry/{entryId}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{ledgerId}", System.Uri.EscapeDataString(ConvertToString(ledgerId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", System.Uri.EscapeDataString(ConvertToString(entryId, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic, subscription or the message position does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Skipping messages on a non-persistent topic is not allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxConsumers2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative)
        {
            return GetMaxConsumers2Async(tenant, @namespace, topic, isGlobal, applied, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxConsumers2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxConsumers?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max consumers of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMaxConsumers2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body)
        {
            return SetMaxConsumers2Async(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max consumers of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMaxConsumers2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxConsumers?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid value of maxConsumers", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveMaxConsumers2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveMaxConsumers2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxConsumers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveMaxConsumers2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxConsumers?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxConsumersPerSubscription3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return GetMaxConsumersPerSubscription3Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxConsumersPerSubscription3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMaxConsumersPerSubscription3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body)
        {
            return SetMaxConsumersPerSubscription3Async(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMaxConsumersPerSubscription3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveMaxConsumersPerSubscription3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveMaxConsumersPerSubscription3Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove max consumers per subscription configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveMaxConsumersPerSubscription3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxMessageSize2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return GetMaxMessageSize2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxMessageSize2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxMessageSize?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max message size of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMaxMessageSize2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body)
        {
            return SetMaxMessageSize2Async(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max message size of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMaxMessageSize2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxMessageSize?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid value of maxConsumers", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveMaxMessageSize2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveMaxMessageSize2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxMessageSize config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveMaxMessageSize2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxMessageSize?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxProducers2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetMaxProducers2Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxProducers2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxProducers?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max producers of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMaxProducers2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, int? body)
        {
            return SetMaxProducers2Async(tenant, @namespace, topic, authoritative, isGlobal, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max producers of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMaxProducers2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, int? body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxProducers?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid value of maxProducers", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveMaxProducers2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveMaxProducers2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxProducers config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveMaxProducers2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxProducers?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxSubscriptionsPerTopic3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return GetMaxSubscriptionsPerTopic3Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxSubscriptionsPerTopic3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max subscriptions of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMaxSubscriptionsPerTopic3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body)
        {
            return SetMaxSubscriptionsPerTopic3Async(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The max subscriptions of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMaxSubscriptionsPerTopic3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid value of maxSubscriptionsPerTopic", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveMaxSubscriptionsPerTopic3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveMaxSubscriptionsPerTopic3Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove maxSubscriptionsPerTopic config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveMaxSubscriptionsPerTopic3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxUnackedMessagesOnConsumer2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetMaxUnackedMessagesOnConsumer2Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxUnackedMessagesOnConsumer2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Max unacked messages on consumer policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMaxUnackedMessagesOnConsumer2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body)
        {
            return SetMaxUnackedMessagesOnConsumer2Async(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Max unacked messages on consumer policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMaxUnackedMessagesOnConsumer2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteMaxUnackedMessagesOnConsumer2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return DeleteMaxUnackedMessagesOnConsumer2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete max unacked messages per consumer config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteMaxUnackedMessagesOnConsumer2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMaxUnackedMessagesOnSubscription2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetMaxUnackedMessagesOnSubscription2Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMaxUnackedMessagesOnSubscription2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Max unacked messages on subscription policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMaxUnackedMessagesOnSubscription2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body)
        {
            return SetMaxUnackedMessagesOnSubscription2Async(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Max unacked messages on subscription policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMaxUnackedMessagesOnSubscription2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, int? body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteMaxUnackedMessagesOnSubscription2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return DeleteMaxUnackedMessagesOnSubscription2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete max unacked messages per subscription config on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteMaxUnackedMessagesOnSubscription2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get message TTL in seconds for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMessageTTL2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetMessageTTL2Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get message TTL in seconds for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMessageTTL2Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/messageTTL?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set message TTL in seconds for a topic
        /// </summary>
        /// <param name="messageTTL">TTL in seconds for the specified namespace</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetMessageTTL2Async(string tenant, string @namespace, string topic, int messageTTL, bool? isGlobal, bool? authoritative)
        {
            return SetMessageTTL2Async(tenant, @namespace, topic, messageTTL, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set message TTL in seconds for a topic
        /// </summary>
        /// <param name="messageTTL">TTL in seconds for the specified namespace</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetMessageTTL2Async(string tenant, string @namespace, string topic, int messageTTL, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (messageTTL == null)
                throw new System.ArgumentNullException("messageTTL");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/messageTTL?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Append(System.Uri.EscapeDataString("messageTTL") + "=").Append(System.Uri.EscapeDataString(ConvertToString(messageTTL, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not authenticate to perform the request or policy is read only", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid message TTL value", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove message TTL in seconds for a topic
        /// </summary>
        /// <param name="isGlobal">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveMessageTTL2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveMessageTTL2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove message TTL in seconds for a topic
        /// </summary>
        /// <param name="isGlobal">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveMessageTTL2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/messageTTL?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not authenticate to perform the request or policy is read only", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid message TTL value", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get message ID published at or just after this absolute timestamp (in ms).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="timestamp">Specify the timestamp</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetMessageIdByTimestamp2Async(string tenant, string @namespace, string topic, long timestamp, bool? authoritative)
        {
            return GetMessageIdByTimestamp2Async(tenant, @namespace, topic, timestamp, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get message ID published at or just after this absolute timestamp (in ms).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="timestamp">Specify the timestamp</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetMessageIdByTimestamp2Async(string tenant, string @namespace, string topic, long timestamp, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (timestamp == null)
                throw new System.ArgumentNullException("timestamp");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/messageid/{timestamp}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{timestamp}", System.Uri.EscapeDataString(ConvertToString(timestamp, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic is not non-partitioned and persistent", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Offload a prefix of a topic to long term storage
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task OffloadStatus2Async(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return OffloadStatus2Async(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Offload a prefix of a topic to long term storage
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task OffloadStatus2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/offload?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Operation is not allowed on the persistent topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Offload a prefix of a topic to long term storage
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task TriggerOffload2Async(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return TriggerOffload2Async(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Offload a prefix of a topic to long term storage
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task TriggerOffload2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/offload?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Message ID is null", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Operation is not allowed on the persistent topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Offload already running", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetOffloadPolicies3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetOffloadPolicies3Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetOffloadPolicies3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/offloadPolicies?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Offload policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetOffloadPolicies3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, OffloadPoliciesImpl body)
        {
            return SetOffloadPolicies3Async(tenant, @namespace, topic, authoritative, isGlobal, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Offload policies for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetOffloadPolicies3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, OffloadPoliciesImpl body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/offloadPolicies?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveOffloadPolicies3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveOffloadPolicies3Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete offload policies on a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveOffloadPolicies3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/offloadPolicies?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or cluster or namespace or topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the stats for the partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="perPartition">Get per partition stats</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="getPreciseBacklog">If return precise backlog or imprecise backlog</param>
        /// <param name="subscriptionBacklogSize">If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.</param>
        /// <param name="getEarliestTimeInBacklog">If return the earliest time in backlog</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetPartitionedStats2Async(string tenant, string @namespace, string topic, bool? perPartition, bool? authoritative, bool? getPreciseBacklog, bool? subscriptionBacklogSize, bool? getEarliestTimeInBacklog)
        {
            return GetPartitionedStats2Async(tenant, @namespace, topic, perPartition, authoritative, getPreciseBacklog, subscriptionBacklogSize, getEarliestTimeInBacklog, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the stats for the partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="perPartition">Get per partition stats</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="getPreciseBacklog">If return precise backlog or imprecise backlog</param>
        /// <param name="subscriptionBacklogSize">If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.</param>
        /// <param name="getEarliestTimeInBacklog">If return the earliest time in backlog</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetPartitionedStats2Async(string tenant, string @namespace, string topic, bool? perPartition, bool? authoritative, bool? getPreciseBacklog, bool? subscriptionBacklogSize, bool? getEarliestTimeInBacklog, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/partitioned-stats?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (perPartition != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("perPartition") + "=").Append(System.Uri.EscapeDataString(ConvertToString(perPartition, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (getPreciseBacklog != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("getPreciseBacklog") + "=").Append(System.Uri.EscapeDataString(ConvertToString(getPreciseBacklog, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (subscriptionBacklogSize != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("subscriptionBacklogSize") + "=").Append(System.Uri.EscapeDataString(ConvertToString(subscriptionBacklogSize, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (getEarliestTimeInBacklog != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("getEarliestTimeInBacklog") + "=").Append(System.Uri.EscapeDataString(ConvertToString(getEarliestTimeInBacklog, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic name is invalid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get partitioned topic metadata.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="checkAllowAutoCreation">Is check configuration required to automatically create topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetPartitionedMetadata2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? checkAllowAutoCreation)
        {
            return GetPartitionedMetadata2Async(tenant, @namespace, topic, authoritative, checkAllowAutoCreation, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get partitioned topic metadata.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="checkAllowAutoCreation">Is check configuration required to automatically create topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetPartitionedMetadata2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? checkAllowAutoCreation, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/partitions?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (checkAllowAutoCreation != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("checkAllowAutoCreation") + "=").Append(System.Uri.EscapeDataString(ConvertToString(checkAllowAutoCreation, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic name is invalid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Increment partitions of an existing partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The number of partitions for the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task UpdatePartitionedTopic2Async(string tenant, string @namespace, string topic, bool? updateLocalTopicOnly, bool? authoritative, bool? force, int body)
        {
            return UpdatePartitionedTopic2Async(tenant, @namespace, topic, updateLocalTopicOnly, authoritative, force, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Increment partitions of an existing partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">The number of partitions for the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UpdatePartitionedTopic2Async(string tenant, string @namespace, string topic, bool? updateLocalTopicOnly, bool? authoritative, bool? force, int body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/partitions?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (updateLocalTopicOnly != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("updateLocalTopicOnly") + "=").Append(System.Uri.EscapeDataString(ConvertToString(updateLocalTopicOnly, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (force != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("force") + "=").Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 406)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The number of partitions should be more than 0 and less than or equal to maxNumPartitionsPerPartitionedTopic and number of new partitions must be greater than existing number of partitions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic name is invalid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create a partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="body">The metadata for the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task CreatePartitionedTopic2Async(string tenant, string @namespace, string topic, PartitionedTopicMetadata body, bool? createLocalTopicOnly)
        {
            return CreatePartitionedTopic2Async(tenant, @namespace, topic, body, createLocalTopicOnly, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="body">The metadata for the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task CreatePartitionedTopic2Async(string tenant, string @namespace, string topic, PartitionedTopicMetadata body, bool? createLocalTopicOnly, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/partitions?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (createLocalTopicOnly != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("createLocalTopicOnly") + "=").Append(System.Uri.EscapeDataString(ConvertToString(createLocalTopicOnly, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/vnd.partitioned-topic-metadata+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 406)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The number of partitions should be more than 0 and less than or equal to maxNumPartitionsPerPartitionedTopic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic already exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed Reason : Name is invalid or Namespace does not have any clusters configured", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete a partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="force">Stop all producer/consumer/replicator and delete topic forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeletePartitionedTopic2Async(string tenant, string @namespace, string topic, bool? force, bool? authoritative)
        {
            return DeletePartitionedTopic2Async(tenant, @namespace, topic, force, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a partitioned topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="force">Stop all producer/consumer/replicator and delete topic forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeletePartitionedTopic2Async(string tenant, string @namespace, string topic, bool? force, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/partitions?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (force != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("force") + "=").Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic name is invalid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get permissions on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetPermissionsOnTopic2Async(string tenant, string @namespace, string topic)
        {
            return GetPermissionsOnTopic2Async(tenant, @namespace, topic, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get permissions on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetPermissionsOnTopic2Async(string tenant, string @namespace, string topic, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/permissions");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("tenant/namespace/topic doesn\'t exit", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Grant a new permission to a role on a single topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="role">Client role to which grant permissions</param>
        /// <param name="body">Actions to be granted (produce,functions,consume)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GrantPermissionsOnTopic2Async(string tenant, string @namespace, string topic, string role, System.Collections.Generic.IEnumerable<Anonymous5> body)
        {
            return GrantPermissionsOnTopic2Async(tenant, @namespace, topic, role, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Grant a new permission to a role on a single topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="role">Client role to which grant permissions</param>
        /// <param name="body">Actions to be granted (produce,functions,consume)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GrantPermissionsOnTopic2Async(string tenant, string @namespace, string topic, string role, System.Collections.Generic.IEnumerable<Anonymous5> body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (role == null)
                throw new System.ArgumentNullException("role");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/permissions/{role}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{role}", System.Uri.EscapeDataString(ConvertToString(role, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("tenant/namespace/topic doesn\'t exit", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Revoke permissions on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="role">Client role to which grant permissions</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RevokePermissionsOnTopic2Async(string tenant, string @namespace, string topic, string role)
        {
            return RevokePermissionsOnTopic2Async(tenant, @namespace, topic, role, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Revoke permissions on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="role">Client role to which grant permissions</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RevokePermissionsOnTopic2Async(string tenant, string @namespace, string topic, string role, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (role == null)
                throw new System.ArgumentNullException("role");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/permissions/{role}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{role}", System.Uri.EscapeDataString(ConvertToString(role, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("tenant/namespace/topic doesn\'t exit", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Permissions are not set at the topic level", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetPersistence3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetPersistence3Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetPersistence3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/persistence?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Bookkeeper persistence policies for specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetPersistence3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, PersistencePolicies body)
        {
            return SetPersistence3Async(tenant, @namespace, topic, authoritative, isGlobal, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Bookkeeper persistence policies for specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetPersistence3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, PersistencePolicies body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/persistence?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid persistence policies", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemovePersistence2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemovePersistence2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove configuration of persistence policies for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemovePersistence2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/persistence?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get topic properties.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetProperties3Async(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return GetProperties3Async(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get topic properties.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetProperties3Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/properties?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is invalid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update the properties on the given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Key value pair properties for the topic metadata</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task UpdateProperties2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IDictionary<string, string> body)
        {
            return UpdateProperties2Async(tenant, @namespace, topic, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update the properties on the given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Key value pair properties for the topic metadata</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UpdateProperties2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IDictionary<string, string> body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/properties?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic/Subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Method Not Allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove the key in properties on the given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveProperties2Async(string tenant, string @namespace, string topic, string key, bool? authoritative)
        {
            return RemoveProperties2Async(tenant, @namespace, topic, key, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove the key in properties on the given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveProperties2Async(string tenant, string @namespace, string topic, string key, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/properties?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (key != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("key") + "=").Append(System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Partitioned topic name is invalid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetPublishRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return GetPublishRate2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetPublishRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/publishRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set message publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetPublishRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, PublishRate body)
        {
            return SetPublishRate2Async(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set message publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetPublishRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, PublishRate body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/publishRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove message publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemovePublishRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemovePublishRate2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove message publish rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemovePublishRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/publishRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the replication clusters for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetReplicationClusters2Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative)
        {
            return GetReplicationClusters2Async(tenant, @namespace, topic, applied, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the replication clusters for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetReplicationClusters2Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/replication?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set the replication clusters for a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">List of replication clusters</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetReplicationClusters2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IEnumerable<string> body)
        {
            return SetReplicationClusters2Async(tenant, @namespace, topic, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set the replication clusters for a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">List of replication clusters</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetReplicationClusters2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IEnumerable<string> body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/replication?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic is not global or invalid cluster ids", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove the replication clusters from a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveReplicationClusters2Async(string tenant, string @namespace, string topic, BacklogQuotaType8? backlogQuotaType, bool? authoritative)
        {
            return RemoveReplicationClusters2Async(tenant, @namespace, topic, backlogQuotaType, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove the replication clusters from a topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveReplicationClusters2Async(string tenant, string @namespace, string topic, BacklogQuotaType8? backlogQuotaType, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/replication?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (backlogQuotaType != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("backlogQuotaType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(backlogQuotaType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetReplicatorDispatchRate3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative)
        {
            return GetReplicatorDispatchRate3Async(tenant, @namespace, topic, isGlobal, applied, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetReplicatorDispatchRate3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Replicator dispatch rate of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetReplicatorDispatchRate3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, DispatchRateImpl body)
        {
            return SetReplicatorDispatchRate3Async(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Replicator dispatch rate of the topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetReplicatorDispatchRate3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid value of replicatorDispatchRate", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveReplicatorDispatchRate3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveReplicatorDispatchRate3Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove replicatorDispatchRate config for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveReplicatorDispatchRate3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetRetention3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative)
        {
            return GetRetention3Async(tenant, @namespace, topic, isGlobal, applied, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetRetention3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/retention?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Retention policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetRetention3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, RetentionPolicies body)
        {
            return SetRetention3Async(tenant, @namespace, topic, authoritative, isGlobal, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Retention policies for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetRetention3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, RetentionPolicies body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/retention?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Retention Quota must exceed backlog quota", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveRetention3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveRetention3Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove retention configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveRetention3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/retention?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Retention Quota must exceed backlog quota", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the cluster</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSchemaCompatibilityStrategy3Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative)
        {
            return GetSchemaCompatibilityStrategy3Async(tenant, @namespace, topic, applied, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the cluster</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSchemaCompatibilityStrategy3Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Operation not allowed on persistent topic", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Strategy used to check the compatibility of new schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetSchemaCompatibilityStrategy3Async(string tenant, string @namespace, string topic, bool? authoritative, string body)
        {
            return SetSchemaCompatibilityStrategy3Async(tenant, @namespace, topic, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Strategy used to check the compatibility of new schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetSchemaCompatibilityStrategy3Async(string tenant, string @namespace, string topic, bool? authoritative, string body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Operation not allowed on persistent topic", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Strategy used to check the compatibility of new schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveSchemaCompatibilityStrategy2Async(string tenant, string @namespace, string topic, bool? authoritative, string body)
        {
            return RemoveSchemaCompatibilityStrategy2Async(tenant, @namespace, topic, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove schema compatibility strategy on a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Strategy used to check the compatibility of new schema</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveSchemaCompatibilityStrategy2Async(string tenant, string @namespace, string topic, bool? authoritative, string body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Operation not allowed on persistent topic", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get schema validation enforced flag for topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSchemaValidationEnforced2Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative)
        {
            return GetSchemaValidationEnforced2Async(tenant, @namespace, topic, applied, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get schema validation enforced flag for topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSchemaValidationEnforced2Async(string tenant, string @namespace, string topic, bool? applied, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/schemaValidationEnforced?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenants or Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set schema validation enforced flag on topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetSchemaValidationEnforced3Async(string tenant, string @namespace, string topic, bool? authoritative, bool body)
        {
            return SetSchemaValidationEnforced3Async(tenant, @namespace, topic, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set schema validation enforced flag on topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetSchemaValidationEnforced3Async(string tenant, string @namespace, string topic, bool? authoritative, bool body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/schemaValidationEnforced?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or Namespace doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("schemaValidationEnforced value is not valid", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the shadow topic list for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetShadowTopics2Async(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return GetShadowTopics2Async(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the shadow topic list for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetShadowTopics2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/shadowTopics?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set shadow topic list for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">List of shadow topics</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetShadowTopics2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IEnumerable<string> body)
        {
            return SetShadowTopics2Async(tenant, @namespace, topic, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set shadow topic list for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">List of shadow topics</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetShadowTopics2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Collections.Generic.IEnumerable<string> body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/shadowTopics?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete shadow topics for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteShadowTopics2Async(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return DeleteShadowTopics2Async(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete shadow topics for a topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteShadowTopics2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/shadowTopics?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the stats for the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="getPreciseBacklog">If return precise backlog or imprecise backlog</param>
        /// <param name="subscriptionBacklogSize">If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.</param>
        /// <param name="getEarliestTimeInBacklog">If return time of the earliest message in backlog</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetStats2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? getPreciseBacklog, bool? subscriptionBacklogSize, bool? getEarliestTimeInBacklog)
        {
            return GetStats2Async(tenant, @namespace, topic, authoritative, getPreciseBacklog, subscriptionBacklogSize, getEarliestTimeInBacklog, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the stats for the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="getPreciseBacklog">If return precise backlog or imprecise backlog</param>
        /// <param name="subscriptionBacklogSize">If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.</param>
        /// <param name="getEarliestTimeInBacklog">If return time of the earliest message in backlog</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetStats2Async(string tenant, string @namespace, string topic, bool? authoritative, bool? getPreciseBacklog, bool? subscriptionBacklogSize, bool? getEarliestTimeInBacklog, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/stats?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (getPreciseBacklog != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("getPreciseBacklog") + "=").Append(System.Uri.EscapeDataString(ConvertToString(getPreciseBacklog, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (subscriptionBacklogSize != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("subscriptionBacklogSize") + "=").Append(System.Uri.EscapeDataString(ConvertToString(subscriptionBacklogSize, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (getEarliestTimeInBacklog != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("getEarliestTimeInBacklog") + "=").Append(System.Uri.EscapeDataString(ConvertToString(getEarliestTimeInBacklog, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSubscribeRate3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetSubscribeRate3Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSubscribeRate3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscribeRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscribe rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetSubscribeRate3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, SubscribeRate body)
        {
            return SetSubscribeRate3Async(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscribe rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetSubscribeRate3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, SubscribeRate body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscribeRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscribe rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveSubscribeRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, SubscribeRate body)
        {
            return RemoveSubscribeRate2Async(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove subscribe rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscribe rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveSubscribeRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, SubscribeRate body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscribeRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete a subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be deleted</param>
        /// <param name="force">Disconnect and close all consumers and delete subscription forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteSubscription2Async(string tenant, string @namespace, string topic, string subName, bool? force, bool? authoritative)
        {
            return DeleteSubscription2Async(tenant, @namespace, topic, subName, force, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be deleted</param>
        /// <param name="force">Disconnect and close all consumers and delete subscription forcefully</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteSubscription2Async(string tenant, string @namespace, string topic, string subName, bool? force, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscription/{subName}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (force != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("force") + "=").Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Subscription has active consumers", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Analyse a subscription, by scanning all the unprocessed messages
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription</param>
        /// <param name="position">messageId to start the analysis</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task AnalyzeSubscriptionBacklog2Async(string tenant, string @namespace, string topic, string subName, ResetCursorData position, bool? authoritative)
        {
            return AnalyzeSubscriptionBacklog2Async(tenant, @namespace, topic, subName, position, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Analyse a subscription, by scanning all the unprocessed messages
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription</param>
        /// <param name="position">messageId to start the analysis</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task AnalyzeSubscriptionBacklog2Async(string tenant, string @namespace, string topic, string subName, ResetCursorData position, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/analyzeBacklog?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(position, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic/Subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Method Not Allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Expiry messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be Expiry messages on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId to reset back to (ledgerId:entryId)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ExpireTopicMessages3Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, ResetCursorData messageId)
        {
            return ExpireTopicMessages3Async(tenant, @namespace, topic, subName, authoritative, messageId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Expiry messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be Expiry messages on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId to reset back to (ledgerId:entryId)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ExpireTopicMessages3Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, ResetCursorData messageId, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/expireMessages?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(messageId, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic or subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Expiry messages on a non-persistent topic is not allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Expiry messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be Expiry messages on</param>
        /// <param name="expireTimeInSeconds">Expires beyond the specified number of seconds</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ExpireTopicMessages4Async(string tenant, string @namespace, string topic, string subName, int expireTimeInSeconds, bool? authoritative)
        {
            return ExpireTopicMessages4Async(tenant, @namespace, topic, subName, expireTimeInSeconds, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Expiry messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to be Expiry messages on</param>
        /// <param name="expireTimeInSeconds">Expires beyond the specified number of seconds</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ExpireTopicMessages4Async(string tenant, string @namespace, string topic, string subName, int expireTimeInSeconds, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            if (expireTimeInSeconds == null)
                throw new System.ArgumentNullException("expireTimeInSeconds");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/expireMessages/{expireTimeInSeconds}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{expireTimeInSeconds}", System.Uri.EscapeDataString(ConvertToString(expireTimeInSeconds, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic or subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Expiry messages on a non-persistent topic is not allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Peek nth message on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscribed message expired</param>
        /// <param name="messagePosition">The number of messages (default 1)</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PeekNthMessage2Async(string tenant, string @namespace, string topic, string subName, int messagePosition, bool? authoritative)
        {
            return PeekNthMessage2Async(tenant, @namespace, topic, subName, messagePosition, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Peek nth message on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscribed message expired</param>
        /// <param name="messagePosition">The number of messages (default 1)</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PeekNthMessage2Async(string tenant, string @namespace, string topic, string subName, int messagePosition, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            if (messagePosition == null)
                throw new System.ArgumentNullException("messagePosition");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/position/{messagePosition}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{messagePosition}", System.Uri.EscapeDataString(ConvertToString(messagePosition, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic, subscription or the message position does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Skipping messages on a non-persistent topic is not allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Return all the properties on the given subscription
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSubscriptionProperties2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative)
        {
            return GetSubscriptionProperties2Async(tenant, @namespace, topic, subName, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Return all the properties on the given subscription
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSubscriptionProperties2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/properties?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic/Subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Method Not Allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Replace all the properties on the given subscription
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to update</param>
        /// <param name="body">The new properties</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task UpdateSubscriptionProperties2Async(string tenant, string @namespace, string topic, string subName, System.Collections.Generic.IDictionary<string, string> body, bool? authoritative)
        {
            return UpdateSubscriptionProperties2Async(tenant, @namespace, topic, subName, body, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Replace all the properties on the given subscription
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to update</param>
        /// <param name="body">The new properties</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UpdateSubscriptionProperties2Async(string tenant, string @namespace, string topic, string subName, System.Collections.Generic.IDictionary<string, string> body, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/properties?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic/Subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Method Not Allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get replicated subscription status on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetReplicatedSubscriptionStatus2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative)
        {
            return GetReplicatedSubscriptionStatus2Async(tenant, @namespace, topic, subName, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get replicated subscription status on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetReplicatedSubscriptionStatus2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/replicatedSubscriptionStatus?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Can\'t find owner for topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Enable or disable a replicated subscription on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Whether to enable replicated subscription</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetReplicatedSubscriptionStatus2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, bool body)
        {
            return SetReplicatedSubscriptionStatus2Async(tenant, @namespace, topic, subName, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Enable or disable a replicated subscription on a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Whether to enable replicated subscription</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetReplicatedSubscriptionStatus2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, bool body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/replicatedSubscriptionStatus?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant or subscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic or subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Operation not allowed on this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Can\'t find owner for topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Reset subscription to message position closest to given position.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to reset position on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId to reset back to (ledgerId:entryId)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ResetCursorOnPosition2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, ResetCursorData messageId)
        {
            return ResetCursorOnPosition2Async(tenant, @namespace, topic, subName, authoritative, messageId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Reset subscription to message position closest to given position.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to reset position on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId to reset back to (ledgerId:entryId)</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ResetCursorOnPosition2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, ResetCursorData messageId, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/resetcursor?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(messageId, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic/Subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not supported for partitioned topics", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unable to find position for position specified", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Reset subscription to message position closest to absolute timestamp (in ms).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to reset position on</param>
        /// <param name="timestamp">the timestamp to reset back</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ResetCursor2Async(string tenant, string @namespace, string topic, string subName, long timestamp, bool? authoritative)
        {
            return ResetCursor2Async(tenant, @namespace, topic, subName, timestamp, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Reset subscription to message position closest to absolute timestamp (in ms).
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Subscription to reset position on</param>
        /// <param name="timestamp">the timestamp to reset back</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ResetCursor2Async(string tenant, string @namespace, string topic, string subName, long timestamp, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            if (timestamp == null)
                throw new System.ArgumentNullException("timestamp");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/resetcursor/{timestamp}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{timestamp}", System.Uri.EscapeDataString(ConvertToString(timestamp, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic/Subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Method Not Allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to reset cursor on subscription or Unable to find position for timestamp specified", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Skipping messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="numMessages">The number of messages to skip</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SkipMessages2Async(string tenant, string @namespace, string topic, string subName, int numMessages, bool? authoritative)
        {
            return SkipMessages2Async(tenant, @namespace, topic, subName, numMessages, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Skipping messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="numMessages">The number of messages to skip</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SkipMessages2Async(string tenant, string @namespace, string topic, string subName, int numMessages, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            if (numMessages == null)
                throw new System.ArgumentNullException("numMessages");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/skip/{numMessages}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{numMessages}", System.Uri.EscapeDataString(ConvertToString(numMessages, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic or subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Skipping messages on a partitioned topic is not allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Skip all messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SkipAllMessages2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative)
        {
            return SkipAllMessages2Async(tenant, @namespace, topic, subName, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Skip all messages on a topic subscription.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subName">Name of subscription</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SkipAllMessages2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/skip_all?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic or subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Operation not allowed on non-persistent topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Can\'t find owner for topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create a subscription on the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subscriptionName">Subscription to create position on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId where to create the subscription. It can be 'latest', 'earliest' or (ledgerId:entryId)</param>
        /// <param name="replicated">Is replicated required to perform this operation</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task CreateSubscription2Async(string tenant, string @namespace, string topic, string subscriptionName, bool? authoritative, ResetCursorData messageId, bool? replicated)
        {
            return CreateSubscription2Async(tenant, @namespace, topic, subscriptionName, authoritative, messageId, replicated, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a subscription on the topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="subscriptionName">Subscription to create position on</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="messageId">messageId where to create the subscription. It can be 'latest', 'earliest' or (ledgerId:entryId)</param>
        /// <param name="replicated">Is replicated required to perform this operation</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task CreateSubscription2Async(string tenant, string @namespace, string topic, string subscriptionName, bool? authoritative, ResetCursorData messageId, bool? replicated, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subscriptionName == null)
                throw new System.ArgumentNullException("subscriptionName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscription/{subscriptionName}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subscriptionName}", System.Uri.EscapeDataString(ConvertToString(subscriptionName, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (replicated != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("replicated") + "=").Append(System.Uri.EscapeDataString(ConvertToString(replicated, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(messageId, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Create subscription on non persistent topic is not supported", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic/Subscription does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not supported for partitioned topics", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSubscriptionDispatchRate3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetSubscriptionDispatchRate3Async(tenant, @namespace, topic, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSubscriptionDispatchRate3Async(string tenant, string @namespace, string topic, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscription message dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetSubscriptionDispatchRate3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, DispatchRateImpl body)
        {
            return SetSubscriptionDispatchRate3Async(tenant, @namespace, topic, authoritative, isGlobal, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscription message dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetSubscriptionDispatchRate3Async(string tenant, string @namespace, string topic, bool? authoritative, bool? isGlobal, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveSubscriptionDispatchRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveSubscriptionDispatchRate2Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove subscription message dispatch rate configuration for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveSubscriptionDispatchRate2Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get is enable sub type fors specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSubscriptionTypesEnabled3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return GetSubscriptionTypesEnabled3Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get is enable sub type fors specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSubscriptionTypesEnabled3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set is enable sub types for specified topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Enable sub types for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetSubscriptionTypesEnabled3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Collections.Generic.IEnumerable<Anonymous6> body)
        {
            return SetSubscriptionTypesEnabled3Async(tenant, @namespace, topic, isGlobal, authoritative, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set is enable sub types for specified topic
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Enable sub types for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetSubscriptionTypesEnabled3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Collections.Generic.IEnumerable<Anonymous6> body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove subscription types enabled for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveSubscriptionTypesEnabled3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative)
        {
            return RemoveSubscriptionTypesEnabled3Async(tenant, @namespace, topic, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove subscription types enabled for specified topic.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveSubscriptionTypesEnabled3Async(string tenant, string @namespace, string topic, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, to enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the list of persistent subscriptions for a given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSubscriptions2Async(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return GetSubscriptions2Async(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of persistent subscriptions for a given topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSubscriptions2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/subscriptions?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Terminate a topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task Terminate2Async(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return Terminate2Async(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Terminate a topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task Terminate2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/terminate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Termination of a partitioned topic is not allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 406)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Need to provide a persistent topic name", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Terminate all partitioned topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task TerminatePartitionedTopic2Async(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return TerminatePartitionedTopic2Async(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Terminate all partitioned topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task TerminatePartitionedTopic2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/terminate/partitions?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant orsubscriber is not authorized to access this operation", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Termination of a non-partitioned topic is not allowed", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Truncate a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task TruncateTopic2Async(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return TruncateTopic2Async(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Truncate a topic.
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task TruncateTopic2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/truncate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Unload a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task UnloadTopic2Async(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return UnloadTopic2Async(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unload a topic
        /// </summary>
        /// <param name="tenant">Specify the tenant</param>
        /// <param name="namespace">Specify the namespace</param>
        /// <param name="topic">Specify topic name</param>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UnloadTopic2Async(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/unload?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have permission to administrate resources on this tenant", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic name is not valid or can\'t find owner for topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to validate global cluster configuration", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetSubscriptionLevelDispatchRate2Async(string tenant, string @namespace, string topic, string subName, bool? applied, bool? isGlobal, bool? authoritative)
        {
            return GetSubscriptionLevelDispatchRate2Async(tenant, @namespace, topic, subName, applied, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetSubscriptionLevelDispatchRate2Async(string tenant, string @namespace, string topic, string subName, bool? applied, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (applied != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applied") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applied, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscription message dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetSubscriptionLevelDispatchRate2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, bool? isGlobal, DispatchRateImpl body)
        {
            return SetSubscriptionLevelDispatchRate2Async(tenant, @namespace, topic, subName, authoritative, isGlobal, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <param name="body">Subscription message dispatch rate for the specified topic</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetSubscriptionLevelDispatchRate2Async(string tenant, string @namespace, string topic, string subName, bool? authoritative, bool? isGlobal, DispatchRateImpl body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveSubscriptionLevelDispatchRate2Async(string tenant, string @namespace, string topic, string subName, bool? isGlobal, bool? authoritative)
        {
            return RemoveSubscriptionLevelDispatchRate2Async(tenant, @namespace, topic, subName, isGlobal, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove message dispatch rate configuration for specified subscription.
        /// </summary>
        /// <param name="authoritative">Whether leader broker redirected this call to this broker. For internal use.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveSubscriptionLevelDispatchRate2Async(string tenant, string @namespace, string topic, string subName, bool? isGlobal, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (subName == null)
                throw new System.ArgumentNullException("subName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subName}", System.Uri.EscapeDataString(ConvertToString(subName, System.Globalization.CultureInfo.InvariantCulture)));
            if (isGlobal != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isGlobal") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isGlobal, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Topic level policy is disabled, please enable the topic level policy and retry", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the default quota
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetDefaultResourceQuotaAsync()
        {
            return GetDefaultResourceQuotaAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the default quota
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetDefaultResourceQuotaAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("resource-quotas");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set the default quota
        /// </summary>
        /// <param name="body">Default resource quota</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> SetDefaultResourceQuotaAsync(ResourceQuota body)
        {
            return SetDefaultResourceQuotaAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set the default quota
        /// </summary>
        /// <param name="body">Default resource quota</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> SetDefaultResourceQuotaAsync(ResourceQuota body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("resource-quotas");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get resource quota of a namespace bundle.
        /// </summary>
        /// <param name="tenant">Tenant name</param>
        /// <param name="namespace">Namespace name within the specified tenant</param>
        /// <param name="bundle">Namespace bundle range</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetNamespaceBundleResourceQuotaAsync(string tenant, string @namespace, string bundle)
        {
            return GetNamespaceBundleResourceQuotaAsync(tenant, @namespace, bundle, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get resource quota of a namespace bundle.
        /// </summary>
        /// <param name="tenant">Tenant name</param>
        /// <param name="namespace">Namespace name within the specified tenant</param>
        /// <param name="bundle">Namespace bundle range</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetNamespaceBundleResourceQuotaAsync(string tenant, string @namespace, string bundle, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (bundle == null)
                throw new System.ArgumentNullException("bundle");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("resource-quotas/{tenant}/{namespace}/{bundle}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{bundle}", System.Uri.EscapeDataString(ConvertToString(bundle, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Namespace does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set resource quota on a namespace.
        /// </summary>
        /// <param name="tenant">Tenant name</param>
        /// <param name="namespace">Namespace name within the specified tenant</param>
        /// <param name="bundle">Namespace bundle range</param>
        /// <param name="body">Resource quota for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SetNamespaceBundleResourceQuotaAsync(string tenant, string @namespace, string bundle, ResourceQuota body)
        {
            return SetNamespaceBundleResourceQuotaAsync(tenant, @namespace, bundle, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set resource quota on a namespace.
        /// </summary>
        /// <param name="tenant">Tenant name</param>
        /// <param name="namespace">Namespace name within the specified tenant</param>
        /// <param name="bundle">Namespace bundle range</param>
        /// <param name="body">Resource quota for the specified namespace</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SetNamespaceBundleResourceQuotaAsync(string tenant, string @namespace, string bundle, ResourceQuota body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (bundle == null)
                throw new System.ArgumentNullException("bundle");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("resource-quotas/{tenant}/{namespace}/{bundle}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{bundle}", System.Uri.EscapeDataString(ConvertToString(bundle, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove resource quota for a namespace.
        /// </summary>
        /// <param name="tenant">Tenant name</param>
        /// <param name="namespace">Namespace name within the specified tenant</param>
        /// <param name="bundle">Namespace bundle range</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveNamespaceBundleResourceQuotaAsync(string tenant, string @namespace, string bundle)
        {
            return RemoveNamespaceBundleResourceQuotaAsync(tenant, @namespace, bundle, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove resource quota for a namespace.
        /// </summary>
        /// <param name="tenant">Tenant name</param>
        /// <param name="namespace">Namespace name within the specified tenant</param>
        /// <param name="bundle">Namespace bundle range</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveNamespaceBundleResourceQuotaAsync(string tenant, string @namespace, string bundle, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (bundle == null)
                throw new System.ArgumentNullException("bundle");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("resource-quotas/{tenant}/{namespace}/{bundle}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{bundle}", System.Uri.EscapeDataString(ConvertToString(bundle, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Concurrent modification", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the list of all the resourcegroups.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetResourceGroupsAsync()
        {
            return GetResourceGroupsAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of all the resourcegroups.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetResourceGroupsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("resourcegroups");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the rate limiters specified for a resourcegroup.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ResourceGroup> GetResourceGroupAsync(string resourcegroup)
        {
            return GetResourceGroupAsync(resourcegroup, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the rate limiters specified for a resourcegroup.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ResourceGroup> GetResourceGroupAsync(string resourcegroup, System.Threading.CancellationToken cancellationToken)
        {
            if (resourcegroup == null)
                throw new System.ArgumentNullException("resourcegroup");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("resourcegroups/{resourcegroup}");
            urlBuilder_.Replace("{resourcegroup}", System.Uri.EscapeDataString(ConvertToString(resourcegroup, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ResourceGroup>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("ResourceGroup doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Creates a new resourcegroup with the specified rate limiters
        /// </summary>
        /// <param name="body">Rate limiters for the resourcegroup</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task CreateOrUpdateResourceGroupAsync(string resourcegroup, ResourceGroup body)
        {
            return CreateOrUpdateResourceGroupAsync(resourcegroup, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates a new resourcegroup with the specified rate limiters
        /// </summary>
        /// <param name="body">Rate limiters for the resourcegroup</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task CreateOrUpdateResourceGroupAsync(string resourcegroup, ResourceGroup body, System.Threading.CancellationToken cancellationToken)
        {
            if (resourcegroup == null)
                throw new System.ArgumentNullException("resourcegroup");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("resourcegroups/{resourcegroup}");
            urlBuilder_.Replace("{resourcegroup}", System.Uri.EscapeDataString(ConvertToString(resourcegroup, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("cluster doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete a resourcegroup.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteResourceGroupAsync(string resourcegroup)
        {
            return DeleteResourceGroupAsync(resourcegroup, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a resourcegroup.
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteResourceGroupAsync(string resourcegroup, System.Threading.CancellationToken cancellationToken)
        {
            if (resourcegroup == null)
                throw new System.ArgumentNullException("resourcegroup");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("resourcegroups/{resourcegroup}");
            urlBuilder_.Replace("{resourcegroup}", System.Uri.EscapeDataString(ConvertToString(resourcegroup, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("ResourceGroup doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("ResourceGroup is in use", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// test the schema compatibility
        /// </summary>
        /// <param name="body">A JSON value presenting a schema payload. An example of the expected schema can be found down here.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<IsCompatibilityResponse> TestCompatibilityAsync(string tenant, string @namespace, string topic, PostSchemaPayload body, bool? authoritative)
        {
            return TestCompatibilityAsync(tenant, @namespace, topic, body, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// test the schema compatibility
        /// </summary>
        /// <param name="body">A JSON value presenting a schema payload. An example of the expected schema can be found down here.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<IsCompatibilityResponse> TestCompatibilityAsync(string tenant, string @namespace, string topic, PostSchemaPayload body, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("schemas/{tenant}/{namespace}/{topic}/compatibility?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<IsCompatibilityResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Client is not authorized or Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Client is not authenticated", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or Namespace or Topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to find the ownership for the topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal Server Error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the schema of a topic
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetSchemaResponse> GetSchemaAsync(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return GetSchemaAsync(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the schema of a topic
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetSchemaResponse> GetSchemaAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("schemas/{tenant}/{namespace}/{topic}/schema?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetSchemaResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Client is not authorized or Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Client is not authenticated", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or Namespace or Topic doesn\'t exist; or Schema is not found for this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to find the ownership for the topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal Server Error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update the schema of a topic
        /// </summary>
        /// <param name="body">A JSON value presenting a schema payload. An example of the expected schema can be found down here.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PostSchemaResponse> PostSchemaAsync(string tenant, string @namespace, string topic, PostSchemaPayload body, bool? authoritative)
        {
            return PostSchemaAsync(tenant, @namespace, topic, body, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update the schema of a topic
        /// </summary>
        /// <param name="body">A JSON value presenting a schema payload. An example of the expected schema can be found down here.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PostSchemaResponse> PostSchemaAsync(string tenant, string @namespace, string topic, PostSchemaPayload body, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("schemas/{tenant}/{namespace}/{topic}/schema?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PostSchemaResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Client is not authorized or Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Client is not authenticated", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or Namespace or Topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Incompatible schema", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to find the ownership for the topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 422)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid schema data", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal Server Error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete the schema of a topic
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<DeleteSchemaResponse> DeleteSchemaAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? force)
        {
            return DeleteSchemaAsync(tenant, @namespace, topic, authoritative, force, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete the schema of a topic
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<DeleteSchemaResponse> DeleteSchemaAsync(string tenant, string @namespace, string topic, bool? authoritative, bool? force, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("schemas/{tenant}/{namespace}/{topic}/schema?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (force != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("force") + "=").Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DeleteSchemaResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Client is not authorized or Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Client is not authenticated", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or Namespace or Topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to find the ownership for the topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal Server Error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the schema of a topic at a given version
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetSchemaResponse> GetSchema2Async(string tenant, string @namespace, string topic, string version, bool? authoritative)
        {
            return GetSchema2Async(tenant, @namespace, topic, version, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the schema of a topic at a given version
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetSchemaResponse> GetSchema2Async(string tenant, string @namespace, string topic, string version, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            if (version == null)
                throw new System.ArgumentNullException("version");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("schemas/{tenant}/{namespace}/{topic}/schema/{version}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{version}", System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetSchemaResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Client is not authorized or Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Client is not authenticated", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or Namespace or Topic doesn\'t exist; or Schema is not found for this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to find the ownership for the topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal Server Error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the all schemas of a topic
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetAllVersionsSchemaResponse> GetAllSchemasAsync(string tenant, string @namespace, string topic, bool? authoritative)
        {
            return GetAllSchemasAsync(tenant, @namespace, topic, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the all schemas of a topic
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetAllVersionsSchemaResponse> GetAllSchemasAsync(string tenant, string @namespace, string topic, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("schemas/{tenant}/{namespace}/{topic}/schemas?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetAllVersionsSchemaResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Client is not authorized or Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Client is not authenticated", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or Namespace or Topic doesn\'t exist; or Schema is not found for this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to find the ownership for the topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal Server Error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// get the version of the schema
        /// </summary>
        /// <param name="body">A JSON value presenting a schema payload. An example of the expected schema can be found down here.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<LongSchemaVersion> GetVersionBySchemaAsync(string tenant, string @namespace, string topic, PostSchemaPayload body, bool? authoritative)
        {
            return GetVersionBySchemaAsync(tenant, @namespace, topic, body, authoritative, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// get the version of the schema
        /// </summary>
        /// <param name="body">A JSON value presenting a schema payload. An example of the expected schema can be found down here.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<LongSchemaVersion> GetVersionBySchemaAsync(string tenant, string @namespace, string topic, PostSchemaPayload body, bool? authoritative, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (topic == null)
                throw new System.ArgumentNullException("topic");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("schemas/{tenant}/{namespace}/{topic}/version?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{topic}", System.Uri.EscapeDataString(ConvertToString(topic, System.Globalization.CultureInfo.InvariantCulture)));
            if (authoritative != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("authoritative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(authoritative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LongSchemaVersion>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Client is not authorized or Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Client is not authenticated", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant or Namespace or Topic doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Failed to find the ownership for the topic", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 422)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid schema data", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal Server Error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the list of existing tenants.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetTenantsAsync()
        {
            return GetTenantsAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the list of existing tenants.
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetTenantsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("tenants");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the admin configuration for a given tenant.
        /// </summary>
        /// <param name="tenant">The tenant name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task GetTenantAdminAsync(string tenant)
        {
            return GetTenantAdminAsync(tenant, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the admin configuration for a given tenant.
        /// </summary>
        /// <param name="tenant">The tenant name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetTenantAdminAsync(string tenant, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("tenants/{tenant}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant does not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update the admins for a tenant.
        /// </summary>
        /// <param name="tenant">The tenant name</param>
        /// <param name="body">TenantInfo</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task UpdateTenantAsync(string tenant, TenantInfo body)
        {
            return UpdateTenantAsync(tenant, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update the admins for a tenant.
        /// </summary>
        /// <param name="tenant">The tenant name</param>
        /// <param name="body">TenantInfo</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UpdateTenantAsync(string tenant, TenantInfo body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("tenants/{tenant}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant already exists", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Clusters do not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create a new tenant.
        /// </summary>
        /// <param name="tenant">The tenant name</param>
        /// <param name="body">TenantInfo</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task CreateTenantAsync(string tenant, TenantInfo body)
        {
            return CreateTenantAsync(tenant, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a new tenant.
        /// </summary>
        /// <param name="tenant">The tenant name</param>
        /// <param name="body">TenantInfo</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task CreateTenantAsync(string tenant, TenantInfo body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("tenants/{tenant}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant already exists", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 412)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Clusters do not exist", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete a tenant and all namespaces and topics under it.
        /// </summary>
        /// <param name="tenant">The tenant name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteTenantAsync(string tenant, bool? force)
        {
            return DeleteTenantAsync(tenant, force, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a tenant and all namespaces and topics under it.
        /// </summary>
        /// <param name="tenant">The tenant name</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteTenantAsync(string tenant, bool? force, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("tenants/{tenant}?");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            if (force != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("force") + "=").Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tenant does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Broker doesn\'t allow forced deletion of tenants", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The tenant still has active namespaces", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get metrics for all functions owned by worker
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<WorkerFunctionInstanceStats>> GetStatsAllAsync()
        {
            return GetStatsAllAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get metrics for all functions owned by worker
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<WorkerFunctionInstanceStats>> GetStatsAllAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("worker-stats/functionsmetrics");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<WorkerFunctionInstanceStats>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Worker service is not running", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Gets the metrics for Monitoring
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Metrics>> GetMetrics2Async()
        {
            return GetMetrics2Async(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets the metrics for Monitoring
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Metrics>> GetMetrics2Async(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("worker-stats/metrics");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<Metrics>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Don\'t have admin permission", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Worker service is not running", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Fetches information about which Pulsar Functions are assigned to which Pulsar clusters
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, object>> GetAssignmentsAsync()
        {
            return GetAssignmentsAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fetches information about which Pulsar Functions are assigned to which Pulsar clusters
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, object>> GetAssignmentsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("worker/assignments");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, object>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Worker service is not running", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Fetches information about the Pulsar cluster running Pulsar Functions
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<WorkerInfo>> GetClusterAllAsync()
        {
            return GetClusterAllAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fetches information about the Pulsar cluster running Pulsar Functions
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<WorkerInfo>> GetClusterAllAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("worker/cluster");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<WorkerInfo>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Worker service is not running", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Fetches info about the leader node of the Pulsar cluster running Pulsar Functions
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<WorkerInfo> GetClusterLeaderAsync()
        {
            return GetClusterLeaderAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fetches info about the leader node of the Pulsar cluster running Pulsar Functions
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<WorkerInfo> GetClusterLeaderAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("worker/cluster/leader");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<WorkerInfo>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Worker service is not running", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Checks if this node is the leader and is ready to service requests
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<bool> IsLeaderReadyAsync()
        {
            return IsLeaderReadyAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Checks if this node is the leader and is ready to service requests
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<bool> IsLeaderReadyAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("worker/cluster/leader/ready");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<bool>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Worker service is not running", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Fetches a list of supported Pulsar IO connectors currently running in cluster mode
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<object>> GetConnectorsListAsync()
        {
            return GetConnectorsListAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fetches a list of supported Pulsar IO connectors currently running in cluster mode
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<object>> GetConnectorsListAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("worker/connectors");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<object>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 408)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Request timeout", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the status of any ongoing drain operation at this worker
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<LongRunningProcessStatus> GetDrainStatusAsync()
        {
            return GetDrainStatusAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the status of any ongoing drain operation at this worker
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<LongRunningProcessStatus> GetDrainStatusAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("worker/drain");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LongRunningProcessStatus>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Worker service is not ready", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Drains this worker, i.e., moves its work-assignments to other workers
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DrainAsync()
        {
            return DrainAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Drains this worker, i.e., moves its work-assignments to other workers
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DrainAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("worker/drain");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 408)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Request timeout", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Drain already in progress", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Worker service is not ready", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the status of any ongoing drain operation at the specified worker
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<LongRunningProcessStatus> GetDrainStatusFromLeaderAsync(string workerId)
        {
            return GetDrainStatusFromLeaderAsync(workerId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the status of any ongoing drain operation at the specified worker
        /// </summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<LongRunningProcessStatus> GetDrainStatusFromLeaderAsync(string workerId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("worker/leader/drain?");
            if (workerId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("workerId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(workerId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LongRunningProcessStatus>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Worker service is not ready", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Drains the specified worker, i.e., moves its work-assignments to other workers
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DrainAtLeaderAsync(string workerId)
        {
            return DrainAtLeaderAsync(workerId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Drains the specified worker, i.e., moves its work-assignments to other workers
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DrainAtLeaderAsync(string workerId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("worker/leader/drain?");
            if (workerId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("workerId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(workerId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 408)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Request timeout", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Drain already in progress", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Worker service is not ready", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Triggers a rebalance of functions to workers
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RebalanceAsync()
        {
            return RebalanceAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Triggers a rebalance of functions to workers
        /// </summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RebalanceAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("worker/rebalance");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 408)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Request timeout", status_, responseText_, headers_, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class AllocatorStats
    {
        [Newtonsoft.Json.JsonProperty("numDirectArenas", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumDirectArenas { get; set; }

        [Newtonsoft.Json.JsonProperty("numHeapArenas", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumHeapArenas { get; set; }

        [Newtonsoft.Json.JsonProperty("numThreadLocalCaches", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumThreadLocalCaches { get; set; }

        [Newtonsoft.Json.JsonProperty("normalCacheSize", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NormalCacheSize { get; set; }

        [Newtonsoft.Json.JsonProperty("smallCacheSize", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SmallCacheSize { get; set; }

        [Newtonsoft.Json.JsonProperty("directArenas", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PoolArenaStats> DirectArenas { get; set; }

        [Newtonsoft.Json.JsonProperty("heapArenas", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PoolArenaStats> HeapArenas { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class Annotation
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class AnnotationIntrospector
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ArrayBuilders
    {
        [Newtonsoft.Json.JsonProperty("booleanBuilder", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public BooleanBuilder BooleanBuilder { get; set; }

        [Newtonsoft.Json.JsonProperty("byteBuilder", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ByteBuilder ByteBuilder { get; set; }

        [Newtonsoft.Json.JsonProperty("shortBuilder", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ShortBuilder ShortBuilder { get; set; }

        [Newtonsoft.Json.JsonProperty("intBuilder", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IntBuilder IntBuilder { get; set; }

        [Newtonsoft.Json.JsonProperty("longBuilder", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LongBuilder LongBuilder { get; set; }

        [Newtonsoft.Json.JsonProperty("floatBuilder", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FloatBuilder FloatBuilder { get; set; }

        [Newtonsoft.Json.JsonProperty("doubleBuilder", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DoubleBuilder DoubleBuilder { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class AuthPolicies
    {
        [Newtonsoft.Json.JsonProperty("namespaceAuthentication", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<Anonymous7>> NamespaceAuthentication { get; set; }

        [Newtonsoft.Json.JsonProperty("subscriptionAuthentication", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<string>> SubscriptionAuthentication { get; set; }

        [Newtonsoft.Json.JsonProperty("topicAuthentication", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<Anonymous8>>> TopicAuthentication { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class AuthenticationDataSource
    {
        [Newtonsoft.Json.JsonProperty("peerAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SocketAddress PeerAddress { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsCertificates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Certificate> TlsCertificates { get; set; }

        [Newtonsoft.Json.JsonProperty("httpAuthType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HttpAuthType { get; set; }

        [Newtonsoft.Json.JsonProperty("commandData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CommandData { get; set; }

        [Newtonsoft.Json.JsonProperty("subscription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Subscription { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class AutoFailoverPolicyData
    {
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Parameters { get; set; }

        [Newtonsoft.Json.JsonProperty("policyType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AutoFailoverPolicyDataPolicyType? PolicyType { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class AutoSubscriptionCreationOverride
    {
        [Newtonsoft.Json.JsonProperty("allowAutoSubscriptionCreation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AllowAutoSubscriptionCreation { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class AutoTopicCreationOverride
    {
        [Newtonsoft.Json.JsonProperty("topicType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TopicType { get; set; }

        [Newtonsoft.Json.JsonProperty("defaultNumPartitions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? DefaultNumPartitions { get; set; }

        [Newtonsoft.Json.JsonProperty("allowAutoTopicCreation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AllowAutoTopicCreation { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class BacklogQuota
    {
        [Newtonsoft.Json.JsonProperty("policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BacklogQuotaPolicy? Policy { get; set; }

        [Newtonsoft.Json.JsonProperty("limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Limit { get; set; }

        [Newtonsoft.Json.JsonProperty("limitSize", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? LimitSize { get; set; }

        [Newtonsoft.Json.JsonProperty("limitTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? LimitTime { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class Base64Variant
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("maxLineLength", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxLineLength { get; set; }

        [Newtonsoft.Json.JsonProperty("paddingChar", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PaddingChar { get; set; }

        [Newtonsoft.Json.JsonProperty("paddingByte", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] PaddingByte { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class BookieAffinityGroupData
    {
        [Newtonsoft.Json.JsonProperty("bookkeeperAffinityGroupPrimary", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BookkeeperAffinityGroupPrimary { get; set; }

        [Newtonsoft.Json.JsonProperty("bookkeeperAffinityGroupSecondary", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BookkeeperAffinityGroupSecondary { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class BookieInfo
    {
        [Newtonsoft.Json.JsonProperty("hostname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Hostname { get; set; }

        [Newtonsoft.Json.JsonProperty("rack", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rack { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class BookiesClusterInfo
    {
        [Newtonsoft.Json.JsonProperty("bookies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RawBookieInfo> Bookies { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class BooleanBuilder
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class BrokerInfo
    {
        [Newtonsoft.Json.JsonProperty("serviceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServiceUrl { get; set; }

    }

    /// <summary>
    /// The namespace isolation data for a given broker
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class BrokerNamespaceIsolationData
    {
        /// <summary>
        /// The broker name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("brokerName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BrokerName { get; set; }

        /// <summary>
        /// Policy name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("policyName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PolicyName { get; set; }

        /// <summary>
        /// The namespace-isolation policies attached to this broker
        /// </summary>
        [Newtonsoft.Json.JsonProperty("namespaceRegex", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> NamespaceRegex { get; set; }

        [Newtonsoft.Json.JsonProperty("primary", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Primary { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class BundlesData
    {
        [Newtonsoft.Json.JsonProperty("boundaries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Boundaries { get; set; }

        [Newtonsoft.Json.JsonProperty("numBundles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumBundles { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ByteBuilder
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class Certificate
    {
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        [Newtonsoft.Json.JsonProperty("encoded", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<byte[]> Encoded { get; set; }

        [Newtonsoft.Json.JsonProperty("publicKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PublicKey PublicKey { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class CharacterEscapes
    {
        [Newtonsoft.Json.JsonProperty("escapeCodesForAscii", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<int> EscapeCodesForAscii { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ClassIntrospector
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ClassLoader
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("registeredAsParallelCapable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RegisteredAsParallelCapable { get; set; }

        [Newtonsoft.Json.JsonProperty("parent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ClassLoader Parent { get; set; }

        [Newtonsoft.Json.JsonProperty("unnamedModule", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Module UnnamedModule { get; set; }

        [Newtonsoft.Json.JsonProperty("definedPackages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Package> DefinedPackages { get; set; }

    }

    /// <summary>
    /// The configuration data for a cluster
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ClusterData
    {
        /// <summary>
        /// The HTTP rest service URL (for admin operations)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serviceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServiceUrl { get; set; }

        /// <summary>
        /// The HTTPS rest service URL (for admin operations)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serviceUrlTls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServiceUrlTls { get; set; }

        /// <summary>
        /// The broker service url (for produce and consume operations)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("brokerServiceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BrokerServiceUrl { get; set; }

        /// <summary>
        /// The secured broker service url (for produce and consume operations)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("brokerServiceUrlTls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BrokerServiceUrlTls { get; set; }

        /// <summary>
        /// Proxy-service url when client would like to connect to broker via proxy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("proxyServiceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProxyServiceUrl { get; set; }

        /// <summary>
        /// Authentication plugin when client would like to connect to cluster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authenticationPlugin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AuthenticationPlugin { get; set; }

        /// <summary>
        /// Authentication parameters when client would like to connect to cluster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authenticationParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AuthenticationParameters { get; set; }

        /// <summary>
        /// protocol to decide type of proxy routing eg: SNI-routing
        /// </summary>
        [Newtonsoft.Json.JsonProperty("proxyProtocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ClusterDataProxyProtocol? ProxyProtocol { get; set; }

        /// <summary>
        /// A set of peer cluster names
        /// </summary>
        [Newtonsoft.Json.JsonProperty("peerClusterNames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> PeerClusterNames { get; set; }

        /// <summary>
        /// Enable TLS when talking with other brokers in the same cluster (admin operation) or different clusters (replication)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("brokerClientTlsEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? BrokerClientTlsEnabled { get; set; }

        /// <summary>
        /// Allow TLS connections to servers whose certificate cannot be be verified to have been signed by a trusted certificate authority.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tlsAllowInsecureConnection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? TlsAllowInsecureConnection { get; set; }

        /// <summary>
        /// Whether internal client use KeyStore type to authenticate with other Pulsar brokers
        /// </summary>
        [Newtonsoft.Json.JsonProperty("brokerClientTlsEnabledWithKeyStore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? BrokerClientTlsEnabledWithKeyStore { get; set; }

        /// <summary>
        /// TLS TrustStore type configuration for internal client: JKS, PKCS12 used by the internal client to authenticate with Pulsar brokers
        /// </summary>
        [Newtonsoft.Json.JsonProperty("brokerClientTlsTrustStoreType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BrokerClientTlsTrustStoreType { get; set; }

        /// <summary>
        /// TLS TrustStore path for internal client used by the internal client to authenticate with Pulsar brokers
        /// </summary>
        [Newtonsoft.Json.JsonProperty("brokerClientTlsTrustStore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BrokerClientTlsTrustStore { get; set; }

        /// <summary>
        /// TLS TrustStore password for internal client used by the internal client to authenticate with Pulsar brokers
        /// </summary>
        [Newtonsoft.Json.JsonProperty("brokerClientTlsTrustStorePassword", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BrokerClientTlsTrustStorePassword { get; set; }

        /// <summary>
        /// Path for the trusted TLS certificate file for outgoing connection to a server (broker)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("brokerClientTrustCertsFilePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BrokerClientTrustCertsFilePath { get; set; }

        /// <summary>
        /// listenerName when client would like to connect to cluster
        /// </summary>
        [Newtonsoft.Json.JsonProperty("listenerName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ListenerName { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class CompletableFuture
    {
        [Newtonsoft.Json.JsonProperty("cancelled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Cancelled { get; set; }

        [Newtonsoft.Json.JsonProperty("done", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Done { get; set; }

        [Newtonsoft.Json.JsonProperty("numberOfDependents", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumberOfDependents { get; set; }

        [Newtonsoft.Json.JsonProperty("completedExceptionally", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CompletedExceptionally { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class CompletableFutureClusterData
    {
        [Newtonsoft.Json.JsonProperty("cancelled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Cancelled { get; set; }

        [Newtonsoft.Json.JsonProperty("done", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Done { get; set; }

        [Newtonsoft.Json.JsonProperty("numberOfDependents", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumberOfDependents { get; set; }

        [Newtonsoft.Json.JsonProperty("completedExceptionally", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CompletedExceptionally { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class CompletableFutureListSchemaAndMetadata
    {
        [Newtonsoft.Json.JsonProperty("cancelled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Cancelled { get; set; }

        [Newtonsoft.Json.JsonProperty("done", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Done { get; set; }

        [Newtonsoft.Json.JsonProperty("numberOfDependents", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumberOfDependents { get; set; }

        [Newtonsoft.Json.JsonProperty("completedExceptionally", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CompletedExceptionally { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class CompletableFutureLong
    {
        [Newtonsoft.Json.JsonProperty("cancelled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Cancelled { get; set; }

        [Newtonsoft.Json.JsonProperty("done", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Done { get; set; }

        [Newtonsoft.Json.JsonProperty("numberOfDependents", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumberOfDependents { get; set; }

        [Newtonsoft.Json.JsonProperty("completedExceptionally", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CompletedExceptionally { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class CompletableFuturePairBooleanSchemaCompatibilityStrategy
    {
        [Newtonsoft.Json.JsonProperty("cancelled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Cancelled { get; set; }

        [Newtonsoft.Json.JsonProperty("done", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Done { get; set; }

        [Newtonsoft.Json.JsonProperty("numberOfDependents", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumberOfDependents { get; set; }

        [Newtonsoft.Json.JsonProperty("completedExceptionally", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CompletedExceptionally { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class CompletableFuturePartitionedTopicMetadata
    {
        [Newtonsoft.Json.JsonProperty("cancelled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Cancelled { get; set; }

        [Newtonsoft.Json.JsonProperty("done", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Done { get; set; }

        [Newtonsoft.Json.JsonProperty("numberOfDependents", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumberOfDependents { get; set; }

        [Newtonsoft.Json.JsonProperty("completedExceptionally", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CompletedExceptionally { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class CompletableFutureResourceQuota
    {
        [Newtonsoft.Json.JsonProperty("cancelled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Cancelled { get; set; }

        [Newtonsoft.Json.JsonProperty("done", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Done { get; set; }

        [Newtonsoft.Json.JsonProperty("numberOfDependents", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumberOfDependents { get; set; }

        [Newtonsoft.Json.JsonProperty("completedExceptionally", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CompletedExceptionally { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class CompletableFutureSchemaAndMetadata
    {
        [Newtonsoft.Json.JsonProperty("cancelled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Cancelled { get; set; }

        [Newtonsoft.Json.JsonProperty("done", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Done { get; set; }

        [Newtonsoft.Json.JsonProperty("numberOfDependents", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumberOfDependents { get; set; }

        [Newtonsoft.Json.JsonProperty("completedExceptionally", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CompletedExceptionally { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class CompletableFutureSchemaVersion
    {
        [Newtonsoft.Json.JsonProperty("cancelled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Cancelled { get; set; }

        [Newtonsoft.Json.JsonProperty("done", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Done { get; set; }

        [Newtonsoft.Json.JsonProperty("numberOfDependents", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumberOfDependents { get; set; }

        [Newtonsoft.Json.JsonProperty("completedExceptionally", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CompletedExceptionally { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class CompletableFutureVoid
    {
        [Newtonsoft.Json.JsonProperty("cancelled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Cancelled { get; set; }

        [Newtonsoft.Json.JsonProperty("done", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Done { get; set; }

        [Newtonsoft.Json.JsonProperty("numberOfDependents", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumberOfDependents { get; set; }

        [Newtonsoft.Json.JsonProperty("completedExceptionally", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CompletedExceptionally { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ConnectorDefinition
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        [Newtonsoft.Json.JsonProperty("sourceClass", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SourceClass { get; set; }

        [Newtonsoft.Json.JsonProperty("sinkClass", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SinkClass { get; set; }

        [Newtonsoft.Json.JsonProperty("sourceConfigClass", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SourceConfigClass { get; set; }

        [Newtonsoft.Json.JsonProperty("sinkConfigClass", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SinkConfigClass { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ContextAttributes
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class Currency
    {
        [Newtonsoft.Json.JsonProperty("currencyCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CurrencyCode { get; set; }

        [Newtonsoft.Json.JsonProperty("defaultFractionDigits", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? DefaultFractionDigits { get; set; }

        [Newtonsoft.Json.JsonProperty("numericCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumericCode { get; set; }

        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayName { get; set; }

        [Newtonsoft.Json.JsonProperty("symbol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Symbol { get; set; }

        [Newtonsoft.Json.JsonProperty("numericCodeAsString", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NumericCodeAsString { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class DateFormat
    {
        [Newtonsoft.Json.JsonProperty("calendar", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Calendar { get; set; }

        [Newtonsoft.Json.JsonProperty("numberFormat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NumberFormat NumberFormat { get; set; }

        [Newtonsoft.Json.JsonProperty("timeZone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TimeZone TimeZone { get; set; }

        [Newtonsoft.Json.JsonProperty("lenient", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Lenient { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class DelayedDeliveryPolicies
    {
        [Newtonsoft.Json.JsonProperty("active", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Active { get; set; }

        [Newtonsoft.Json.JsonProperty("tickTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? TickTime { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class DeleteSchemaResponse
    {
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Version { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class DeserializationConfig
    {
        [Newtonsoft.Json.JsonProperty("annotationIntrospector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AnnotationIntrospector AnnotationIntrospector { get; set; }

        [Newtonsoft.Json.JsonProperty("defaultPropertyInclusion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Value DefaultPropertyInclusion { get; set; }

        [Newtonsoft.Json.JsonProperty("nodeFactory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JsonNodeFactory NodeFactory { get; set; }

        [Newtonsoft.Json.JsonProperty("deserializationFeatures", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? DeserializationFeatures { get; set; }

        [Newtonsoft.Json.JsonProperty("problemHandlers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LinkedNodeDeserializationProblemHandler ProblemHandlers { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ContextAttributes Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("rootName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RootName { get; set; }

        [Newtonsoft.Json.JsonProperty("fullRootName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PropertyName FullRootName { get; set; }

        [Newtonsoft.Json.JsonProperty("subtypeResolver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubtypeResolver SubtypeResolver { get; set; }

        [Newtonsoft.Json.JsonProperty("defaultVisibilityChecker", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public VisibilityCheckerObject DefaultVisibilityChecker { get; set; }

        [Newtonsoft.Json.JsonProperty("locale", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Locale Locale { get; set; }

        [Newtonsoft.Json.JsonProperty("timeZone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TimeZone TimeZone { get; set; }

        [Newtonsoft.Json.JsonProperty("typeFactory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TypeFactory TypeFactory { get; set; }

        [Newtonsoft.Json.JsonProperty("handlerInstantiator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HandlerInstantiator HandlerInstantiator { get; set; }

        [Newtonsoft.Json.JsonProperty("propertyNamingStrategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PropertyNamingStrategy PropertyNamingStrategy { get; set; }

        [Newtonsoft.Json.JsonProperty("dateFormat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DateFormat DateFormat { get; set; }

        [Newtonsoft.Json.JsonProperty("base64Variant", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Base64Variant Base64Variant { get; set; }

        [Newtonsoft.Json.JsonProperty("annotationProcessingEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AnnotationProcessingEnabled { get; set; }

        [Newtonsoft.Json.JsonProperty("classIntrospector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ClassIntrospector ClassIntrospector { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class DeserializationContext
    {
        [Newtonsoft.Json.JsonProperty("factory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DeserializerFactory Factory { get; set; }

        [Newtonsoft.Json.JsonProperty("locale", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Locale Locale { get; set; }

        [Newtonsoft.Json.JsonProperty("timeZone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TimeZone TimeZone { get; set; }

        [Newtonsoft.Json.JsonProperty("config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DeserializationConfig Config { get; set; }

        [Newtonsoft.Json.JsonProperty("parser", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JsonParser Parser { get; set; }

        [Newtonsoft.Json.JsonProperty("typeFactory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TypeFactory TypeFactory { get; set; }

        [Newtonsoft.Json.JsonProperty("annotationIntrospector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AnnotationIntrospector AnnotationIntrospector { get; set; }

        [Newtonsoft.Json.JsonProperty("nodeFactory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JsonNodeFactory NodeFactory { get; set; }

        [Newtonsoft.Json.JsonProperty("contextualType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JavaType ContextualType { get; set; }

        [Newtonsoft.Json.JsonProperty("deserializationFeatures", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? DeserializationFeatures { get; set; }

        [Newtonsoft.Json.JsonProperty("base64Variant", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Base64Variant Base64Variant { get; set; }

        [Newtonsoft.Json.JsonProperty("arrayBuilders", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ArrayBuilders ArrayBuilders { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class DeserializerFactory
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class DispatchRateImpl
    {
        [Newtonsoft.Json.JsonProperty("dispatchThrottlingRateInMsg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? DispatchThrottlingRateInMsg { get; set; }

        [Newtonsoft.Json.JsonProperty("dispatchThrottlingRateInByte", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? DispatchThrottlingRateInByte { get; set; }

        [Newtonsoft.Json.JsonProperty("relativeToPublishRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RelativeToPublishRate { get; set; }

        [Newtonsoft.Json.JsonProperty("ratePeriodInSecond", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? RatePeriodInSecond { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class DoubleBuilder
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class EntryFilters
    {
        [Newtonsoft.Json.JsonProperty("entryFilterNames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EntryFilterNames { get; set; }

    }

    /// <summary>
    /// The data of a failure domain configuration in a cluster
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class FailureDomain
    {
        /// <summary>
        /// The collection of brokers in the same failure domain
        /// </summary>
        [Newtonsoft.Json.JsonProperty("brokers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Brokers { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class FilterProvider
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class FloatBuilder
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class FormatSchema
    {
        [Newtonsoft.Json.JsonProperty("schemaType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SchemaType { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class FunctionInstanceStatsData
    {
        [Newtonsoft.Json.JsonProperty("oneMin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FunctionInstanceStatsDataBase OneMin { get; set; }

        [Newtonsoft.Json.JsonProperty("lastInvocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? LastInvocation { get; set; }

        [Newtonsoft.Json.JsonProperty("userMetrics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, double> UserMetrics { get; set; }

        [Newtonsoft.Json.JsonProperty("receivedTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ReceivedTotal { get; set; }

        [Newtonsoft.Json.JsonProperty("processedSuccessfullyTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ProcessedSuccessfullyTotal { get; set; }

        [Newtonsoft.Json.JsonProperty("systemExceptionsTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? SystemExceptionsTotal { get; set; }

        [Newtonsoft.Json.JsonProperty("userExceptionsTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? UserExceptionsTotal { get; set; }

        [Newtonsoft.Json.JsonProperty("avgProcessLatency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AvgProcessLatency { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class FunctionInstanceStatsDataBase
    {
        [Newtonsoft.Json.JsonProperty("receivedTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ReceivedTotal { get; set; }

        [Newtonsoft.Json.JsonProperty("processedSuccessfullyTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ProcessedSuccessfullyTotal { get; set; }

        [Newtonsoft.Json.JsonProperty("systemExceptionsTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? SystemExceptionsTotal { get; set; }

        [Newtonsoft.Json.JsonProperty("userExceptionsTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? UserExceptionsTotal { get; set; }

        [Newtonsoft.Json.JsonProperty("avgProcessLatency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AvgProcessLatency { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class Functions
    {
        [Newtonsoft.Json.JsonProperty("listOfConnectors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ConnectorDefinition> ListOfConnectors { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class FunctionsV2
    {
        [Newtonsoft.Json.JsonProperty("listOfConnectors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ConnectorDefinition> ListOfConnectors { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class FunctionsV2WorkerService
    {
        [Newtonsoft.Json.JsonProperty("listOfConnectors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ConnectorDefinition> ListOfConnectors { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class FunctionsWorkerService
    {
        [Newtonsoft.Json.JsonProperty("listOfConnectors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ConnectorDefinition> ListOfConnectors { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class GetAllVersionsSchemaResponse
    {
        [Newtonsoft.Json.JsonProperty("getSchemaResponses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<GetSchemaResponse> GetSchemaResponses { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class GetSchemaResponse
    {
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Version { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public GetSchemaResponseType? Type { get; set; }

        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Timestamp { get; set; }

        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Data { get; set; }

        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Properties { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class HandlerInstantiator
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class InactiveTopicPolicies
    {
        [Newtonsoft.Json.JsonProperty("inactiveTopicDeleteMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InactiveTopicPoliciesInactiveTopicDeleteMode? InactiveTopicDeleteMode { get; set; }

        [Newtonsoft.Json.JsonProperty("maxInactiveDurationSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxInactiveDurationSeconds { get; set; }

        [Newtonsoft.Json.JsonProperty("deleteWhileInactive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DeleteWhileInactive { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class InjectableValues
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class InputDecorator
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class IntBuilder
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class InternalConfigurationData
    {
        [Newtonsoft.Json.JsonProperty("zookeeperServers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ZookeeperServers { get; set; }

        [Newtonsoft.Json.JsonProperty("configurationStoreServers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigurationStoreServers { get; set; }

        [Newtonsoft.Json.JsonProperty("metadataStoreUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MetadataStoreUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("configurationMetadataStoreUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigurationMetadataStoreUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("ledgersRootPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LedgersRootPath { get; set; }

        [Newtonsoft.Json.JsonProperty("bookkeeperMetadataServiceUri", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BookkeeperMetadataServiceUri { get; set; }

        [Newtonsoft.Json.JsonProperty("stateStorageServiceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StateStorageServiceUrl { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class IsCompatibilityResponse
    {
        [Newtonsoft.Json.JsonProperty("schemaCompatibilityStrategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SchemaCompatibilityStrategy { get; set; }

        [Newtonsoft.Json.JsonProperty("compatibility", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Compatibility { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class JavaType
    {
        [Newtonsoft.Json.JsonProperty("interface", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Interface { get; set; }

        [Newtonsoft.Json.JsonProperty("primitive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Primitive { get; set; }

        [Newtonsoft.Json.JsonProperty("interfaces", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<JavaType> Interfaces { get; set; }

        [Newtonsoft.Json.JsonProperty("genericSignature", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GenericSignature { get; set; }

        [Newtonsoft.Json.JsonProperty("final", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Final { get; set; }

        [Newtonsoft.Json.JsonProperty("abstract", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Abstract { get; set; }

        [Newtonsoft.Json.JsonProperty("bindings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TypeBindings Bindings { get; set; }

        [Newtonsoft.Json.JsonProperty("concrete", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Concrete { get; set; }

        [Newtonsoft.Json.JsonProperty("keyType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JavaType KeyType { get; set; }

        [Newtonsoft.Json.JsonProperty("arrayType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ArrayType { get; set; }

        [Newtonsoft.Json.JsonProperty("throwable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Throwable { get; set; }

        [Newtonsoft.Json.JsonProperty("javaLangObject", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? JavaLangObject { get; set; }

        [Newtonsoft.Json.JsonProperty("enumType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EnumType { get; set; }

        [Newtonsoft.Json.JsonProperty("containerType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ContainerType { get; set; }

        [Newtonsoft.Json.JsonProperty("valueHandler", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object ValueHandler { get; set; }

        [Newtonsoft.Json.JsonProperty("typeHandler", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object TypeHandler { get; set; }

        [Newtonsoft.Json.JsonProperty("referencedType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JavaType ReferencedType { get; set; }

        [Newtonsoft.Json.JsonProperty("superClass", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JavaType SuperClass { get; set; }

        [Newtonsoft.Json.JsonProperty("contentValueHandler", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object ContentValueHandler { get; set; }

        [Newtonsoft.Json.JsonProperty("contentTypeHandler", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object ContentTypeHandler { get; set; }

        [Newtonsoft.Json.JsonProperty("erasedSignature", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErasedSignature { get; set; }

        [Newtonsoft.Json.JsonProperty("collectionLikeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CollectionLikeType { get; set; }

        [Newtonsoft.Json.JsonProperty("mapLikeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? MapLikeType { get; set; }

        [Newtonsoft.Json.JsonProperty("contentType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JavaType ContentType { get; set; }

        [Newtonsoft.Json.JsonProperty("typeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TypeName { get; set; }

        [Newtonsoft.Json.JsonProperty("referenceType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReferenceType { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class JsonFactory
    {
        [Newtonsoft.Json.JsonProperty("inputDecorator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public InputDecorator InputDecorator { get; set; }

        [Newtonsoft.Json.JsonProperty("characterEscapes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CharacterEscapes CharacterEscapes { get; set; }

        [Newtonsoft.Json.JsonProperty("outputDecorator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OutputDecorator OutputDecorator { get; set; }

        [Newtonsoft.Json.JsonProperty("rootValueSeparator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RootValueSeparator { get; set; }

        [Newtonsoft.Json.JsonProperty("codec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ObjectCodec Codec { get; set; }

        [Newtonsoft.Json.JsonProperty("formatName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FormatName { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class JsonGenerator
    {
        [Newtonsoft.Json.JsonProperty("schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FormatSchema Schema { get; set; }

        [Newtonsoft.Json.JsonProperty("characterEscapes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CharacterEscapes CharacterEscapes { get; set; }

        [Newtonsoft.Json.JsonProperty("codec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ObjectCodec Codec { get; set; }

        [Newtonsoft.Json.JsonProperty("prettyPrinter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PrettyPrinter PrettyPrinter { get; set; }

        [Newtonsoft.Json.JsonProperty("featureMask", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? FeatureMask { get; set; }

        [Newtonsoft.Json.JsonProperty("formatFeatures", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? FormatFeatures { get; set; }

        [Newtonsoft.Json.JsonProperty("currentValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object CurrentValue { get; set; }

        [Newtonsoft.Json.JsonProperty("highestEscapedChar", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? HighestEscapedChar { get; set; }

        [Newtonsoft.Json.JsonProperty("outputTarget", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object OutputTarget { get; set; }

        [Newtonsoft.Json.JsonProperty("outputBuffered", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? OutputBuffered { get; set; }

        [Newtonsoft.Json.JsonProperty("outputContext", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JsonStreamContext OutputContext { get; set; }

        [Newtonsoft.Json.JsonProperty("closed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Closed { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class JsonLocation
    {
        [Newtonsoft.Json.JsonProperty("byteOffset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ByteOffset { get; set; }

        [Newtonsoft.Json.JsonProperty("sourceRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object SourceRef { get; set; }

        [Newtonsoft.Json.JsonProperty("lineNr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? LineNr { get; set; }

        [Newtonsoft.Json.JsonProperty("columnNr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ColumnNr { get; set; }

        [Newtonsoft.Json.JsonProperty("charOffset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? CharOffset { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class JsonNodeFactory
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class JsonParser
    {
        [Newtonsoft.Json.JsonProperty("textLength", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? TextLength { get; set; }

        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Text { get; set; }

        [Newtonsoft.Json.JsonProperty("textCharacters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> TextCharacters { get; set; }

        [Newtonsoft.Json.JsonProperty("booleanValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? BooleanValue { get; set; }

        [Newtonsoft.Json.JsonProperty("byteValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] ByteValue { get; set; }

        [Newtonsoft.Json.JsonProperty("doubleValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? DoubleValue { get; set; }

        [Newtonsoft.Json.JsonProperty("floatValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public float? FloatValue { get; set; }

        [Newtonsoft.Json.JsonProperty("longValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? LongValue { get; set; }

        [Newtonsoft.Json.JsonProperty("shortValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ShortValue { get; set; }

        [Newtonsoft.Json.JsonProperty("objectId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object ObjectId { get; set; }

        [Newtonsoft.Json.JsonProperty("intValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? IntValue { get; set; }

        [Newtonsoft.Json.JsonProperty("typeId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object TypeId { get; set; }

        [Newtonsoft.Json.JsonProperty("schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FormatSchema Schema { get; set; }

        [Newtonsoft.Json.JsonProperty("codec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ObjectCodec Codec { get; set; }

        [Newtonsoft.Json.JsonProperty("currentToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public JsonParserCurrentToken? CurrentToken { get; set; }

        [Newtonsoft.Json.JsonProperty("currentName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CurrentName { get; set; }

        [Newtonsoft.Json.JsonProperty("tokenLocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JsonLocation TokenLocation { get; set; }

        [Newtonsoft.Json.JsonProperty("featureMask", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? FeatureMask { get; set; }

        [Newtonsoft.Json.JsonProperty("formatFeatures", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? FormatFeatures { get; set; }

        [Newtonsoft.Json.JsonProperty("currentTokenId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? CurrentTokenId { get; set; }

        [Newtonsoft.Json.JsonProperty("parsingContext", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JsonStreamContext ParsingContext { get; set; }

        [Newtonsoft.Json.JsonProperty("currentLocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JsonLocation CurrentLocation { get; set; }

        [Newtonsoft.Json.JsonProperty("expectedStartArrayToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExpectedStartArrayToken { get; set; }

        [Newtonsoft.Json.JsonProperty("expectedStartObjectToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExpectedStartObjectToken { get; set; }

        [Newtonsoft.Json.JsonProperty("lastClearedToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public JsonParserLastClearedToken? LastClearedToken { get; set; }

        [Newtonsoft.Json.JsonProperty("textOffset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? TextOffset { get; set; }

        [Newtonsoft.Json.JsonProperty("numberValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Number NumberValue { get; set; }

        [Newtonsoft.Json.JsonProperty("numberType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public JsonParserNumberType? NumberType { get; set; }

        [Newtonsoft.Json.JsonProperty("bigIntegerValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? BigIntegerValue { get; set; }

        [Newtonsoft.Json.JsonProperty("decimalValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? DecimalValue { get; set; }

        [Newtonsoft.Json.JsonProperty("embeddedObject", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object EmbeddedObject { get; set; }

        [Newtonsoft.Json.JsonProperty("binaryValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<byte[]> BinaryValue { get; set; }

        [Newtonsoft.Json.JsonProperty("valueAsInt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ValueAsInt { get; set; }

        [Newtonsoft.Json.JsonProperty("valueAsLong", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ValueAsLong { get; set; }

        [Newtonsoft.Json.JsonProperty("valueAsDouble", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ValueAsDouble { get; set; }

        [Newtonsoft.Json.JsonProperty("valueAsBoolean", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ValueAsBoolean { get; set; }

        [Newtonsoft.Json.JsonProperty("valueAsString", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ValueAsString { get; set; }

        [Newtonsoft.Json.JsonProperty("inputSource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object InputSource { get; set; }

        [Newtonsoft.Json.JsonProperty("currentValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object CurrentValue { get; set; }

        [Newtonsoft.Json.JsonProperty("closed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Closed { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class JsonSerializer
    {
        [Newtonsoft.Json.JsonProperty("unwrappingSerializer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UnwrappingSerializer { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class JsonSerializerObject
    {
        [Newtonsoft.Json.JsonProperty("delegatee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JsonSerializerObject Delegatee { get; set; }

        [Newtonsoft.Json.JsonProperty("unwrappingSerializer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UnwrappingSerializer { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class JsonStreamContext
    {
        [Newtonsoft.Json.JsonProperty("parent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JsonStreamContext Parent { get; set; }

        [Newtonsoft.Json.JsonProperty("currentName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CurrentName { get; set; }

        [Newtonsoft.Json.JsonProperty("currentValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object CurrentValue { get; set; }

        [Newtonsoft.Json.JsonProperty("entryCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? EntryCount { get; set; }

        [Newtonsoft.Json.JsonProperty("typeDesc", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TypeDesc { get; set; }

        [Newtonsoft.Json.JsonProperty("currentIndex", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? CurrentIndex { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class KubernetesContainerFactory
    {
        [Newtonsoft.Json.JsonProperty("k8Uri", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string K8Uri { get; set; }

        [Newtonsoft.Json.JsonProperty("jobNamespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobNamespace { get; set; }

        [Newtonsoft.Json.JsonProperty("jobName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobName { get; set; }

        [Newtonsoft.Json.JsonProperty("pulsarDockerImageName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PulsarDockerImageName { get; set; }

        [Newtonsoft.Json.JsonProperty("functionDockerImages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> FunctionDockerImages { get; set; }

        [Newtonsoft.Json.JsonProperty("imagePullPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ImagePullPolicy { get; set; }

        [Newtonsoft.Json.JsonProperty("pulsarRootDir", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PulsarRootDir { get; set; }

        [Newtonsoft.Json.JsonProperty("configAdminCLI", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigAdminCLI { get; set; }

        [Newtonsoft.Json.JsonProperty("submittingInsidePod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? SubmittingInsidePod { get; set; }

        [Newtonsoft.Json.JsonProperty("pulsarServiceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PulsarServiceUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("pulsarAdminUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PulsarAdminUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("installUserCodeDependencies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? InstallUserCodeDependencies { get; set; }

        [Newtonsoft.Json.JsonProperty("pythonDependencyRepository", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PythonDependencyRepository { get; set; }

        [Newtonsoft.Json.JsonProperty("pythonExtraDependencyRepository", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PythonExtraDependencyRepository { get; set; }

        [Newtonsoft.Json.JsonProperty("extraFunctionDependenciesDir", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExtraFunctionDependenciesDir { get; set; }

        [Newtonsoft.Json.JsonProperty("customLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> CustomLabels { get; set; }

        [Newtonsoft.Json.JsonProperty("expectedMetricsCollectionInterval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ExpectedMetricsCollectionInterval { get; set; }

        [Newtonsoft.Json.JsonProperty("changeConfigMap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ChangeConfigMap { get; set; }

        [Newtonsoft.Json.JsonProperty("changeConfigMapNamespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ChangeConfigMapNamespace { get; set; }

        [Newtonsoft.Json.JsonProperty("percentMemoryPadding", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? PercentMemoryPadding { get; set; }

        [Newtonsoft.Json.JsonProperty("cpuOverCommitRatio", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? CpuOverCommitRatio { get; set; }

        [Newtonsoft.Json.JsonProperty("memoryOverCommitRatio", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MemoryOverCommitRatio { get; set; }

        [Newtonsoft.Json.JsonProperty("grpcPort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? GrpcPort { get; set; }

        [Newtonsoft.Json.JsonProperty("metricsPort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MetricsPort { get; set; }

        [Newtonsoft.Json.JsonProperty("narExtractionDirectory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NarExtractionDirectory { get; set; }

        [Newtonsoft.Json.JsonProperty("functionInstanceClassPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FunctionInstanceClassPath { get; set; }

        [Newtonsoft.Json.JsonProperty("gracePeriodSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? GracePeriodSeconds { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class LinkedNode
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class LinkedNodeDeserializationProblemHandler
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class LoadReport
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("brokerVersionString", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BrokerVersionString { get; set; }

        [Newtonsoft.Json.JsonProperty("webServiceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WebServiceUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("webServiceUrlTls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WebServiceUrlTls { get; set; }

        [Newtonsoft.Json.JsonProperty("pulsarServiceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PulsarServiceUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("pulsarServiceUrlTls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PulsarServiceUrlTls { get; set; }

        [Newtonsoft.Json.JsonProperty("persistentTopicsEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? PersistentTopicsEnabled { get; set; }

        [Newtonsoft.Json.JsonProperty("nonPersistentTopicsEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? NonPersistentTopicsEnabled { get; set; }

        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Timestamp { get; set; }

        [Newtonsoft.Json.JsonProperty("msgRateIn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MsgRateIn { get; set; }

        [Newtonsoft.Json.JsonProperty("msgRateOut", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MsgRateOut { get; set; }

        [Newtonsoft.Json.JsonProperty("numTopics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumTopics { get; set; }

        [Newtonsoft.Json.JsonProperty("numConsumers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumConsumers { get; set; }

        [Newtonsoft.Json.JsonProperty("numProducers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumProducers { get; set; }

        [Newtonsoft.Json.JsonProperty("numBundles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumBundles { get; set; }

        [Newtonsoft.Json.JsonProperty("protocols", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Protocols { get; set; }

        [Newtonsoft.Json.JsonProperty("systemResourceUsage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SystemResourceUsage SystemResourceUsage { get; set; }

        [Newtonsoft.Json.JsonProperty("bundleStats", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, NamespaceBundleStats> BundleStats { get; set; }

        [Newtonsoft.Json.JsonProperty("bundleGains", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> BundleGains { get; set; }

        [Newtonsoft.Json.JsonProperty("bundleLosses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> BundleLosses { get; set; }

        [Newtonsoft.Json.JsonProperty("allocatedCPU", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AllocatedCPU { get; set; }

        [Newtonsoft.Json.JsonProperty("allocatedMemory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AllocatedMemory { get; set; }

        [Newtonsoft.Json.JsonProperty("allocatedBandwidthIn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AllocatedBandwidthIn { get; set; }

        [Newtonsoft.Json.JsonProperty("allocatedBandwidthOut", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AllocatedBandwidthOut { get; set; }

        [Newtonsoft.Json.JsonProperty("allocatedMsgRateIn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AllocatedMsgRateIn { get; set; }

        [Newtonsoft.Json.JsonProperty("allocatedMsgRateOut", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AllocatedMsgRateOut { get; set; }

        [Newtonsoft.Json.JsonProperty("preAllocatedCPU", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? PreAllocatedCPU { get; set; }

        [Newtonsoft.Json.JsonProperty("preAllocatedMemory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? PreAllocatedMemory { get; set; }

        [Newtonsoft.Json.JsonProperty("preAllocatedBandwidthIn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? PreAllocatedBandwidthIn { get; set; }

        [Newtonsoft.Json.JsonProperty("preAllocatedBandwidthOut", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? PreAllocatedBandwidthOut { get; set; }

        [Newtonsoft.Json.JsonProperty("preAllocatedMsgRateIn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? PreAllocatedMsgRateIn { get; set; }

        [Newtonsoft.Json.JsonProperty("preAllocatedMsgRateOut", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? PreAllocatedMsgRateOut { get; set; }

        [Newtonsoft.Json.JsonProperty("msgThroughputOut", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MsgThroughputOut { get; set; }

        [Newtonsoft.Json.JsonProperty("msgThroughputIn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MsgThroughputIn { get; set; }

        [Newtonsoft.Json.JsonProperty("cpu", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceUsage Cpu { get; set; }

        [Newtonsoft.Json.JsonProperty("directMemory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceUsage DirectMemory { get; set; }

        [Newtonsoft.Json.JsonProperty("lastUpdate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? LastUpdate { get; set; }

        [Newtonsoft.Json.JsonProperty("bandwidthIn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceUsage BandwidthIn { get; set; }

        [Newtonsoft.Json.JsonProperty("bandwidthOut", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceUsage BandwidthOut { get; set; }

        [Newtonsoft.Json.JsonProperty("memory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceUsage Memory { get; set; }

        [Newtonsoft.Json.JsonProperty("underLoaded", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UnderLoaded { get; set; }

        [Newtonsoft.Json.JsonProperty("overLoaded", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? OverLoaded { get; set; }

        [Newtonsoft.Json.JsonProperty("loadReportType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LoadReportType { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class Locale
    {
        [Newtonsoft.Json.JsonProperty("language", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Language { get; set; }

        [Newtonsoft.Json.JsonProperty("script", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Script { get; set; }

        [Newtonsoft.Json.JsonProperty("variant", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Variant { get; set; }

        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayName { get; set; }

        [Newtonsoft.Json.JsonProperty("country", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Country { get; set; }

        [Newtonsoft.Json.JsonProperty("unicodeLocaleAttributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> UnicodeLocaleAttributes { get; set; }

        [Newtonsoft.Json.JsonProperty("unicodeLocaleKeys", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> UnicodeLocaleKeys { get; set; }

        [Newtonsoft.Json.JsonProperty("displayLanguage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayLanguage { get; set; }

        [Newtonsoft.Json.JsonProperty("displayScript", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayScript { get; set; }

        [Newtonsoft.Json.JsonProperty("displayCountry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayCountry { get; set; }

        [Newtonsoft.Json.JsonProperty("displayVariant", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayVariant { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionKeys", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> ExtensionKeys { get; set; }

        [Newtonsoft.Json.JsonProperty("iso3Language", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Iso3Language { get; set; }

        [Newtonsoft.Json.JsonProperty("iso3Country", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Iso3Country { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class LongBuilder
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class LongRunningProcessStatus
    {
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LongRunningProcessStatusStatus? Status { get; set; }

        [Newtonsoft.Json.JsonProperty("lastError", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LastError { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class LongSchemaVersion
    {
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Version { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class MemoryLimit
    {
        [Newtonsoft.Json.JsonProperty("absoluteValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? AbsoluteValue { get; set; }

        [Newtonsoft.Json.JsonProperty("percentOfMaxDirectMemory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? PercentOfMaxDirectMemory { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class Metrics
    {
        [Newtonsoft.Json.JsonProperty("metrics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, object> Metrics1 { get; set; }

        [Newtonsoft.Json.JsonProperty("dimensions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Dimensions { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class Module
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("classLoader", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ClassLoader ClassLoader { get; set; }

        [Newtonsoft.Json.JsonProperty("descriptor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ModuleDescriptor Descriptor { get; set; }

        [Newtonsoft.Json.JsonProperty("named", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Named { get; set; }

        [Newtonsoft.Json.JsonProperty("annotations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Annotation> Annotations { get; set; }

        [Newtonsoft.Json.JsonProperty("declaredAnnotations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Annotation> DeclaredAnnotations { get; set; }

        [Newtonsoft.Json.JsonProperty("packages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Packages { get; set; }

        [Newtonsoft.Json.JsonProperty("layer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ModuleLayer Layer { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ModuleDescriptor
    {
        [Newtonsoft.Json.JsonProperty("open", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Open { get; set; }

        [Newtonsoft.Json.JsonProperty("automatic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Automatic { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ModuleLayer
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class NamespaceBundleStats
    {
        [Newtonsoft.Json.JsonProperty("msgRateIn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MsgRateIn { get; set; }

        [Newtonsoft.Json.JsonProperty("msgThroughputIn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MsgThroughputIn { get; set; }

        [Newtonsoft.Json.JsonProperty("msgRateOut", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MsgRateOut { get; set; }

        [Newtonsoft.Json.JsonProperty("msgThroughputOut", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MsgThroughputOut { get; set; }

        [Newtonsoft.Json.JsonProperty("consumerCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ConsumerCount { get; set; }

        [Newtonsoft.Json.JsonProperty("producerCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ProducerCount { get; set; }

        [Newtonsoft.Json.JsonProperty("topics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Topics { get; set; }

        [Newtonsoft.Json.JsonProperty("cacheSize", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? CacheSize { get; set; }

    }

    /// <summary>
    /// The data of namespace isolation configuration
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class NamespaceIsolationData
    {
        /// <summary>
        /// The list of namespaces to apply this namespace isolation data
        /// </summary>
        [Newtonsoft.Json.JsonProperty("namespaces", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Namespaces { get; set; }

        /// <summary>
        /// The list of primary brokers for serving the list of namespaces in this isolation policy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("primary", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Primary { get; set; }

        /// <summary>
        /// The list of secondary brokers for serving the list of namespaces in this isolation policy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secondary", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Secondary { get; set; }

        /// <summary>
        /// The data of auto-failover policy configuration
        /// </summary>
        [Newtonsoft.Json.JsonProperty("auto_failover_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AutoFailoverPolicyData Auto_failover_policy { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class NamespaceOwnershipStatus
    {
        [Newtonsoft.Json.JsonProperty("broker_assignment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public NamespaceOwnershipStatusBroker_assignment? Broker_assignment { get; set; }

        [Newtonsoft.Json.JsonProperty("is_controlled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_controlled { get; set; }

        [Newtonsoft.Json.JsonProperty("is_active", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_active { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class Number
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class NumberFormat
    {
        [Newtonsoft.Json.JsonProperty("groupingUsed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? GroupingUsed { get; set; }

        [Newtonsoft.Json.JsonProperty("parseIntegerOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ParseIntegerOnly { get; set; }

        [Newtonsoft.Json.JsonProperty("maximumIntegerDigits", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaximumIntegerDigits { get; set; }

        [Newtonsoft.Json.JsonProperty("minimumIntegerDigits", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MinimumIntegerDigits { get; set; }

        [Newtonsoft.Json.JsonProperty("maximumFractionDigits", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaximumFractionDigits { get; set; }

        [Newtonsoft.Json.JsonProperty("minimumFractionDigits", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MinimumFractionDigits { get; set; }

        [Newtonsoft.Json.JsonProperty("roundingMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public NumberFormatRoundingMode? RoundingMode { get; set; }

        [Newtonsoft.Json.JsonProperty("currency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Currency Currency { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ObjectCodec
    {
        [Newtonsoft.Json.JsonProperty("factory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JsonFactory Factory { get; set; }

        [Newtonsoft.Json.JsonProperty("jsonFactory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JsonFactory JsonFactory { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ObjectMapper
    {
        [Newtonsoft.Json.JsonProperty("factory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JsonFactory Factory { get; set; }

        [Newtonsoft.Json.JsonProperty("typeFactory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TypeFactory TypeFactory { get; set; }

        [Newtonsoft.Json.JsonProperty("serializationConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SerializationConfig SerializationConfig { get; set; }

        [Newtonsoft.Json.JsonProperty("deserializationConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DeserializationConfig DeserializationConfig { get; set; }

        [Newtonsoft.Json.JsonProperty("deserializationContext", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DeserializationContext DeserializationContext { get; set; }

        [Newtonsoft.Json.JsonProperty("serializerFactory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SerializerFactory SerializerFactory { get; set; }

        [Newtonsoft.Json.JsonProperty("serializerProvider", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SerializerProvider SerializerProvider { get; set; }

        [Newtonsoft.Json.JsonProperty("serializerProviderInstance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SerializerProvider SerializerProviderInstance { get; set; }

        [Newtonsoft.Json.JsonProperty("visibilityChecker", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public VisibilityCheckerObject VisibilityChecker { get; set; }

        [Newtonsoft.Json.JsonProperty("subtypeResolver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubtypeResolver SubtypeResolver { get; set; }

        [Newtonsoft.Json.JsonProperty("propertyNamingStrategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PropertyNamingStrategy PropertyNamingStrategy { get; set; }

        [Newtonsoft.Json.JsonProperty("nodeFactory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JsonNodeFactory NodeFactory { get; set; }

        [Newtonsoft.Json.JsonProperty("jsonFactory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JsonFactory JsonFactory { get; set; }

        [Newtonsoft.Json.JsonProperty("dateFormat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DateFormat DateFormat { get; set; }

        [Newtonsoft.Json.JsonProperty("injectableValues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public InjectableValues InjectableValues { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class OffloadPolicies
    {
        [Newtonsoft.Json.JsonProperty("offloadersDirectory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OffloadersDirectory { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadMaxThreads", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ManagedLedgerOffloadMaxThreads { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadDriver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ManagedLedgerOffloadDriver { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadDeletionLagInMillis", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ManagedLedgerOffloadDeletionLagInMillis { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadThresholdInBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ManagedLedgerOffloadThresholdInBytes { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadPrefetchRounds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ManagedLedgerOffloadPrefetchRounds { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadedReadPriority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OffloadPoliciesManagedLedgerOffloadedReadPriority? ManagedLedgerOffloadedReadPriority { get; set; }

        [Newtonsoft.Json.JsonProperty("s3ManagedLedgerOffloadRegion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string S3ManagedLedgerOffloadRegion { get; set; }

        [Newtonsoft.Json.JsonProperty("s3ManagedLedgerOffloadBucket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string S3ManagedLedgerOffloadBucket { get; set; }

        [Newtonsoft.Json.JsonProperty("s3ManagedLedgerOffloadServiceEndpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string S3ManagedLedgerOffloadServiceEndpoint { get; set; }

        [Newtonsoft.Json.JsonProperty("s3ManagedLedgerOffloadMaxBlockSizeInBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? S3ManagedLedgerOffloadMaxBlockSizeInBytes { get; set; }

        [Newtonsoft.Json.JsonProperty("s3ManagedLedgerOffloadReadBufferSizeInBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? S3ManagedLedgerOffloadReadBufferSizeInBytes { get; set; }

        [Newtonsoft.Json.JsonProperty("s3ManagedLedgerOffloadCredentialId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string S3ManagedLedgerOffloadCredentialId { get; set; }

        [Newtonsoft.Json.JsonProperty("s3ManagedLedgerOffloadCredentialSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string S3ManagedLedgerOffloadCredentialSecret { get; set; }

        [Newtonsoft.Json.JsonProperty("s3ManagedLedgerOffloadRole", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string S3ManagedLedgerOffloadRole { get; set; }

        [Newtonsoft.Json.JsonProperty("s3ManagedLedgerOffloadRoleSessionName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string S3ManagedLedgerOffloadRoleSessionName { get; set; }

        [Newtonsoft.Json.JsonProperty("gcsManagedLedgerOffloadRegion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GcsManagedLedgerOffloadRegion { get; set; }

        [Newtonsoft.Json.JsonProperty("gcsManagedLedgerOffloadBucket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GcsManagedLedgerOffloadBucket { get; set; }

        [Newtonsoft.Json.JsonProperty("gcsManagedLedgerOffloadMaxBlockSizeInBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? GcsManagedLedgerOffloadMaxBlockSizeInBytes { get; set; }

        [Newtonsoft.Json.JsonProperty("gcsManagedLedgerOffloadReadBufferSizeInBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? GcsManagedLedgerOffloadReadBufferSizeInBytes { get; set; }

        [Newtonsoft.Json.JsonProperty("gcsManagedLedgerOffloadServiceAccountKeyFile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GcsManagedLedgerOffloadServiceAccountKeyFile { get; set; }

        [Newtonsoft.Json.JsonProperty("fileSystemProfilePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FileSystemProfilePath { get; set; }

        [Newtonsoft.Json.JsonProperty("fileSystemURI", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FileSystemURI { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadBucket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ManagedLedgerOffloadBucket { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadRegion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ManagedLedgerOffloadRegion { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadServiceEndpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ManagedLedgerOffloadServiceEndpoint { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadMaxBlockSizeInBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ManagedLedgerOffloadMaxBlockSizeInBytes { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadReadBufferSizeInBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ManagedLedgerOffloadReadBufferSizeInBytes { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class OffloadPoliciesImpl
    {
        [Newtonsoft.Json.JsonProperty("offloadersDirectory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OffloadersDirectory { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadDriver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ManagedLedgerOffloadDriver { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadMaxThreads", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ManagedLedgerOffloadMaxThreads { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadPrefetchRounds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ManagedLedgerOffloadPrefetchRounds { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadThresholdInBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ManagedLedgerOffloadThresholdInBytes { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadDeletionLagInMillis", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ManagedLedgerOffloadDeletionLagInMillis { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadedReadPriority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OffloadPoliciesImplManagedLedgerOffloadedReadPriority? ManagedLedgerOffloadedReadPriority { get; set; }

        [Newtonsoft.Json.JsonProperty("s3ManagedLedgerOffloadRegion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string S3ManagedLedgerOffloadRegion { get; set; }

        [Newtonsoft.Json.JsonProperty("s3ManagedLedgerOffloadBucket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string S3ManagedLedgerOffloadBucket { get; set; }

        [Newtonsoft.Json.JsonProperty("s3ManagedLedgerOffloadServiceEndpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string S3ManagedLedgerOffloadServiceEndpoint { get; set; }

        [Newtonsoft.Json.JsonProperty("s3ManagedLedgerOffloadMaxBlockSizeInBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? S3ManagedLedgerOffloadMaxBlockSizeInBytes { get; set; }

        [Newtonsoft.Json.JsonProperty("s3ManagedLedgerOffloadReadBufferSizeInBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? S3ManagedLedgerOffloadReadBufferSizeInBytes { get; set; }

        [Newtonsoft.Json.JsonProperty("s3ManagedLedgerOffloadCredentialId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string S3ManagedLedgerOffloadCredentialId { get; set; }

        [Newtonsoft.Json.JsonProperty("s3ManagedLedgerOffloadCredentialSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string S3ManagedLedgerOffloadCredentialSecret { get; set; }

        [Newtonsoft.Json.JsonProperty("s3ManagedLedgerOffloadRole", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string S3ManagedLedgerOffloadRole { get; set; }

        [Newtonsoft.Json.JsonProperty("s3ManagedLedgerOffloadRoleSessionName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string S3ManagedLedgerOffloadRoleSessionName { get; set; }

        [Newtonsoft.Json.JsonProperty("gcsManagedLedgerOffloadRegion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GcsManagedLedgerOffloadRegion { get; set; }

        [Newtonsoft.Json.JsonProperty("gcsManagedLedgerOffloadBucket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GcsManagedLedgerOffloadBucket { get; set; }

        [Newtonsoft.Json.JsonProperty("gcsManagedLedgerOffloadMaxBlockSizeInBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? GcsManagedLedgerOffloadMaxBlockSizeInBytes { get; set; }

        [Newtonsoft.Json.JsonProperty("gcsManagedLedgerOffloadReadBufferSizeInBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? GcsManagedLedgerOffloadReadBufferSizeInBytes { get; set; }

        [Newtonsoft.Json.JsonProperty("gcsManagedLedgerOffloadServiceAccountKeyFile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GcsManagedLedgerOffloadServiceAccountKeyFile { get; set; }

        [Newtonsoft.Json.JsonProperty("fileSystemProfilePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FileSystemProfilePath { get; set; }

        [Newtonsoft.Json.JsonProperty("fileSystemURI", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FileSystemURI { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadBucket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ManagedLedgerOffloadBucket { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadRegion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ManagedLedgerOffloadRegion { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadServiceEndpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ManagedLedgerOffloadServiceEndpoint { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadMaxBlockSizeInBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ManagedLedgerOffloadMaxBlockSizeInBytes { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerOffloadReadBufferSizeInBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ManagedLedgerOffloadReadBufferSizeInBytes { get; set; }

        [Newtonsoft.Json.JsonProperty("s3Driver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? S3Driver { get; set; }

        [Newtonsoft.Json.JsonProperty("gcsDriver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? GcsDriver { get; set; }

        [Newtonsoft.Json.JsonProperty("fileSystemDriver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? FileSystemDriver { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class OutputDecorator
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class OutputStream
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class Package
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("annotations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Annotation> Annotations { get; set; }

        [Newtonsoft.Json.JsonProperty("declaredAnnotations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Annotation> DeclaredAnnotations { get; set; }

        [Newtonsoft.Json.JsonProperty("sealed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Sealed { get; set; }

        [Newtonsoft.Json.JsonProperty("specificationTitle", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SpecificationTitle { get; set; }

        [Newtonsoft.Json.JsonProperty("specificationVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SpecificationVersion { get; set; }

        [Newtonsoft.Json.JsonProperty("specificationVendor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SpecificationVendor { get; set; }

        [Newtonsoft.Json.JsonProperty("implementationTitle", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ImplementationTitle { get; set; }

        [Newtonsoft.Json.JsonProperty("implementationVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ImplementationVersion { get; set; }

        [Newtonsoft.Json.JsonProperty("implementationVendor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ImplementationVendor { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class PartitionedTopicMetadata
    {
        [Newtonsoft.Json.JsonProperty("partitions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Partitions { get; set; }

        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Properties { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class PendingBookieOpsStats
    {
        [Newtonsoft.Json.JsonProperty("dataLedgerOpenOp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? DataLedgerOpenOp { get; set; }

        [Newtonsoft.Json.JsonProperty("dataLedgerCloseOp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? DataLedgerCloseOp { get; set; }

        [Newtonsoft.Json.JsonProperty("dataLedgerCreateOp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? DataLedgerCreateOp { get; set; }

        [Newtonsoft.Json.JsonProperty("dataLedgerDeleteOp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? DataLedgerDeleteOp { get; set; }

        [Newtonsoft.Json.JsonProperty("cursorLedgerOpenOp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? CursorLedgerOpenOp { get; set; }

        [Newtonsoft.Json.JsonProperty("cursorLedgerCloseOp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? CursorLedgerCloseOp { get; set; }

        [Newtonsoft.Json.JsonProperty("cursorLedgerCreateOp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? CursorLedgerCreateOp { get; set; }

        [Newtonsoft.Json.JsonProperty("cursorLedgerDeleteOp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? CursorLedgerDeleteOp { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class PersistencePolicies
    {
        [Newtonsoft.Json.JsonProperty("bookkeeperEnsemble", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? BookkeeperEnsemble { get; set; }

        [Newtonsoft.Json.JsonProperty("bookkeeperWriteQuorum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? BookkeeperWriteQuorum { get; set; }

        [Newtonsoft.Json.JsonProperty("bookkeeperAckQuorum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? BookkeeperAckQuorum { get; set; }

        [Newtonsoft.Json.JsonProperty("managedLedgerMaxMarkDeleteRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ManagedLedgerMaxMarkDeleteRate { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class Policies
    {
        [Newtonsoft.Json.JsonProperty("auth_policies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AuthPolicies Auth_policies { get; set; }

        [Newtonsoft.Json.JsonProperty("replication_clusters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Replication_clusters { get; set; }

        [Newtonsoft.Json.JsonProperty("bundles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public BundlesData Bundles { get; set; }

        [Newtonsoft.Json.JsonProperty("backlog_quota_map", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, BacklogQuota> Backlog_quota_map { get; set; }

        [Newtonsoft.Json.JsonProperty("clusterDispatchRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, DispatchRateImpl> ClusterDispatchRate { get; set; }

        [Newtonsoft.Json.JsonProperty("topicDispatchRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, DispatchRateImpl> TopicDispatchRate { get; set; }

        [Newtonsoft.Json.JsonProperty("subscriptionDispatchRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, DispatchRateImpl> SubscriptionDispatchRate { get; set; }

        [Newtonsoft.Json.JsonProperty("replicatorDispatchRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, DispatchRateImpl> ReplicatorDispatchRate { get; set; }

        [Newtonsoft.Json.JsonProperty("clusterSubscribeRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, SubscribeRate> ClusterSubscribeRate { get; set; }

        [Newtonsoft.Json.JsonProperty("persistence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PersistencePolicies Persistence { get; set; }

        [Newtonsoft.Json.JsonProperty("deduplicationEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DeduplicationEnabled { get; set; }

        [Newtonsoft.Json.JsonProperty("autoTopicCreationOverride", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AutoTopicCreationOverride AutoTopicCreationOverride { get; set; }

        [Newtonsoft.Json.JsonProperty("autoSubscriptionCreationOverride", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AutoSubscriptionCreationOverride AutoSubscriptionCreationOverride { get; set; }

        [Newtonsoft.Json.JsonProperty("publishMaxMessageRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, PublishRate> PublishMaxMessageRate { get; set; }

        [Newtonsoft.Json.JsonProperty("latency_stats_sample_rate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, int> Latency_stats_sample_rate { get; set; }

        [Newtonsoft.Json.JsonProperty("message_ttl_in_seconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Message_ttl_in_seconds { get; set; }

        [Newtonsoft.Json.JsonProperty("subscription_expiration_time_minutes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Subscription_expiration_time_minutes { get; set; }

        [Newtonsoft.Json.JsonProperty("retention_policies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RetentionPolicies Retention_policies { get; set; }

        [Newtonsoft.Json.JsonProperty("deleted", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Deleted { get; set; }

        [Newtonsoft.Json.JsonProperty("encryption_required", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Encryption_required { get; set; }

        [Newtonsoft.Json.JsonProperty("delayed_delivery_policies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DelayedDeliveryPolicies Delayed_delivery_policies { get; set; }

        [Newtonsoft.Json.JsonProperty("inactive_topic_policies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public InactiveTopicPolicies Inactive_topic_policies { get; set; }

        [Newtonsoft.Json.JsonProperty("subscription_auth_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PoliciesSubscription_auth_mode? Subscription_auth_mode { get; set; }

        [Newtonsoft.Json.JsonProperty("max_producers_per_topic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Max_producers_per_topic { get; set; }

        [Newtonsoft.Json.JsonProperty("max_consumers_per_topic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Max_consumers_per_topic { get; set; }

        [Newtonsoft.Json.JsonProperty("max_consumers_per_subscription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Max_consumers_per_subscription { get; set; }

        [Newtonsoft.Json.JsonProperty("max_unacked_messages_per_consumer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Max_unacked_messages_per_consumer { get; set; }

        [Newtonsoft.Json.JsonProperty("max_unacked_messages_per_subscription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Max_unacked_messages_per_subscription { get; set; }

        [Newtonsoft.Json.JsonProperty("max_subscriptions_per_topic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Max_subscriptions_per_topic { get; set; }

        [Newtonsoft.Json.JsonProperty("compaction_threshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Compaction_threshold { get; set; }

        [Newtonsoft.Json.JsonProperty("offload_threshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Offload_threshold { get; set; }

        [Newtonsoft.Json.JsonProperty("offload_deletion_lag_ms", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Offload_deletion_lag_ms { get; set; }

        [Newtonsoft.Json.JsonProperty("max_topics_per_namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Max_topics_per_namespace { get; set; }

        [Newtonsoft.Json.JsonProperty("schema_auto_update_compatibility_strategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PoliciesSchema_auto_update_compatibility_strategy? Schema_auto_update_compatibility_strategy { get; set; }

        [Newtonsoft.Json.JsonProperty("schema_compatibility_strategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PoliciesSchema_compatibility_strategy? Schema_compatibility_strategy { get; set; }

        [Newtonsoft.Json.JsonProperty("is_allow_auto_update_schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_allow_auto_update_schema { get; set; }

        [Newtonsoft.Json.JsonProperty("schema_validation_enforced", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Schema_validation_enforced { get; set; }

        [Newtonsoft.Json.JsonProperty("offload_policies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OffloadPolicies Offload_policies { get; set; }

        [Newtonsoft.Json.JsonProperty("deduplicationSnapshotIntervalSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? DeduplicationSnapshotIntervalSeconds { get; set; }

        [Newtonsoft.Json.JsonProperty("subscription_types_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Subscription_types_enabled { get; set; }

        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Properties { get; set; }

        [Newtonsoft.Json.JsonProperty("resource_group_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Resource_group_name { get; set; }

        [Newtonsoft.Json.JsonProperty("entryFilters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EntryFilters EntryFilters { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class PoolArenaStats
    {
        [Newtonsoft.Json.JsonProperty("numSmallSubpages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumSmallSubpages { get; set; }

        [Newtonsoft.Json.JsonProperty("numChunkLists", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumChunkLists { get; set; }

        [Newtonsoft.Json.JsonProperty("smallSubpages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PoolSubpageStats> SmallSubpages { get; set; }

        [Newtonsoft.Json.JsonProperty("chunkLists", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PoolChunkListStats> ChunkLists { get; set; }

        [Newtonsoft.Json.JsonProperty("numAllocations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NumAllocations { get; set; }

        [Newtonsoft.Json.JsonProperty("numSmallAllocations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NumSmallAllocations { get; set; }

        [Newtonsoft.Json.JsonProperty("numNormalAllocations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NumNormalAllocations { get; set; }

        [Newtonsoft.Json.JsonProperty("numHugeAllocations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NumHugeAllocations { get; set; }

        [Newtonsoft.Json.JsonProperty("numDeallocations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NumDeallocations { get; set; }

        [Newtonsoft.Json.JsonProperty("numSmallDeallocations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NumSmallDeallocations { get; set; }

        [Newtonsoft.Json.JsonProperty("numNormalDeallocations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NumNormalDeallocations { get; set; }

        [Newtonsoft.Json.JsonProperty("numHugeDeallocations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NumHugeDeallocations { get; set; }

        [Newtonsoft.Json.JsonProperty("numActiveAllocations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NumActiveAllocations { get; set; }

        [Newtonsoft.Json.JsonProperty("numActiveSmallAllocations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NumActiveSmallAllocations { get; set; }

        [Newtonsoft.Json.JsonProperty("numActiveNormalAllocations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NumActiveNormalAllocations { get; set; }

        [Newtonsoft.Json.JsonProperty("numActiveHugeAllocations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NumActiveHugeAllocations { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class PoolChunkListStats
    {
        [Newtonsoft.Json.JsonProperty("minUsage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MinUsage { get; set; }

        [Newtonsoft.Json.JsonProperty("maxUsage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxUsage { get; set; }

        [Newtonsoft.Json.JsonProperty("chunks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PoolChunkStats> Chunks { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class PoolChunkStats
    {
        [Newtonsoft.Json.JsonProperty("usage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Usage { get; set; }

        [Newtonsoft.Json.JsonProperty("chunkSize", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ChunkSize { get; set; }

        [Newtonsoft.Json.JsonProperty("freeBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? FreeBytes { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class PoolSubpageStats
    {
        [Newtonsoft.Json.JsonProperty("maxNumElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxNumElements { get; set; }

        [Newtonsoft.Json.JsonProperty("numAvailable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumAvailable { get; set; }

        [Newtonsoft.Json.JsonProperty("elementSize", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ElementSize { get; set; }

        [Newtonsoft.Json.JsonProperty("pageSize", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? PageSize { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class PostSchemaPayload
    {
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        [Newtonsoft.Json.JsonProperty("schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Schema { get; set; }

        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Properties { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class PostSchemaResponse
    {
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SchemaVersion Version { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class PrettyPrinter
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ProcessContainerFactory
    {
        [Newtonsoft.Json.JsonProperty("javaInstanceJarLocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JavaInstanceJarLocation { get; set; }

        [Newtonsoft.Json.JsonProperty("pythonInstanceLocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PythonInstanceLocation { get; set; }

        [Newtonsoft.Json.JsonProperty("logDirectory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LogDirectory { get; set; }

        [Newtonsoft.Json.JsonProperty("extraFunctionDependenciesDir", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExtraFunctionDependenciesDir { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class PropertyName
    {
        [Newtonsoft.Json.JsonProperty("empty", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Empty { get; set; }

        [Newtonsoft.Json.JsonProperty("simpleName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SimpleName { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class PropertyNamingStrategy
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class PublicKey
    {
        [Newtonsoft.Json.JsonProperty("encoded", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<byte[]> Encoded { get; set; }

        [Newtonsoft.Json.JsonProperty("format", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Format { get; set; }

        [Newtonsoft.Json.JsonProperty("algorithm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Algorithm { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class PublishRate
    {
        [Newtonsoft.Json.JsonProperty("publishThrottlingRateInMsg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? PublishThrottlingRateInMsg { get; set; }

        [Newtonsoft.Json.JsonProperty("publishThrottlingRateInByte", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? PublishThrottlingRateInByte { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class RawBookieInfo
    {
        [Newtonsoft.Json.JsonProperty("bookieId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BookieId { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ResetCursorData
    {
        [Newtonsoft.Json.JsonProperty("ledgerId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? LedgerId { get; set; }

        [Newtonsoft.Json.JsonProperty("entryId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? EntryId { get; set; }

        [Newtonsoft.Json.JsonProperty("partitionIndex", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? PartitionIndex { get; set; }

        [Newtonsoft.Json.JsonProperty("batchIndex", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? BatchIndex { get; set; }

        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Properties { get; set; }

        [Newtonsoft.Json.JsonProperty("excluded", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Excluded { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ResourceDescription
    {
        [Newtonsoft.Json.JsonProperty("usagePct", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? UsagePct { get; set; }

        [Newtonsoft.Json.JsonProperty("resourceUsage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, ResourceUsage> ResourceUsage { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ResourceGroup
    {
        [Newtonsoft.Json.JsonProperty("publishRateInMsgs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? PublishRateInMsgs { get; set; }

        [Newtonsoft.Json.JsonProperty("publishRateInBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? PublishRateInBytes { get; set; }

        [Newtonsoft.Json.JsonProperty("dispatchRateInMsgs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? DispatchRateInMsgs { get; set; }

        [Newtonsoft.Json.JsonProperty("dispatchRateInBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? DispatchRateInBytes { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ResourceQuota
    {
        [Newtonsoft.Json.JsonProperty("msgRateIn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MsgRateIn { get; set; }

        [Newtonsoft.Json.JsonProperty("msgRateOut", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MsgRateOut { get; set; }

        [Newtonsoft.Json.JsonProperty("bandwidthIn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? BandwidthIn { get; set; }

        [Newtonsoft.Json.JsonProperty("bandwidthOut", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? BandwidthOut { get; set; }

        [Newtonsoft.Json.JsonProperty("memory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Memory { get; set; }

        [Newtonsoft.Json.JsonProperty("dynamic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Dynamic { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ResourceUnit
    {
        [Newtonsoft.Json.JsonProperty("resourceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceId { get; set; }

        [Newtonsoft.Json.JsonProperty("availableResource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceDescription AvailableResource { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ResourceUsage
    {
        [Newtonsoft.Json.JsonProperty("usage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Usage { get; set; }

        [Newtonsoft.Json.JsonProperty("limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Limit { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class Resources
    {
        [Newtonsoft.Json.JsonProperty("cpu", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Cpu { get; set; }

        [Newtonsoft.Json.JsonProperty("ram", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Ram { get; set; }

        [Newtonsoft.Json.JsonProperty("disk", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Disk { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class RetentionPolicies
    {
        [Newtonsoft.Json.JsonProperty("retentionTimeInMinutes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? RetentionTimeInMinutes { get; set; }

        [Newtonsoft.Json.JsonProperty("retentionSizeInMB", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? RetentionSizeInMB { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class SchemaVersion
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class SerializationConfig
    {
        [Newtonsoft.Json.JsonProperty("annotationIntrospector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AnnotationIntrospector AnnotationIntrospector { get; set; }

        [Newtonsoft.Json.JsonProperty("defaultPropertyInclusion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Value DefaultPropertyInclusion { get; set; }

        [Newtonsoft.Json.JsonProperty("filterProvider", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FilterProvider FilterProvider { get; set; }

        [Newtonsoft.Json.JsonProperty("defaultPrettyPrinter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PrettyPrinter DefaultPrettyPrinter { get; set; }

        [Newtonsoft.Json.JsonProperty("serializationInclusion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SerializationConfigSerializationInclusion? SerializationInclusion { get; set; }

        [Newtonsoft.Json.JsonProperty("serializationFeatures", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SerializationFeatures { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ContextAttributes Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("rootName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RootName { get; set; }

        [Newtonsoft.Json.JsonProperty("fullRootName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PropertyName FullRootName { get; set; }

        [Newtonsoft.Json.JsonProperty("subtypeResolver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubtypeResolver SubtypeResolver { get; set; }

        [Newtonsoft.Json.JsonProperty("defaultVisibilityChecker", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public VisibilityCheckerObject DefaultVisibilityChecker { get; set; }

        [Newtonsoft.Json.JsonProperty("locale", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Locale Locale { get; set; }

        [Newtonsoft.Json.JsonProperty("timeZone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TimeZone TimeZone { get; set; }

        [Newtonsoft.Json.JsonProperty("typeFactory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TypeFactory TypeFactory { get; set; }

        [Newtonsoft.Json.JsonProperty("handlerInstantiator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HandlerInstantiator HandlerInstantiator { get; set; }

        [Newtonsoft.Json.JsonProperty("propertyNamingStrategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PropertyNamingStrategy PropertyNamingStrategy { get; set; }

        [Newtonsoft.Json.JsonProperty("dateFormat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DateFormat DateFormat { get; set; }

        [Newtonsoft.Json.JsonProperty("base64Variant", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Base64Variant Base64Variant { get; set; }

        [Newtonsoft.Json.JsonProperty("annotationProcessingEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AnnotationProcessingEnabled { get; set; }

        [Newtonsoft.Json.JsonProperty("classIntrospector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ClassIntrospector ClassIntrospector { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class SerializerFactory
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class SerializerProvider
    {
        [Newtonsoft.Json.JsonProperty("locale", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Locale Locale { get; set; }

        [Newtonsoft.Json.JsonProperty("timeZone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TimeZone TimeZone { get; set; }

        [Newtonsoft.Json.JsonProperty("config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SerializationConfig Config { get; set; }

        [Newtonsoft.Json.JsonProperty("typeFactory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TypeFactory TypeFactory { get; set; }

        [Newtonsoft.Json.JsonProperty("annotationIntrospector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AnnotationIntrospector AnnotationIntrospector { get; set; }

        [Newtonsoft.Json.JsonProperty("defaultNullValueSerializer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JsonSerializerObject DefaultNullValueSerializer { get; set; }

        [Newtonsoft.Json.JsonProperty("filterProvider", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FilterProvider FilterProvider { get; set; }

        [Newtonsoft.Json.JsonProperty("defaultNullKeySerializer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JsonSerializerObject DefaultNullKeySerializer { get; set; }

        [Newtonsoft.Json.JsonProperty("generator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JsonGenerator Generator { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ShortBuilder
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class Sinks
    {
        [Newtonsoft.Json.JsonProperty("sinkList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ConnectorDefinition> SinkList { get; set; }

        [Newtonsoft.Json.JsonProperty("listOfConnectors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ConnectorDefinition> ListOfConnectors { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class SinksWorkerService
    {
        [Newtonsoft.Json.JsonProperty("sinkList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ConnectorDefinition> SinkList { get; set; }

        [Newtonsoft.Json.JsonProperty("listOfConnectors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ConnectorDefinition> ListOfConnectors { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class SocketAddress
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class Sources
    {
        [Newtonsoft.Json.JsonProperty("sourceList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ConnectorDefinition> SourceList { get; set; }

        [Newtonsoft.Json.JsonProperty("listOfConnectors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ConnectorDefinition> ListOfConnectors { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class SourcesWorkerService
    {
        [Newtonsoft.Json.JsonProperty("sourceList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ConnectorDefinition> SourceList { get; set; }

        [Newtonsoft.Json.JsonProperty("listOfConnectors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ConnectorDefinition> ListOfConnectors { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class SubscribeRate
    {
        [Newtonsoft.Json.JsonProperty("subscribeThrottlingRatePerConsumer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SubscribeThrottlingRatePerConsumer { get; set; }

        [Newtonsoft.Json.JsonProperty("ratePeriodInSecond", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? RatePeriodInSecond { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class SubtypeResolver
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class SystemResourceUsage
    {
        [Newtonsoft.Json.JsonProperty("bandwidthIn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceUsage BandwidthIn { get; set; }

        [Newtonsoft.Json.JsonProperty("bandwidthOut", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceUsage BandwidthOut { get; set; }

        [Newtonsoft.Json.JsonProperty("cpu", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceUsage Cpu { get; set; }

        [Newtonsoft.Json.JsonProperty("memory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceUsage Memory { get; set; }

        [Newtonsoft.Json.JsonProperty("directMemory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceUsage DirectMemory { get; set; }

    }

    /// <summary>
    /// Information of adminRoles and allowedClusters for tenant
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class TenantInfo
    {
        /// <summary>
        /// Comma separated list of auth principal allowed to administrate the tenant.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("adminRoles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AdminRoles { get; set; }

        /// <summary>
        /// Comma separated allowed clusters.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allowedClusters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AllowedClusters { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ThreadContainerFactory
    {
        [Newtonsoft.Json.JsonProperty("threadGroupName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ThreadGroupName { get; set; }

        [Newtonsoft.Json.JsonProperty("pulsarClientMemoryLimit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public MemoryLimit PulsarClientMemoryLimit { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class TimeZone
    {
        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayName { get; set; }

        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("dstsavings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Dstsavings { get; set; }

        [Newtonsoft.Json.JsonProperty("rawOffset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? RawOffset { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class TypeBindings
    {
        [Newtonsoft.Json.JsonProperty("empty", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Empty { get; set; }

        [Newtonsoft.Json.JsonProperty("typeParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<JavaType> TypeParameters { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class TypeFactory
    {
        [Newtonsoft.Json.JsonProperty("classLoader", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ClassLoader ClassLoader { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class Value
    {
        [Newtonsoft.Json.JsonProperty("contentInclusion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ValueContentInclusion? ContentInclusion { get; set; }

        [Newtonsoft.Json.JsonProperty("valueInclusion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ValueInclusion? ValueInclusion { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class VisibilityChecker
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class VisibilityCheckerObject
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class WorkerConfig
    {
        [Newtonsoft.Json.JsonProperty("workerId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkerId { get; set; }

        [Newtonsoft.Json.JsonProperty("workerHostname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkerHostname { get; set; }

        [Newtonsoft.Json.JsonProperty("workerPort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? WorkerPort { get; set; }

        [Newtonsoft.Json.JsonProperty("workerPortTls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? WorkerPortTls { get; set; }

        [Newtonsoft.Json.JsonProperty("authenticateMetricsEndpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AuthenticateMetricsEndpoint { get; set; }

        [Newtonsoft.Json.JsonProperty("includeStandardPrometheusMetrics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeStandardPrometheusMetrics { get; set; }

        [Newtonsoft.Json.JsonProperty("jvmGCMetricsLoggerClassName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JvmGCMetricsLoggerClassName { get; set; }

        [Newtonsoft.Json.JsonProperty("numHttpServerThreads", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumHttpServerThreads { get; set; }

        [Newtonsoft.Json.JsonProperty("httpRequestsLimitEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? HttpRequestsLimitEnabled { get; set; }

        [Newtonsoft.Json.JsonProperty("httpRequestsMaxPerSecond", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? HttpRequestsMaxPerSecond { get; set; }

        [Newtonsoft.Json.JsonProperty("maxConcurrentHttpRequests", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxConcurrentHttpRequests { get; set; }

        [Newtonsoft.Json.JsonProperty("httpServerThreadPoolQueueSize", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? HttpServerThreadPoolQueueSize { get; set; }

        [Newtonsoft.Json.JsonProperty("httpServerAcceptQueueSize", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? HttpServerAcceptQueueSize { get; set; }

        [Newtonsoft.Json.JsonProperty("maxHttpServerConnections", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxHttpServerConnections { get; set; }

        [Newtonsoft.Json.JsonProperty("configurationStoreServers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigurationStoreServers { get; set; }

        [Newtonsoft.Json.JsonProperty("configurationMetadataStoreUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigurationMetadataStoreUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("metadataStoreSessionTimeoutMillis", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? MetadataStoreSessionTimeoutMillis { get; set; }

        [Newtonsoft.Json.JsonProperty("metadataStoreOperationTimeoutSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MetadataStoreOperationTimeoutSeconds { get; set; }

        [Newtonsoft.Json.JsonProperty("metadataStoreCacheExpirySeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MetadataStoreCacheExpirySeconds { get; set; }

        [Newtonsoft.Json.JsonProperty("zooKeeperSessionTimeoutMillis", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ZooKeeperSessionTimeoutMillis { get; set; }

        [Newtonsoft.Json.JsonProperty("zooKeeperOperationTimeoutSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ZooKeeperOperationTimeoutSeconds { get; set; }

        [Newtonsoft.Json.JsonProperty("zooKeeperCacheExpirySeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ZooKeeperCacheExpirySeconds { get; set; }

        [Newtonsoft.Json.JsonProperty("connectorsDirectory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConnectorsDirectory { get; set; }

        [Newtonsoft.Json.JsonProperty("narExtractionDirectory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NarExtractionDirectory { get; set; }

        [Newtonsoft.Json.JsonProperty("validateConnectorConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ValidateConnectorConfig { get; set; }

        [Newtonsoft.Json.JsonProperty("uploadBuiltinSinksSources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UploadBuiltinSinksSources { get; set; }

        [Newtonsoft.Json.JsonProperty("functionsDirectory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FunctionsDirectory { get; set; }

        [Newtonsoft.Json.JsonProperty("functionMetadataTopicName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FunctionMetadataTopicName { get; set; }

        [Newtonsoft.Json.JsonProperty("useCompactedMetadataTopic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UseCompactedMetadataTopic { get; set; }

        [Newtonsoft.Json.JsonProperty("functionWebServiceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FunctionWebServiceUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("pulsarServiceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PulsarServiceUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("pulsarWebServiceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PulsarWebServiceUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("clusterCoordinationTopicName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClusterCoordinationTopicName { get; set; }

        [Newtonsoft.Json.JsonProperty("pulsarFunctionsNamespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PulsarFunctionsNamespace { get; set; }

        [Newtonsoft.Json.JsonProperty("pulsarFunctionsCluster", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PulsarFunctionsCluster { get; set; }

        [Newtonsoft.Json.JsonProperty("numFunctionPackageReplicas", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumFunctionPackageReplicas { get; set; }

        [Newtonsoft.Json.JsonProperty("functionsWorkerEnablePackageManagement", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? FunctionsWorkerEnablePackageManagement { get; set; }

        [Newtonsoft.Json.JsonProperty("downloadDirectory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DownloadDirectory { get; set; }

        [Newtonsoft.Json.JsonProperty("stateStorageServiceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StateStorageServiceUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("stateStorageProviderImplementation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StateStorageProviderImplementation { get; set; }

        [Newtonsoft.Json.JsonProperty("functionAssignmentTopicName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FunctionAssignmentTopicName { get; set; }

        [Newtonsoft.Json.JsonProperty("schedulerClassName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SchedulerClassName { get; set; }

        [Newtonsoft.Json.JsonProperty("failureCheckFreqMs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? FailureCheckFreqMs { get; set; }

        [Newtonsoft.Json.JsonProperty("rescheduleTimeoutMs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? RescheduleTimeoutMs { get; set; }

        [Newtonsoft.Json.JsonProperty("rebalanceCheckFreqSec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? RebalanceCheckFreqSec { get; set; }

        [Newtonsoft.Json.JsonProperty("workerListProbeIntervalSec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? WorkerListProbeIntervalSec { get; set; }

        [Newtonsoft.Json.JsonProperty("initialBrokerReconnectMaxRetries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? InitialBrokerReconnectMaxRetries { get; set; }

        [Newtonsoft.Json.JsonProperty("assignmentWriteMaxRetries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? AssignmentWriteMaxRetries { get; set; }

        [Newtonsoft.Json.JsonProperty("instanceLivenessCheckFreqMs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? InstanceLivenessCheckFreqMs { get; set; }

        [Newtonsoft.Json.JsonProperty("brokerClientAuthenticationEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? BrokerClientAuthenticationEnabled { get; set; }

        [Newtonsoft.Json.JsonProperty("brokerClientAuthenticationPlugin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BrokerClientAuthenticationPlugin { get; set; }

        [Newtonsoft.Json.JsonProperty("brokerClientAuthenticationParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BrokerClientAuthenticationParameters { get; set; }

        [Newtonsoft.Json.JsonProperty("bookkeeperClientAuthenticationPlugin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BookkeeperClientAuthenticationPlugin { get; set; }

        [Newtonsoft.Json.JsonProperty("bookkeeperClientAuthenticationParametersName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BookkeeperClientAuthenticationParametersName { get; set; }

        [Newtonsoft.Json.JsonProperty("bookkeeperClientAuthenticationParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BookkeeperClientAuthenticationParameters { get; set; }

        [Newtonsoft.Json.JsonProperty("topicCompactionFrequencySec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? TopicCompactionFrequencySec { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? TlsEnabled { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsCertificateFilePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TlsCertificateFilePath { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsKeyFilePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TlsKeyFilePath { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsTrustCertsFilePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TlsTrustCertsFilePath { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsAllowInsecureConnection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? TlsAllowInsecureConnection { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsRequireTrustedClientCertOnConnect", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? TlsRequireTrustedClientCertOnConnect { get; set; }

        [Newtonsoft.Json.JsonProperty("useTls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UseTls { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsEnableHostnameVerification", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? TlsEnableHostnameVerification { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsCertRefreshCheckDurationSec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? TlsCertRefreshCheckDurationSec { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsEnabledWithKeyStore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? TlsEnabledWithKeyStore { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsProvider", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TlsProvider { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsKeyStoreType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TlsKeyStoreType { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsKeyStore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TlsKeyStore { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsKeyStorePassword", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TlsKeyStorePassword { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsTrustStoreType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TlsTrustStoreType { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsTrustStore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TlsTrustStore { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsTrustStorePassword", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TlsTrustStorePassword { get; set; }

        [Newtonsoft.Json.JsonProperty("webServiceTlsProtocols", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> WebServiceTlsProtocols { get; set; }

        [Newtonsoft.Json.JsonProperty("webServiceTlsCiphers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> WebServiceTlsCiphers { get; set; }

        [Newtonsoft.Json.JsonProperty("authenticationEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AuthenticationEnabled { get; set; }

        [Newtonsoft.Json.JsonProperty("authenticationProviders", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AuthenticationProviders { get; set; }

        [Newtonsoft.Json.JsonProperty("authorizationEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AuthorizationEnabled { get; set; }

        [Newtonsoft.Json.JsonProperty("authorizationProvider", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AuthorizationProvider { get; set; }

        [Newtonsoft.Json.JsonProperty("superUserRoles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> SuperUserRoles { get; set; }

        [Newtonsoft.Json.JsonProperty("saslJaasClientAllowedIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SaslJaasClientAllowedIds { get; set; }

        [Newtonsoft.Json.JsonProperty("saslJaasServerSectionName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SaslJaasServerSectionName { get; set; }

        [Newtonsoft.Json.JsonProperty("saslJaasServerRoleTokenSignerSecretPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SaslJaasServerRoleTokenSignerSecretPath { get; set; }

        [Newtonsoft.Json.JsonProperty("kinitCommand", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KinitCommand { get; set; }

        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Properties { get; set; }

        [Newtonsoft.Json.JsonProperty("initializedDlogMetadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? InitializedDlogMetadata { get; set; }

        [Newtonsoft.Json.JsonProperty("brokerClientTrustCertsFilePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BrokerClientTrustCertsFilePath { get; set; }

        [Newtonsoft.Json.JsonProperty("functionRuntimeFactoryClassName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FunctionRuntimeFactoryClassName { get; set; }

        [Newtonsoft.Json.JsonProperty("functionRuntimeFactoryConfigs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, object> FunctionRuntimeFactoryConfigs { get; set; }

        [Newtonsoft.Json.JsonProperty("secretsProviderConfiguratorClassName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SecretsProviderConfiguratorClassName { get; set; }

        [Newtonsoft.Json.JsonProperty("secretsProviderConfiguratorConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> SecretsProviderConfiguratorConfig { get; set; }

        [Newtonsoft.Json.JsonProperty("functionInstanceMinResources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Resources FunctionInstanceMinResources { get; set; }

        [Newtonsoft.Json.JsonProperty("functionInstanceMaxResources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Resources FunctionInstanceMaxResources { get; set; }

        [Newtonsoft.Json.JsonProperty("functionInstanceResourceGranularities", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Resources FunctionInstanceResourceGranularities { get; set; }

        [Newtonsoft.Json.JsonProperty("functionInstanceResourceChangeInLockStep", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? FunctionInstanceResourceChangeInLockStep { get; set; }

        [Newtonsoft.Json.JsonProperty("functionAuthProviderClassName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FunctionAuthProviderClassName { get; set; }

        [Newtonsoft.Json.JsonProperty("runtimeCustomizerClassName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RuntimeCustomizerClassName { get; set; }

        [Newtonsoft.Json.JsonProperty("runtimeCustomizerConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, object> RuntimeCustomizerConfig { get; set; }

        [Newtonsoft.Json.JsonProperty("maxPendingAsyncRequests", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxPendingAsyncRequests { get; set; }

        [Newtonsoft.Json.JsonProperty("forwardSourceMessageProperty", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ForwardSourceMessageProperty { get; set; }

        [Newtonsoft.Json.JsonProperty("additionalJavaRuntimeArguments", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AdditionalJavaRuntimeArguments { get; set; }

        [Newtonsoft.Json.JsonProperty("functionsWorkerServiceNarPackage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FunctionsWorkerServiceNarPackage { get; set; }

        [Newtonsoft.Json.JsonProperty("functionsWorkerServiceCustomConfigs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, object> FunctionsWorkerServiceCustomConfigs { get; set; }

        [Newtonsoft.Json.JsonProperty("exposeAdminClientEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExposeAdminClientEnabled { get; set; }

        [Newtonsoft.Json.JsonProperty("threadContainerFactory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ThreadContainerFactory ThreadContainerFactory { get; set; }

        [Newtonsoft.Json.JsonProperty("processContainerFactory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProcessContainerFactory ProcessContainerFactory { get; set; }

        [Newtonsoft.Json.JsonProperty("kubernetesContainerFactory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KubernetesContainerFactory KubernetesContainerFactory { get; set; }

        [Newtonsoft.Json.JsonProperty("clientAuthenticationParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClientAuthenticationParameters { get; set; }

        [Newtonsoft.Json.JsonProperty("clientAuthenticationPlugin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClientAuthenticationPlugin { get; set; }

        [Newtonsoft.Json.JsonProperty("functionMetadataTopic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FunctionMetadataTopic { get; set; }

        [Newtonsoft.Json.JsonProperty("clusterCoordinationTopic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClusterCoordinationTopic { get; set; }

        [Newtonsoft.Json.JsonProperty("functionAssignmentTopic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FunctionAssignmentTopic { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsTrustChainBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<byte[]> TlsTrustChainBytes { get; set; }

        [Newtonsoft.Json.JsonProperty("workerWebAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkerWebAddress { get; set; }

        [Newtonsoft.Json.JsonProperty("workerWebAddressTls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkerWebAddressTls { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class WorkerFunctionInstanceStats
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("metrics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FunctionInstanceStatsData Metrics { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class WorkerInfo
    {
        [Newtonsoft.Json.JsonProperty("workerId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkerId { get; set; }

        [Newtonsoft.Json.JsonProperty("workerHostname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkerHostname { get; set; }

        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Port { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class WorkerService
    {
        [Newtonsoft.Json.JsonProperty("sources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SourcesWorkerService Sources { get; set; }

        [Newtonsoft.Json.JsonProperty("initialized", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Initialized { get; set; }

        [Newtonsoft.Json.JsonProperty("workerConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WorkerConfig WorkerConfig { get; set; }

        [Newtonsoft.Json.JsonProperty("functionsV2", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FunctionsV2WorkerService FunctionsV2 { get; set; }

        [Newtonsoft.Json.JsonProperty("workers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WorkersWorkerService Workers { get; set; }

        [Newtonsoft.Json.JsonProperty("functions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FunctionsWorkerService Functions { get; set; }

        [Newtonsoft.Json.JsonProperty("sinks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SinksWorkerService Sinks { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class Workers
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class WorkersWorkerService
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum TopicVersion
    {

        [System.Runtime.Serialization.EnumMember(Value = @"V1")]
        V1 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"V2")]
        V2 = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum BacklogQuotaType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"destination_storage")]
        Destination_storage = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"message_age")]
        Message_age = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum BacklogQuotaType2
    {

        [System.Runtime.Serialization.EnumMember(Value = @"destination_storage")]
        Destination_storage = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"message_age")]
        Message_age = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum Anonymous
    {

        [System.Runtime.Serialization.EnumMember(Value = @"produce")]
        Produce = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"consume")]
        Consume = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"functions")]
        Functions = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"sources")]
        Sources = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"sinks")]
        Sinks = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"packages")]
        Packages = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum Anonymous2
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Exclusive")]
        Exclusive = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Shared")]
        Shared = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Failover")]
        Failover = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Key_Shared")]
        Key_Shared = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum Mode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"PERSISTENT")]
        PERSISTENT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_PERSISTENT")]
        NON_PERSISTENT = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"ALL")]
        ALL = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum BacklogQuotaType3
    {

        [System.Runtime.Serialization.EnumMember(Value = @"destination_storage")]
        Destination_storage = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"message_age")]
        Message_age = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum BacklogQuotaType4
    {

        [System.Runtime.Serialization.EnumMember(Value = @"destination_storage")]
        Destination_storage = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"message_age")]
        Message_age = 1,

    }

    /// <summary>
    /// Relative start position to examine message.It can be 'latest' or 'earliest'
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum InitialPosition
    {

        [System.Runtime.Serialization.EnumMember(Value = @"latest")]
        Latest = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"earliest")]
        Earliest = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum Anonymous3
    {

        [System.Runtime.Serialization.EnumMember(Value = @"produce")]
        Produce = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"consume")]
        Consume = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"functions")]
        Functions = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"sources")]
        Sources = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"sinks")]
        Sinks = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"packages")]
        Packages = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum BacklogQuotaType5
    {

        [System.Runtime.Serialization.EnumMember(Value = @"destination_storage")]
        Destination_storage = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"message_age")]
        Message_age = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum Anonymous4
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Exclusive")]
        Exclusive = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Shared")]
        Shared = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Failover")]
        Failover = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Key_Shared")]
        Key_Shared = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum BacklogQuotaType6
    {

        [System.Runtime.Serialization.EnumMember(Value = @"destination_storage")]
        Destination_storage = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"message_age")]
        Message_age = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum BacklogQuotaType7
    {

        [System.Runtime.Serialization.EnumMember(Value = @"destination_storage")]
        Destination_storage = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"message_age")]
        Message_age = 1,

    }

    /// <summary>
    /// Relative start position to examine message.It can be 'latest' or 'earliest'
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum InitialPosition2
    {

        [System.Runtime.Serialization.EnumMember(Value = @"latest")]
        Latest = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"earliest")]
        Earliest = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum Anonymous5
    {

        [System.Runtime.Serialization.EnumMember(Value = @"produce")]
        Produce = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"consume")]
        Consume = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"functions")]
        Functions = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"sources")]
        Sources = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"sinks")]
        Sinks = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"packages")]
        Packages = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum BacklogQuotaType8
    {

        [System.Runtime.Serialization.EnumMember(Value = @"destination_storage")]
        Destination_storage = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"message_age")]
        Message_age = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum Anonymous6
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Exclusive")]
        Exclusive = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Shared")]
        Shared = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Failover")]
        Failover = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Key_Shared")]
        Key_Shared = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum Response
    {

        [System.Runtime.Serialization.EnumMember(Value = @"AutoUpdateDisabled")]
        AutoUpdateDisabled = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Backward")]
        Backward = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Forward")]
        Forward = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Full")]
        Full = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"AlwaysCompatible")]
        AlwaysCompatible = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"BackwardTransitive")]
        BackwardTransitive = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"ForwardTransitive")]
        ForwardTransitive = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"FullTransitive")]
        FullTransitive = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum Anonymous7
    {

        [System.Runtime.Serialization.EnumMember(Value = @"produce")]
        Produce = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"consume")]
        Consume = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"functions")]
        Functions = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"sources")]
        Sources = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"sinks")]
        Sinks = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"packages")]
        Packages = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum Anonymous8
    {

        [System.Runtime.Serialization.EnumMember(Value = @"produce")]
        Produce = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"consume")]
        Consume = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"functions")]
        Functions = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"sources")]
        Sources = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"sinks")]
        Sinks = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"packages")]
        Packages = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum AutoFailoverPolicyDataPolicyType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"min_available")]
        Min_available = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum BacklogQuotaPolicy
    {

        [System.Runtime.Serialization.EnumMember(Value = @"producer_request_hold")]
        Producer_request_hold = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"producer_exception")]
        Producer_exception = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"consumer_backlog_eviction")]
        Consumer_backlog_eviction = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum ClusterDataProxyProtocol
    {

        [System.Runtime.Serialization.EnumMember(Value = @"SNI")]
        SNI = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum GetSchemaResponseType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"NONE")]
        NONE = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"STRING")]
        STRING = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"JSON")]
        JSON = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"PROTOBUF")]
        PROTOBUF = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"AVRO")]
        AVRO = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"BOOLEAN")]
        BOOLEAN = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"INT8")]
        INT8 = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"INT16")]
        INT16 = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"INT32")]
        INT32 = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"INT64")]
        INT64 = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"FLOAT")]
        FLOAT = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"DOUBLE")]
        DOUBLE = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"DATE")]
        DATE = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"TIME")]
        TIME = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"TIMESTAMP")]
        TIMESTAMP = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"KEY_VALUE")]
        KEY_VALUE = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"INSTANT")]
        INSTANT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"LOCAL_DATE")]
        LOCAL_DATE = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"LOCAL_TIME")]
        LOCAL_TIME = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"LOCAL_DATE_TIME")]
        LOCAL_DATE_TIME = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"PROTOBUF_NATIVE")]
        PROTOBUF_NATIVE = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"BYTES")]
        BYTES = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"AUTO")]
        AUTO = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"AUTO_CONSUME")]
        AUTO_CONSUME = 23,

        [System.Runtime.Serialization.EnumMember(Value = @"AUTO_PUBLISH")]
        AUTO_PUBLISH = 24,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum InactiveTopicPoliciesInactiveTopicDeleteMode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"delete_when_no_subscriptions")]
        Delete_when_no_subscriptions = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"delete_when_subscriptions_caught_up")]
        Delete_when_subscriptions_caught_up = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum JsonParserCurrentToken
    {

        [System.Runtime.Serialization.EnumMember(Value = @"NOT_AVAILABLE")]
        NOT_AVAILABLE = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"START_OBJECT")]
        START_OBJECT = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"END_OBJECT")]
        END_OBJECT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"START_ARRAY")]
        START_ARRAY = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"END_ARRAY")]
        END_ARRAY = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"FIELD_NAME")]
        FIELD_NAME = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"VALUE_EMBEDDED_OBJECT")]
        VALUE_EMBEDDED_OBJECT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"VALUE_STRING")]
        VALUE_STRING = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"VALUE_NUMBER_INT")]
        VALUE_NUMBER_INT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"VALUE_NUMBER_FLOAT")]
        VALUE_NUMBER_FLOAT = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"VALUE_TRUE")]
        VALUE_TRUE = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"VALUE_FALSE")]
        VALUE_FALSE = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"VALUE_NULL")]
        VALUE_NULL = 12,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum JsonParserLastClearedToken
    {

        [System.Runtime.Serialization.EnumMember(Value = @"NOT_AVAILABLE")]
        NOT_AVAILABLE = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"START_OBJECT")]
        START_OBJECT = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"END_OBJECT")]
        END_OBJECT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"START_ARRAY")]
        START_ARRAY = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"END_ARRAY")]
        END_ARRAY = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"FIELD_NAME")]
        FIELD_NAME = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"VALUE_EMBEDDED_OBJECT")]
        VALUE_EMBEDDED_OBJECT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"VALUE_STRING")]
        VALUE_STRING = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"VALUE_NUMBER_INT")]
        VALUE_NUMBER_INT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"VALUE_NUMBER_FLOAT")]
        VALUE_NUMBER_FLOAT = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"VALUE_TRUE")]
        VALUE_TRUE = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"VALUE_FALSE")]
        VALUE_FALSE = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"VALUE_NULL")]
        VALUE_NULL = 12,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum JsonParserNumberType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"INT")]
        INT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"LONG")]
        LONG = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"BIG_INTEGER")]
        BIG_INTEGER = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"FLOAT")]
        FLOAT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"DOUBLE")]
        DOUBLE = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"BIG_DECIMAL")]
        BIG_DECIMAL = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum LongRunningProcessStatusStatus
    {

        [System.Runtime.Serialization.EnumMember(Value = @"NOT_RUN")]
        NOT_RUN = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"RUNNING")]
        RUNNING = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESS")]
        SUCCESS = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum NamespaceOwnershipStatusBroker_assignment
    {

        [System.Runtime.Serialization.EnumMember(Value = @"primary")]
        Primary = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"secondary")]
        Secondary = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"shared")]
        Shared = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum NumberFormatRoundingMode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CEILING")]
        CEILING = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"FLOOR")]
        FLOOR = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"HALF_UP")]
        HALF_UP = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"HALF_DOWN")]
        HALF_DOWN = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"HALF_EVEN")]
        HALF_EVEN = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"UNNECESSARY")]
        UNNECESSARY = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum OffloadPoliciesManagedLedgerOffloadedReadPriority
    {

        [System.Runtime.Serialization.EnumMember(Value = @"BOOKKEEPER_FIRST")]
        BOOKKEEPER_FIRST = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"TIERED_STORAGE_FIRST")]
        TIERED_STORAGE_FIRST = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum OffloadPoliciesImplManagedLedgerOffloadedReadPriority
    {

        [System.Runtime.Serialization.EnumMember(Value = @"BOOKKEEPER_FIRST")]
        BOOKKEEPER_FIRST = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"TIERED_STORAGE_FIRST")]
        TIERED_STORAGE_FIRST = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum PoliciesSubscription_auth_mode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Prefix")]
        Prefix = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum PoliciesSchema_auto_update_compatibility_strategy
    {

        [System.Runtime.Serialization.EnumMember(Value = @"AutoUpdateDisabled")]
        AutoUpdateDisabled = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Backward")]
        Backward = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Forward")]
        Forward = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Full")]
        Full = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"AlwaysCompatible")]
        AlwaysCompatible = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"BackwardTransitive")]
        BackwardTransitive = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"ForwardTransitive")]
        ForwardTransitive = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"FullTransitive")]
        FullTransitive = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum PoliciesSchema_compatibility_strategy
    {

        [System.Runtime.Serialization.EnumMember(Value = @"UNDEFINED")]
        UNDEFINED = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"ALWAYS_INCOMPATIBLE")]
        ALWAYS_INCOMPATIBLE = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"ALWAYS_COMPATIBLE")]
        ALWAYS_COMPATIBLE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"BACKWARD")]
        BACKWARD = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"FORWARD")]
        FORWARD = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"FULL")]
        FULL = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"BACKWARD_TRANSITIVE")]
        BACKWARD_TRANSITIVE = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"FORWARD_TRANSITIVE")]
        FORWARD_TRANSITIVE = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"FULL_TRANSITIVE")]
        FULL_TRANSITIVE = 8,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum SerializationConfigSerializationInclusion
    {

        [System.Runtime.Serialization.EnumMember(Value = @"ALWAYS")]
        ALWAYS = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_NULL")]
        NON_NULL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_ABSENT")]
        NON_ABSENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_EMPTY")]
        NON_EMPTY = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_DEFAULT")]
        NON_DEFAULT = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"USE_DEFAULTS")]
        USE_DEFAULTS = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum ValueContentInclusion
    {

        [System.Runtime.Serialization.EnumMember(Value = @"ALWAYS")]
        ALWAYS = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_NULL")]
        NON_NULL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_ABSENT")]
        NON_ABSENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_EMPTY")]
        NON_EMPTY = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_DEFAULT")]
        NON_DEFAULT = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"USE_DEFAULTS")]
        USE_DEFAULTS = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public enum ValueInclusion
    {

        [System.Runtime.Serialization.EnumMember(Value = @"ALWAYS")]
        ALWAYS = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_NULL")]
        NON_NULL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_ABSENT")]
        NON_ABSENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_EMPTY")]
        NON_EMPTY = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_DEFAULT")]
        NON_DEFAULT = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"USE_DEFAULTS")]
        USE_DEFAULTS = 5,

    }



    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.1.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108
#pragma warning restore 3016
#pragma warning restore 8603