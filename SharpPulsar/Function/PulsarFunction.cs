//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.8.0 (NJsonSchema v10.3.11.0 (Newtonsoft.Json v12.0.0.2)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"

namespace SharpPulsar.Function
{
    using System.Threading;
    using System.Threading.Tasks;
    using System = global::System;
    
    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.10.8.0 (NJsonSchema v10.3.11.0 (Newtonsoft.Json v12.0.0.2))")]
    public partial interface IPulsarFunctionsRESTAPIClient
    {
        /// <summary>Fetches a list of supported Pulsar IO connectors currently running in cluster mode</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<object>> GetConnectorsListAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Fetches a list of supported Pulsar IO connectors currently running in cluster mode</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<object>> GetConnectorsListAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Lists all Pulsar Functions currently deployed in a given namespace</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> ListFunctionsAsync(string tenant, string @namespace);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Lists all Pulsar Functions currently deployed in a given namespace</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> ListFunctionsAsync(string tenant, string @namespace, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Fetches information about a Pulsar Function currently running in cluster mode</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FunctionConfig> GetFunctionInfoAsync(string tenant, string @namespace, string functionName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Fetches information about a Pulsar Function currently running in cluster mode</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FunctionConfig> GetFunctionInfoAsync(string tenant, string @namespace, string functionName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Creates a new Pulsar Function in cluster mode</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="body">A JSON value presenting configuration payload of a Pulsar Function. An example of the expected Pulsar Function can be found here.  
        /// - **autoAck**  
        ///   Whether or not the framework acknowledges messages automatically.  
        /// - **runtime**  
        ///   What is the runtime of the Pulsar Function. Possible Values: [JAVA, PYTHON, GO]  
        /// - **resources**  
        ///   The size of the system resources allowed by the Pulsar Function runtime. The resources include: cpu, ram, disk.  
        /// - **className**  
        ///   The class name of a Pulsar Function.  
        /// - **customSchemaInputs**  
        ///   The map of input topics to Schema class names (specified as a JSON object).  
        /// - **customSerdeInputs**  
        ///   The map of input topics to SerDe class names (specified as a JSON object).  
        /// - **deadLetterTopic**  
        ///   Messages that are not processed successfully are sent to `deadLetterTopic`.  
        /// - **runtimeFlags**  
        ///   Any flags that you want to pass to the runtime. Note that in thread mode, these flags have no impact.  
        /// - **fqfn**  
        ///   The Fully Qualified Function Name (FQFN) for the Pulsar Function.  
        /// - **inputSpecs**  
        ///    The map of input topics to its consumer configuration, each configuration has schema of    {"schemaType": "type-x", "serdeClassName": "name-x", "isRegexPattern": true, "receiverQueueSize": 5}  
        /// - **inputs**  
        ///   The input topic or topics (multiple topics can be specified as a comma-separated list) of a Pulsar Function.  
        /// - **jar**  
        ///   Path to the JAR file for the Pulsar Function (if the Pulsar Function is written in Java).   It also supports URL path [http/https/file (file protocol assumes that file   already exists on worker host)] from which worker can download the package.  
        /// - **py**  
        ///   Path to the main Python file or Python wheel file for the Pulsar Function (if the Pulsar Function is written in Python).  
        /// - **go**  
        ///   Path to the main Go executable binary for the Pulsar Function (if the Pulsar Function is written in Go).  
        /// - **logTopic**  
        ///   The topic to which the logs of a Pulsar Function are produced.  
        /// - **maxMessageRetries**  
        ///   How many times should we try to process a message before giving up.  
        /// - **output**  
        ///   The output topic of a Pulsar Function (If none is specified, no output is written).  
        /// - **outputSerdeClassName**  
        ///   The SerDe class to be used for messages output by the Pulsar Function.  
        /// - **parallelism**  
        ///   The parallelism factor of a Pulsar Function (i.e. the number of a Pulsar Function instances to run).  
        /// - **processingGuarantees**  
        ///   The processing guarantees (that is, delivery semantics) applied to the Pulsar Function.  Possible Values: [ATLEAST_ONCE, ATMOST_ONCE, EFFECTIVELY_ONCE]  
        /// - **retainOrdering**  
        ///   Function consumes and processes messages in order.  
        /// - **outputSchemaType**  
        ///    Represents either a builtin schema type (for example: 'avro', 'json', ect) or the class name for a Schema implementation.- **subName**  
        ///   Pulsar source subscription name. User can specify a subscription-name for the input-topic consumer.  
        /// - **windowConfig**  
        ///   The window configuration of a Pulsar Function.  
        /// - **timeoutMs**  
        ///   The message timeout in milliseconds.  
        /// - **topicsPattern**  
        ///   The topic pattern to consume from a list of topics under a namespace that match the pattern.  [input] and [topic-pattern] are mutually exclusive. Add SerDe class name for a   pattern in customSerdeInputs (supported for java fun only)  
        /// - **userConfig**  
        ///   A map of user-defined configurations (specified as a JSON object).  
        /// - **secrets**  
        ///   This is a map of secretName(that is how the secret is going to be accessed in the Pulsar Function via context) to an object that  encapsulates how the secret is fetched by the underlying secrets provider. The type of an value here can be found by the  SecretProviderConfigurator.getSecretObjectType() method. 
        /// - **cleanupSubscription**  
        ///   Whether the subscriptions of a Pulsar Function created or used should be deleted when the Pulsar Function is deleted.</param>
        /// <returns>Pulsar Function successfully created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RegisterFunctionAsync(string tenant, string @namespace, string functionName, System.IO.Stream body);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Creates a new Pulsar Function in cluster mode</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="body">A JSON value presenting configuration payload of a Pulsar Function. An example of the expected Pulsar Function can be found here.  
        /// - **autoAck**  
        ///   Whether or not the framework acknowledges messages automatically.  
        /// - **runtime**  
        ///   What is the runtime of the Pulsar Function. Possible Values: [JAVA, PYTHON, GO]  
        /// - **resources**  
        ///   The size of the system resources allowed by the Pulsar Function runtime. The resources include: cpu, ram, disk.  
        /// - **className**  
        ///   The class name of a Pulsar Function.  
        /// - **customSchemaInputs**  
        ///   The map of input topics to Schema class names (specified as a JSON object).  
        /// - **customSerdeInputs**  
        ///   The map of input topics to SerDe class names (specified as a JSON object).  
        /// - **deadLetterTopic**  
        ///   Messages that are not processed successfully are sent to `deadLetterTopic`.  
        /// - **runtimeFlags**  
        ///   Any flags that you want to pass to the runtime. Note that in thread mode, these flags have no impact.  
        /// - **fqfn**  
        ///   The Fully Qualified Function Name (FQFN) for the Pulsar Function.  
        /// - **inputSpecs**  
        ///    The map of input topics to its consumer configuration, each configuration has schema of    {"schemaType": "type-x", "serdeClassName": "name-x", "isRegexPattern": true, "receiverQueueSize": 5}  
        /// - **inputs**  
        ///   The input topic or topics (multiple topics can be specified as a comma-separated list) of a Pulsar Function.  
        /// - **jar**  
        ///   Path to the JAR file for the Pulsar Function (if the Pulsar Function is written in Java).   It also supports URL path [http/https/file (file protocol assumes that file   already exists on worker host)] from which worker can download the package.  
        /// - **py**  
        ///   Path to the main Python file or Python wheel file for the Pulsar Function (if the Pulsar Function is written in Python).  
        /// - **go**  
        ///   Path to the main Go executable binary for the Pulsar Function (if the Pulsar Function is written in Go).  
        /// - **logTopic**  
        ///   The topic to which the logs of a Pulsar Function are produced.  
        /// - **maxMessageRetries**  
        ///   How many times should we try to process a message before giving up.  
        /// - **output**  
        ///   The output topic of a Pulsar Function (If none is specified, no output is written).  
        /// - **outputSerdeClassName**  
        ///   The SerDe class to be used for messages output by the Pulsar Function.  
        /// - **parallelism**  
        ///   The parallelism factor of a Pulsar Function (i.e. the number of a Pulsar Function instances to run).  
        /// - **processingGuarantees**  
        ///   The processing guarantees (that is, delivery semantics) applied to the Pulsar Function.  Possible Values: [ATLEAST_ONCE, ATMOST_ONCE, EFFECTIVELY_ONCE]  
        /// - **retainOrdering**  
        ///   Function consumes and processes messages in order.  
        /// - **outputSchemaType**  
        ///    Represents either a builtin schema type (for example: 'avro', 'json', ect) or the class name for a Schema implementation.- **subName**  
        ///   Pulsar source subscription name. User can specify a subscription-name for the input-topic consumer.  
        /// - **windowConfig**  
        ///   The window configuration of a Pulsar Function.  
        /// - **timeoutMs**  
        ///   The message timeout in milliseconds.  
        /// - **topicsPattern**  
        ///   The topic pattern to consume from a list of topics under a namespace that match the pattern.  [input] and [topic-pattern] are mutually exclusive. Add SerDe class name for a   pattern in customSerdeInputs (supported for java fun only)  
        /// - **userConfig**  
        ///   A map of user-defined configurations (specified as a JSON object).  
        /// - **secrets**  
        ///   This is a map of secretName(that is how the secret is going to be accessed in the Pulsar Function via context) to an object that  encapsulates how the secret is fetched by the underlying secrets provider. The type of an value here can be found by the  SecretProviderConfigurator.getSecretObjectType() method. 
        /// - **cleanupSubscription**  
        ///   Whether the subscriptions of a Pulsar Function created or used should be deleted when the Pulsar Function is deleted.</param>
        /// <returns>Pulsar Function successfully created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RegisterFunctionAsync(string tenant, string @namespace, string functionName, System.IO.Stream body, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Updates a Pulsar Function currently running in cluster mode</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="bodyBody">A JSON value presenting configuration payload of a Pulsar Function. An example of the expected Pulsar Function can be found here.  
        /// - **autoAck**  
        ///   Whether or not the framework acknowledges messages automatically.  
        /// - **runtime**  
        ///   What is the runtime of the Pulsar Function. Possible Values: [JAVA, PYTHON, GO]  
        /// - **resources**  
        ///   The size of the system resources allowed by the Pulsar Function runtime. The resources include: cpu, ram, disk.  
        /// - **className**  
        ///   The class name of a Pulsar Function.  
        /// - **customSchemaInputs**  
        ///   The map of input topics to Schema class names (specified as a JSON object).  
        /// - **customSerdeInputs**  
        ///   The map of input topics to SerDe class names (specified as a JSON object).  
        /// - **deadLetterTopic**  
        ///   Messages that are not processed successfully are sent to `deadLetterTopic`.  
        /// - **runtimeFlags**  
        ///   Any flags that you want to pass to the runtime. Note that in thread mode, these flags have no impact.  
        /// - **fqfn**  
        ///   The Fully Qualified Function Name (FQFN) for the Pulsar Function.  
        /// - **inputSpecs**  
        ///    The map of input topics to its consumer configuration, each configuration has schema of    {"schemaType": "type-x", "serdeClassName": "name-x", "isRegexPattern": true, "receiverQueueSize": 5}  
        /// - **inputs**  
        ///   The input topic or topics (multiple topics can be specified as a comma-separated list) of a Pulsar Function.  
        /// - **jar**  
        ///   Path to the JAR file for the Pulsar Function (if the Pulsar Function is written in Java).   It also supports URL path [http/https/file (file protocol assumes that file   already exists on worker host)] from which worker can download the package.  
        /// - **py**  
        ///   Path to the main Python file or Python wheel file for the Pulsar Function (if the Pulsar Function is written in Python).  
        /// - **go**  
        ///   Path to the main Go executable binary for the Pulsar Function (if the Pulsar Function is written in Go).  
        /// - **logTopic**  
        ///   The topic to which the logs of a Pulsar Function are produced.  
        /// - **maxMessageRetries**  
        ///   How many times should we try to process a message before giving up.  
        /// - **output**  
        ///   The output topic of a Pulsar Function (If none is specified, no output is written).  
        /// - **outputSerdeClassName**  
        ///   The SerDe class to be used for messages output by the Pulsar Function.  
        /// - **parallelism**  
        ///   The parallelism factor of a Pulsar Function (i.e. the number of a Pulsar Function instances to run).  
        /// - **processingGuarantees**  
        ///   The processing guarantees (that is, delivery semantics) applied to the Pulsar Function.  Possible Values: [ATLEAST_ONCE, ATMOST_ONCE, EFFECTIVELY_ONCE]  
        /// - **retainOrdering**  
        ///   Function consumes and processes messages in order.  
        /// - **outputSchemaType**  
        ///    Represents either a builtin schema type (for example: 'avro', 'json', ect) or the class name for a Schema implementation.- **subName**  
        ///   Pulsar source subscription name. User can specify a subscription-name for the input-topic consumer.  
        /// - **windowConfig**  
        ///   The window configuration of a Pulsar Function.  
        /// - **timeoutMs**  
        ///   The message timeout in milliseconds.  
        /// - **topicsPattern**  
        ///   The topic pattern to consume from a list of topics under a namespace that match the pattern.  [input] and [topic-pattern] are mutually exclusive. Add SerDe class name for a   pattern in customSerdeInputs (supported for java fun only)  
        /// - **userConfig**  
        ///   A map of user-defined configurations (specified as a JSON object).  
        /// - **secrets**  
        ///   This is a map of secretName(that is how the secret is going to be accessed in the Pulsar Function via context) to an object that  encapsulates how the secret is fetched by the underlying secrets provider. The type of an value here can be found by the  SecretProviderConfigurator.getSecretObjectType() method. 
        /// - **cleanupSubscription**  
        ///   Whether the subscriptions of a Pulsar Function created or used should be deleted when the Pulsar Function is deleted.</param>
        /// <returns>Pulsar Function successfully updated</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateFunctionAsync(string tenant, string @namespace, string functionName, System.IO.Stream bodyBody);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Updates a Pulsar Function currently running in cluster mode</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="bodyBody">A JSON value presenting configuration payload of a Pulsar Function. An example of the expected Pulsar Function can be found here.  
        /// - **autoAck**  
        ///   Whether or not the framework acknowledges messages automatically.  
        /// - **runtime**  
        ///   What is the runtime of the Pulsar Function. Possible Values: [JAVA, PYTHON, GO]  
        /// - **resources**  
        ///   The size of the system resources allowed by the Pulsar Function runtime. The resources include: cpu, ram, disk.  
        /// - **className**  
        ///   The class name of a Pulsar Function.  
        /// - **customSchemaInputs**  
        ///   The map of input topics to Schema class names (specified as a JSON object).  
        /// - **customSerdeInputs**  
        ///   The map of input topics to SerDe class names (specified as a JSON object).  
        /// - **deadLetterTopic**  
        ///   Messages that are not processed successfully are sent to `deadLetterTopic`.  
        /// - **runtimeFlags**  
        ///   Any flags that you want to pass to the runtime. Note that in thread mode, these flags have no impact.  
        /// - **fqfn**  
        ///   The Fully Qualified Function Name (FQFN) for the Pulsar Function.  
        /// - **inputSpecs**  
        ///    The map of input topics to its consumer configuration, each configuration has schema of    {"schemaType": "type-x", "serdeClassName": "name-x", "isRegexPattern": true, "receiverQueueSize": 5}  
        /// - **inputs**  
        ///   The input topic or topics (multiple topics can be specified as a comma-separated list) of a Pulsar Function.  
        /// - **jar**  
        ///   Path to the JAR file for the Pulsar Function (if the Pulsar Function is written in Java).   It also supports URL path [http/https/file (file protocol assumes that file   already exists on worker host)] from which worker can download the package.  
        /// - **py**  
        ///   Path to the main Python file or Python wheel file for the Pulsar Function (if the Pulsar Function is written in Python).  
        /// - **go**  
        ///   Path to the main Go executable binary for the Pulsar Function (if the Pulsar Function is written in Go).  
        /// - **logTopic**  
        ///   The topic to which the logs of a Pulsar Function are produced.  
        /// - **maxMessageRetries**  
        ///   How many times should we try to process a message before giving up.  
        /// - **output**  
        ///   The output topic of a Pulsar Function (If none is specified, no output is written).  
        /// - **outputSerdeClassName**  
        ///   The SerDe class to be used for messages output by the Pulsar Function.  
        /// - **parallelism**  
        ///   The parallelism factor of a Pulsar Function (i.e. the number of a Pulsar Function instances to run).  
        /// - **processingGuarantees**  
        ///   The processing guarantees (that is, delivery semantics) applied to the Pulsar Function.  Possible Values: [ATLEAST_ONCE, ATMOST_ONCE, EFFECTIVELY_ONCE]  
        /// - **retainOrdering**  
        ///   Function consumes and processes messages in order.  
        /// - **outputSchemaType**  
        ///    Represents either a builtin schema type (for example: 'avro', 'json', ect) or the class name for a Schema implementation.- **subName**  
        ///   Pulsar source subscription name. User can specify a subscription-name for the input-topic consumer.  
        /// - **windowConfig**  
        ///   The window configuration of a Pulsar Function.  
        /// - **timeoutMs**  
        ///   The message timeout in milliseconds.  
        /// - **topicsPattern**  
        ///   The topic pattern to consume from a list of topics under a namespace that match the pattern.  [input] and [topic-pattern] are mutually exclusive. Add SerDe class name for a   pattern in customSerdeInputs (supported for java fun only)  
        /// - **userConfig**  
        ///   A map of user-defined configurations (specified as a JSON object).  
        /// - **secrets**  
        ///   This is a map of secretName(that is how the secret is going to be accessed in the Pulsar Function via context) to an object that  encapsulates how the secret is fetched by the underlying secrets provider. The type of an value here can be found by the  SecretProviderConfigurator.getSecretObjectType() method. 
        /// - **cleanupSubscription**  
        ///   Whether the subscriptions of a Pulsar Function created or used should be deleted when the Pulsar Function is deleted.</param>
        /// <returns>Pulsar Function successfully updated</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateFunctionAsync(string tenant, string @namespace, string functionName, System.IO.Stream bodyBody, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Deletes a Pulsar Function currently running in cluster mode</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <returns>The Pulsar Function was successfully deleted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeregisterFunctionAsync(string tenant, string @namespace, string functionName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes a Pulsar Function currently running in cluster mode</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <returns>The Pulsar Function was successfully deleted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeregisterFunctionAsync(string tenant, string @namespace, string functionName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Restart all instances of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RestartFunctionAsync(string tenant, string @namespace, string functionName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Restart all instances of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RestartFunctionAsync(string tenant, string @namespace, string functionName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Start all instances of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task StartFunctionAsync(string tenant, string @namespace, string functionName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Start all instances of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task StartFunctionAsync(string tenant, string @namespace, string functionName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Fetch the current state associated with a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="key">The stats key</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FunctionState> GetFunctionStateAsync(string tenant, string @namespace, string functionName, string key);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Fetch the current state associated with a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="key">The stats key</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FunctionState> GetFunctionStateAsync(string tenant, string @namespace, string functionName, string key, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Put the state associated with a Pulsar Function</summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PutFunctionStateAsync(string tenant, string @namespace, string functionName, string key);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Put the state associated with a Pulsar Function</summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PutFunctionStateAsync(string tenant, string @namespace, string functionName, string key, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Displays the stats of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FunctionStats> GetFunctionStatsAsync(string tenant, string @namespace, string functionName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Displays the stats of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FunctionStats> GetFunctionStatsAsync(string tenant, string @namespace, string functionName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Displays the status of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FunctionStatus> GetFunctionStatusAsync(string tenant, string @namespace, string functionName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Displays the status of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FunctionStatus> GetFunctionStatusAsync(string tenant, string @namespace, string functionName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Stop all instances of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task StopFunctionAsync(string tenant, string @namespace, string functionName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Stop all instances of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task StopFunctionAsync(string tenant, string @namespace, string functionName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Triggers a Pulsar Function with a user-specified value or file data</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="bodyBody">The value with which you want to trigger the Pulsar Function</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Message> TriggerFunctionAsync(string tenant, string @namespace, string functionName, System.IO.Stream bodyBody);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Triggers a Pulsar Function with a user-specified value or file data</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="bodyBody">The value with which you want to trigger the Pulsar Function</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Message> TriggerFunctionAsync(string tenant, string @namespace, string functionName, System.IO.Stream bodyBody, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Restart an instance of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="instanceId">The instanceId of a Pulsar Function (if instance-id is not provided, all instances are restarted</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RestartFunction2Async(string tenant, string @namespace, string functionName, string instanceId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Restart an instance of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="instanceId">The instanceId of a Pulsar Function (if instance-id is not provided, all instances are restarted</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RestartFunction2Async(string tenant, string @namespace, string functionName, string instanceId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Start an instance of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="instanceId">The instanceId of a Pulsar Function (if instance-id is not provided, all instances sre started.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task StartFunction2Async(string tenant, string @namespace, string functionName, string instanceId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Start an instance of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="instanceId">The instanceId of a Pulsar Function (if instance-id is not provided, all instances sre started.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task StartFunction2Async(string tenant, string @namespace, string functionName, string instanceId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Displays the stats of a Pulsar Function instance</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="instanceId">The instanceId of a Pulsar Function (if instance-id is not provided, the stats of all instances is returned</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FunctionInstanceStatsData> GetFunctionInstanceStatsAsync(string tenant, string @namespace, string functionName, string instanceId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Displays the stats of a Pulsar Function instance</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="instanceId">The instanceId of a Pulsar Function (if instance-id is not provided, the stats of all instances is returned</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FunctionInstanceStatsData> GetFunctionInstanceStatsAsync(string tenant, string @namespace, string functionName, string instanceId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Displays the status of a Pulsar Function instance</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="instanceId">The instanceId of a Pulsar Function (if instance-id is not provided, the stats of all instances is returned</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FunctionInstanceStatusData> GetFunctionInstanceStatusAsync(string tenant, string @namespace, string functionName, string instanceId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Displays the status of a Pulsar Function instance</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="instanceId">The instanceId of a Pulsar Function (if instance-id is not provided, the stats of all instances is returned</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FunctionInstanceStatusData> GetFunctionInstanceStatusAsync(string tenant, string @namespace, string functionName, string instanceId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Stop an instance of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="instanceId">The instanceId of a Pulsar Function (if instance-id is not provided, all instances are stopped.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task StopFunction2Async(string tenant, string @namespace, string functionName, string instanceId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Stop an instance of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="instanceId">The instanceId of a Pulsar Function (if instance-id is not provided, all instances are stopped.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task StopFunction2Async(string tenant, string @namespace, string functionName, string instanceId, System.Threading.CancellationToken cancellationToken);
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.10.8.0 (NJsonSchema v10.3.11.0 (Newtonsoft.Json v12.0.0.2))")]
    public partial class PulsarFunctionsRESTAPIClient : IPulsarFunctionsRESTAPIClient
    {
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;
    
        public PulsarFunctionsRESTAPIClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }
    
        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }
    
        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }
    
        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
    
    
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);
        /// <summary>Fetches a list of supported Pulsar IO connectors currently running in cluster mode</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<object>> GetConnectorsListAsync()
        {
            return GetConnectorsListAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Fetches a list of supported Pulsar IO connectors currently running in cluster mode</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<object>> GetConnectorsListAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("functions/connectors");
    
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
    
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
    
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<object>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 408)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Request timeout", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }
    
        /// <summary>Lists all Pulsar Functions currently deployed in a given namespace</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public Task<string> ListFunctionsAsync(string tenant, string @namespace)
        {
            return ListFunctionsAsync(tenant, @namespace, CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Lists all Pulsar Functions currently deployed in a given namespace</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async Task<string> ListFunctionsAsync(string tenant, string @namespace, CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");
    
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("functions/{tenant}/{namespace}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
    
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
    
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }
    
        /// <summary>Fetches information about a Pulsar Function currently running in cluster mode</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FunctionConfig> GetFunctionInfoAsync(string tenant, string @namespace, string functionName)
        {
            return GetFunctionInfoAsync(tenant, @namespace, functionName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Fetches information about a Pulsar Function currently running in cluster mode</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FunctionConfig> GetFunctionInfoAsync(string tenant, string @namespace, string functionName, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");
    
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");
    
            if (functionName == null)
                throw new System.ArgumentNullException("functionName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("functions/{tenant}/{namespace}/{functionName}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{functionName}", System.Uri.EscapeDataString(ConvertToString(functionName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
    
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
    
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FunctionConfig>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Pulsar Function doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 408)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Request timeout", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }
    
        /// <summary>Creates a new Pulsar Function in cluster mode</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="body">A JSON value presenting configuration payload of a Pulsar Function. An example of the expected Pulsar Function can be found here.  
        /// - **autoAck**  
        ///   Whether or not the framework acknowledges messages automatically.  
        /// - **runtime**  
        ///   What is the runtime of the Pulsar Function. Possible Values: [JAVA, PYTHON, GO]  
        /// - **resources**  
        ///   The size of the system resources allowed by the Pulsar Function runtime. The resources include: cpu, ram, disk.  
        /// - **className**  
        ///   The class name of a Pulsar Function.  
        /// - **customSchemaInputs**  
        ///   The map of input topics to Schema class names (specified as a JSON object).  
        /// - **customSerdeInputs**  
        ///   The map of input topics to SerDe class names (specified as a JSON object).  
        /// - **deadLetterTopic**  
        ///   Messages that are not processed successfully are sent to `deadLetterTopic`.  
        /// - **runtimeFlags**  
        ///   Any flags that you want to pass to the runtime. Note that in thread mode, these flags have no impact.  
        /// - **fqfn**  
        ///   The Fully Qualified Function Name (FQFN) for the Pulsar Function.  
        /// - **inputSpecs**  
        ///    The map of input topics to its consumer configuration, each configuration has schema of    {"schemaType": "type-x", "serdeClassName": "name-x", "isRegexPattern": true, "receiverQueueSize": 5}  
        /// - **inputs**  
        ///   The input topic or topics (multiple topics can be specified as a comma-separated list) of a Pulsar Function.  
        /// - **jar**  
        ///   Path to the JAR file for the Pulsar Function (if the Pulsar Function is written in Java).   It also supports URL path [http/https/file (file protocol assumes that file   already exists on worker host)] from which worker can download the package.  
        /// - **py**  
        ///   Path to the main Python file or Python wheel file for the Pulsar Function (if the Pulsar Function is written in Python).  
        /// - **go**  
        ///   Path to the main Go executable binary for the Pulsar Function (if the Pulsar Function is written in Go).  
        /// - **logTopic**  
        ///   The topic to which the logs of a Pulsar Function are produced.  
        /// - **maxMessageRetries**  
        ///   How many times should we try to process a message before giving up.  
        /// - **output**  
        ///   The output topic of a Pulsar Function (If none is specified, no output is written).  
        /// - **outputSerdeClassName**  
        ///   The SerDe class to be used for messages output by the Pulsar Function.  
        /// - **parallelism**  
        ///   The parallelism factor of a Pulsar Function (i.e. the number of a Pulsar Function instances to run).  
        /// - **processingGuarantees**  
        ///   The processing guarantees (that is, delivery semantics) applied to the Pulsar Function.  Possible Values: [ATLEAST_ONCE, ATMOST_ONCE, EFFECTIVELY_ONCE]  
        /// - **retainOrdering**  
        ///   Function consumes and processes messages in order.  
        /// - **outputSchemaType**  
        ///    Represents either a builtin schema type (for example: 'avro', 'json', ect) or the class name for a Schema implementation.- **subName**  
        ///   Pulsar source subscription name. User can specify a subscription-name for the input-topic consumer.  
        /// - **windowConfig**  
        ///   The window configuration of a Pulsar Function.  
        /// - **timeoutMs**  
        ///   The message timeout in milliseconds.  
        /// - **topicsPattern**  
        ///   The topic pattern to consume from a list of topics under a namespace that match the pattern.  [input] and [topic-pattern] are mutually exclusive. Add SerDe class name for a   pattern in customSerdeInputs (supported for java fun only)  
        /// - **userConfig**  
        ///   A map of user-defined configurations (specified as a JSON object).  
        /// - **secrets**  
        ///   This is a map of secretName(that is how the secret is going to be accessed in the Pulsar Function via context) to an object that  encapsulates how the secret is fetched by the underlying secrets provider. The type of an value here can be found by the  SecretProviderConfigurator.getSecretObjectType() method. 
        /// - **cleanupSubscription**  
        ///   Whether the subscriptions of a Pulsar Function created or used should be deleted when the Pulsar Function is deleted.</param>
        /// <returns>Pulsar Function successfully created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task RegisterFunctionAsync(string tenant, string @namespace, string functionName, System.IO.Stream body)
        {
            return RegisterFunctionAsync(tenant, @namespace, functionName, body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Creates a new Pulsar Function in cluster mode</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="body">A JSON value presenting configuration payload of a Pulsar Function. An example of the expected Pulsar Function can be found here.  
        /// - **autoAck**  
        ///   Whether or not the framework acknowledges messages automatically.  
        /// - **runtime**  
        ///   What is the runtime of the Pulsar Function. Possible Values: [JAVA, PYTHON, GO]  
        /// - **resources**  
        ///   The size of the system resources allowed by the Pulsar Function runtime. The resources include: cpu, ram, disk.  
        /// - **className**  
        ///   The class name of a Pulsar Function.  
        /// - **customSchemaInputs**  
        ///   The map of input topics to Schema class names (specified as a JSON object).  
        /// - **customSerdeInputs**  
        ///   The map of input topics to SerDe class names (specified as a JSON object).  
        /// - **deadLetterTopic**  
        ///   Messages that are not processed successfully are sent to `deadLetterTopic`.  
        /// - **runtimeFlags**  
        ///   Any flags that you want to pass to the runtime. Note that in thread mode, these flags have no impact.  
        /// - **fqfn**  
        ///   The Fully Qualified Function Name (FQFN) for the Pulsar Function.  
        /// - **inputSpecs**  
        ///    The map of input topics to its consumer configuration, each configuration has schema of    {"schemaType": "type-x", "serdeClassName": "name-x", "isRegexPattern": true, "receiverQueueSize": 5}  
        /// - **inputs**  
        ///   The input topic or topics (multiple topics can be specified as a comma-separated list) of a Pulsar Function.  
        /// - **jar**  
        ///   Path to the JAR file for the Pulsar Function (if the Pulsar Function is written in Java).   It also supports URL path [http/https/file (file protocol assumes that file   already exists on worker host)] from which worker can download the package.  
        /// - **py**  
        ///   Path to the main Python file or Python wheel file for the Pulsar Function (if the Pulsar Function is written in Python).  
        /// - **go**  
        ///   Path to the main Go executable binary for the Pulsar Function (if the Pulsar Function is written in Go).  
        /// - **logTopic**  
        ///   The topic to which the logs of a Pulsar Function are produced.  
        /// - **maxMessageRetries**  
        ///   How many times should we try to process a message before giving up.  
        /// - **output**  
        ///   The output topic of a Pulsar Function (If none is specified, no output is written).  
        /// - **outputSerdeClassName**  
        ///   The SerDe class to be used for messages output by the Pulsar Function.  
        /// - **parallelism**  
        ///   The parallelism factor of a Pulsar Function (i.e. the number of a Pulsar Function instances to run).  
        /// - **processingGuarantees**  
        ///   The processing guarantees (that is, delivery semantics) applied to the Pulsar Function.  Possible Values: [ATLEAST_ONCE, ATMOST_ONCE, EFFECTIVELY_ONCE]  
        /// - **retainOrdering**  
        ///   Function consumes and processes messages in order.  
        /// - **outputSchemaType**  
        ///    Represents either a builtin schema type (for example: 'avro', 'json', ect) or the class name for a Schema implementation.- **subName**  
        ///   Pulsar source subscription name. User can specify a subscription-name for the input-topic consumer.  
        /// - **windowConfig**  
        ///   The window configuration of a Pulsar Function.  
        /// - **timeoutMs**  
        ///   The message timeout in milliseconds.  
        /// - **topicsPattern**  
        ///   The topic pattern to consume from a list of topics under a namespace that match the pattern.  [input] and [topic-pattern] are mutually exclusive. Add SerDe class name for a   pattern in customSerdeInputs (supported for java fun only)  
        /// - **userConfig**  
        ///   A map of user-defined configurations (specified as a JSON object).  
        /// - **secrets**  
        ///   This is a map of secretName(that is how the secret is going to be accessed in the Pulsar Function via context) to an object that  encapsulates how the secret is fetched by the underlying secrets provider. The type of an value here can be found by the  SecretProviderConfigurator.getSecretObjectType() method. 
        /// - **cleanupSubscription**  
        ///   Whether the subscriptions of a Pulsar Function created or used should be deleted when the Pulsar Function is deleted.</param>
        /// <returns>Pulsar Function successfully created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task RegisterFunctionAsync(string tenant, string @namespace, string functionName, System.IO.Stream body, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");
    
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");
    
            if (functionName == null)
                throw new System.ArgumentNullException("functionName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("functions/{tenant}/{namespace}/{functionName}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{functionName}", System.Uri.EscapeDataString(ConvertToString(functionName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StreamContent(body);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("multipart/form-data");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
    
                    PrepareRequest(client_, request_, urlBuilder_);
    
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
    
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request (The Pulsar Function already exists, etc.)", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 408)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Request timeout", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }
    
        /// <summary>Updates a Pulsar Function currently running in cluster mode</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="bodyBody">A JSON value presenting configuration payload of a Pulsar Function. An example of the expected Pulsar Function can be found here.  
        /// - **autoAck**  
        ///   Whether or not the framework acknowledges messages automatically.  
        /// - **runtime**  
        ///   What is the runtime of the Pulsar Function. Possible Values: [JAVA, PYTHON, GO]  
        /// - **resources**  
        ///   The size of the system resources allowed by the Pulsar Function runtime. The resources include: cpu, ram, disk.  
        /// - **className**  
        ///   The class name of a Pulsar Function.  
        /// - **customSchemaInputs**  
        ///   The map of input topics to Schema class names (specified as a JSON object).  
        /// - **customSerdeInputs**  
        ///   The map of input topics to SerDe class names (specified as a JSON object).  
        /// - **deadLetterTopic**  
        ///   Messages that are not processed successfully are sent to `deadLetterTopic`.  
        /// - **runtimeFlags**  
        ///   Any flags that you want to pass to the runtime. Note that in thread mode, these flags have no impact.  
        /// - **fqfn**  
        ///   The Fully Qualified Function Name (FQFN) for the Pulsar Function.  
        /// - **inputSpecs**  
        ///    The map of input topics to its consumer configuration, each configuration has schema of    {"schemaType": "type-x", "serdeClassName": "name-x", "isRegexPattern": true, "receiverQueueSize": 5}  
        /// - **inputs**  
        ///   The input topic or topics (multiple topics can be specified as a comma-separated list) of a Pulsar Function.  
        /// - **jar**  
        ///   Path to the JAR file for the Pulsar Function (if the Pulsar Function is written in Java).   It also supports URL path [http/https/file (file protocol assumes that file   already exists on worker host)] from which worker can download the package.  
        /// - **py**  
        ///   Path to the main Python file or Python wheel file for the Pulsar Function (if the Pulsar Function is written in Python).  
        /// - **go**  
        ///   Path to the main Go executable binary for the Pulsar Function (if the Pulsar Function is written in Go).  
        /// - **logTopic**  
        ///   The topic to which the logs of a Pulsar Function are produced.  
        /// - **maxMessageRetries**  
        ///   How many times should we try to process a message before giving up.  
        /// - **output**  
        ///   The output topic of a Pulsar Function (If none is specified, no output is written).  
        /// - **outputSerdeClassName**  
        ///   The SerDe class to be used for messages output by the Pulsar Function.  
        /// - **parallelism**  
        ///   The parallelism factor of a Pulsar Function (i.e. the number of a Pulsar Function instances to run).  
        /// - **processingGuarantees**  
        ///   The processing guarantees (that is, delivery semantics) applied to the Pulsar Function.  Possible Values: [ATLEAST_ONCE, ATMOST_ONCE, EFFECTIVELY_ONCE]  
        /// - **retainOrdering**  
        ///   Function consumes and processes messages in order.  
        /// - **outputSchemaType**  
        ///    Represents either a builtin schema type (for example: 'avro', 'json', ect) or the class name for a Schema implementation.- **subName**  
        ///   Pulsar source subscription name. User can specify a subscription-name for the input-topic consumer.  
        /// - **windowConfig**  
        ///   The window configuration of a Pulsar Function.  
        /// - **timeoutMs**  
        ///   The message timeout in milliseconds.  
        /// - **topicsPattern**  
        ///   The topic pattern to consume from a list of topics under a namespace that match the pattern.  [input] and [topic-pattern] are mutually exclusive. Add SerDe class name for a   pattern in customSerdeInputs (supported for java fun only)  
        /// - **userConfig**  
        ///   A map of user-defined configurations (specified as a JSON object).  
        /// - **secrets**  
        ///   This is a map of secretName(that is how the secret is going to be accessed in the Pulsar Function via context) to an object that  encapsulates how the secret is fetched by the underlying secrets provider. The type of an value here can be found by the  SecretProviderConfigurator.getSecretObjectType() method. 
        /// - **cleanupSubscription**  
        ///   Whether the subscriptions of a Pulsar Function created or used should be deleted when the Pulsar Function is deleted.</param>
        /// <returns>Pulsar Function successfully updated</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task UpdateFunctionAsync(string tenant, string @namespace, string functionName, System.IO.Stream bodyBody)
        {
            return UpdateFunctionAsync(tenant, @namespace, functionName, bodyBody, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Updates a Pulsar Function currently running in cluster mode</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="bodyBody">A JSON value presenting configuration payload of a Pulsar Function. An example of the expected Pulsar Function can be found here.  
        /// - **autoAck**  
        ///   Whether or not the framework acknowledges messages automatically.  
        /// - **runtime**  
        ///   What is the runtime of the Pulsar Function. Possible Values: [JAVA, PYTHON, GO]  
        /// - **resources**  
        ///   The size of the system resources allowed by the Pulsar Function runtime. The resources include: cpu, ram, disk.  
        /// - **className**  
        ///   The class name of a Pulsar Function.  
        /// - **customSchemaInputs**  
        ///   The map of input topics to Schema class names (specified as a JSON object).  
        /// - **customSerdeInputs**  
        ///   The map of input topics to SerDe class names (specified as a JSON object).  
        /// - **deadLetterTopic**  
        ///   Messages that are not processed successfully are sent to `deadLetterTopic`.  
        /// - **runtimeFlags**  
        ///   Any flags that you want to pass to the runtime. Note that in thread mode, these flags have no impact.  
        /// - **fqfn**  
        ///   The Fully Qualified Function Name (FQFN) for the Pulsar Function.  
        /// - **inputSpecs**  
        ///    The map of input topics to its consumer configuration, each configuration has schema of    {"schemaType": "type-x", "serdeClassName": "name-x", "isRegexPattern": true, "receiverQueueSize": 5}  
        /// - **inputs**  
        ///   The input topic or topics (multiple topics can be specified as a comma-separated list) of a Pulsar Function.  
        /// - **jar**  
        ///   Path to the JAR file for the Pulsar Function (if the Pulsar Function is written in Java).   It also supports URL path [http/https/file (file protocol assumes that file   already exists on worker host)] from which worker can download the package.  
        /// - **py**  
        ///   Path to the main Python file or Python wheel file for the Pulsar Function (if the Pulsar Function is written in Python).  
        /// - **go**  
        ///   Path to the main Go executable binary for the Pulsar Function (if the Pulsar Function is written in Go).  
        /// - **logTopic**  
        ///   The topic to which the logs of a Pulsar Function are produced.  
        /// - **maxMessageRetries**  
        ///   How many times should we try to process a message before giving up.  
        /// - **output**  
        ///   The output topic of a Pulsar Function (If none is specified, no output is written).  
        /// - **outputSerdeClassName**  
        ///   The SerDe class to be used for messages output by the Pulsar Function.  
        /// - **parallelism**  
        ///   The parallelism factor of a Pulsar Function (i.e. the number of a Pulsar Function instances to run).  
        /// - **processingGuarantees**  
        ///   The processing guarantees (that is, delivery semantics) applied to the Pulsar Function.  Possible Values: [ATLEAST_ONCE, ATMOST_ONCE, EFFECTIVELY_ONCE]  
        /// - **retainOrdering**  
        ///   Function consumes and processes messages in order.  
        /// - **outputSchemaType**  
        ///    Represents either a builtin schema type (for example: 'avro', 'json', ect) or the class name for a Schema implementation.- **subName**  
        ///   Pulsar source subscription name. User can specify a subscription-name for the input-topic consumer.  
        /// - **windowConfig**  
        ///   The window configuration of a Pulsar Function.  
        /// - **timeoutMs**  
        ///   The message timeout in milliseconds.  
        /// - **topicsPattern**  
        ///   The topic pattern to consume from a list of topics under a namespace that match the pattern.  [input] and [topic-pattern] are mutually exclusive. Add SerDe class name for a   pattern in customSerdeInputs (supported for java fun only)  
        /// - **userConfig**  
        ///   A map of user-defined configurations (specified as a JSON object).  
        /// - **secrets**  
        ///   This is a map of secretName(that is how the secret is going to be accessed in the Pulsar Function via context) to an object that  encapsulates how the secret is fetched by the underlying secrets provider. The type of an value here can be found by the  SecretProviderConfigurator.getSecretObjectType() method. 
        /// - **cleanupSubscription**  
        ///   Whether the subscriptions of a Pulsar Function created or used should be deleted when the Pulsar Function is deleted.</param>
        /// <returns>Pulsar Function successfully updated</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task UpdateFunctionAsync(string tenant, string @namespace, string functionName, System.IO.Stream bodyBody, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");
    
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");
    
            if (functionName == null)
                throw new System.ArgumentNullException("functionName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("functions/{tenant}/{namespace}/{functionName}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{functionName}", System.Uri.EscapeDataString(ConvertToString(functionName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StreamContent(bodyBody);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("multipart/form-data");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
    
                    PrepareRequest(client_, request_, urlBuilder_);
    
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
    
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request (The Pulsar Function doesn\'t exist, etc.)", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }
    
        /// <summary>Deletes a Pulsar Function currently running in cluster mode</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <returns>The Pulsar Function was successfully deleted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeregisterFunctionAsync(string tenant, string @namespace, string functionName)
        {
            return DeregisterFunctionAsync(tenant, @namespace, functionName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes a Pulsar Function currently running in cluster mode</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <returns>The Pulsar Function was successfully deleted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeregisterFunctionAsync(string tenant, string @namespace, string functionName, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");
    
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");
    
            if (functionName == null)
                throw new System.ArgumentNullException("functionName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("functions/{tenant}/{namespace}/{functionName}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{functionName}", System.Uri.EscapeDataString(ConvertToString(functionName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
    
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
    
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Pulsar Function doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 408)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Request timeout", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }
    
        /// <summary>Restart all instances of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task RestartFunctionAsync(string tenant, string @namespace, string functionName)
        {
            return RestartFunctionAsync(tenant, @namespace, functionName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Restart all instances of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task RestartFunctionAsync(string tenant, string @namespace, string functionName, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");
    
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");
    
            if (functionName == null)
                throw new System.ArgumentNullException("functionName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("functions/{tenant}/{namespace}/{functionName}/restart");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{functionName}", System.Uri.EscapeDataString(ConvertToString(functionName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
    
                    PrepareRequest(client_, request_, urlBuilder_);
    
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
    
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = (int)response_.StatusCode;
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Pulsar Function does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 200 || status_ == 204)
                        {
                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }
    
        /// <summary>Start all instances of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task StartFunctionAsync(string tenant, string @namespace, string functionName)
        {
            return StartFunctionAsync(tenant, @namespace, functionName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Start all instances of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task StartFunctionAsync(string tenant, string @namespace, string functionName, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");
    
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");
    
            if (functionName == null)
                throw new System.ArgumentNullException("functionName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("functions/{tenant}/{namespace}/{functionName}/start");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{functionName}", System.Uri.EscapeDataString(ConvertToString(functionName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
    
                    PrepareRequest(client_, request_, urlBuilder_);
    
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
    
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = (int)response_.StatusCode;
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Pulsar Function does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 200 || status_ == 204)
                        {
                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }
    
        /// <summary>Fetch the current state associated with a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="key">The stats key</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FunctionState> GetFunctionStateAsync(string tenant, string @namespace, string functionName, string key)
        {
            return GetFunctionStateAsync(tenant, @namespace, functionName, key, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Fetch the current state associated with a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="key">The stats key</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FunctionState> GetFunctionStateAsync(string tenant, string @namespace, string functionName, string key, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");
    
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");
    
            if (functionName == null)
                throw new System.ArgumentNullException("functionName");
    
            if (key == null)
                throw new System.ArgumentNullException("key");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("functions/{tenant}/{namespace}/{functionName}/state/{key}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{functionName}", System.Uri.EscapeDataString(ConvertToString(functionName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{key}", System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
    
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
    
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FunctionState>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The key does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }
    
        /// <summary>Put the state associated with a Pulsar Function</summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task PutFunctionStateAsync(string tenant, string @namespace, string functionName, string key)
        {
            return PutFunctionStateAsync(tenant, @namespace, functionName, key, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Put the state associated with a Pulsar Function</summary>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task PutFunctionStateAsync(string tenant, string @namespace, string functionName, string key, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");
    
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");
    
            if (functionName == null)
                throw new System.ArgumentNullException("functionName");
    
            if (key == null)
                throw new System.ArgumentNullException("key");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("functions/{tenant}/{namespace}/{functionName}/state/{key}");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{functionName}", System.Uri.EscapeDataString(ConvertToString(functionName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{key}", System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
    
                    PrepareRequest(client_, request_, urlBuilder_);
    
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
    
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = (int)response_.StatusCode;
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Pulsar Function does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 200 || status_ == 204)
                        {
                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }
    
        /// <summary>Displays the stats of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FunctionStats> GetFunctionStatsAsync(string tenant, string @namespace, string functionName)
        {
            return GetFunctionStatsAsync(tenant, @namespace, functionName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Displays the stats of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FunctionStats> GetFunctionStatsAsync(string tenant, string @namespace, string functionName, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");
    
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");
    
            if (functionName == null)
                throw new System.ArgumentNullException("functionName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("functions/{tenant}/{namespace}/{functionName}/stats");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{functionName}", System.Uri.EscapeDataString(ConvertToString(functionName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
    
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
    
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FunctionStats>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this function", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Pulsar Function doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }
    
        /// <summary>Displays the status of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FunctionStatus> GetFunctionStatusAsync(string tenant, string @namespace, string functionName)
        {
            return GetFunctionStatusAsync(tenant, @namespace, functionName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Displays the status of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FunctionStatus> GetFunctionStatusAsync(string tenant, string @namespace, string functionName, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");
    
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");
    
            if (functionName == null)
                throw new System.ArgumentNullException("functionName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("functions/{tenant}/{namespace}/{functionName}/status");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{functionName}", System.Uri.EscapeDataString(ConvertToString(functionName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
    
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
    
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FunctionStatus>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this function", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Pulsar Function doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }
    
        /// <summary>Stop all instances of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task StopFunctionAsync(string tenant, string @namespace, string functionName)
        {
            return StopFunctionAsync(tenant, @namespace, functionName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Stop all instances of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task StopFunctionAsync(string tenant, string @namespace, string functionName, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");
    
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");
    
            if (functionName == null)
                throw new System.ArgumentNullException("functionName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("functions/{tenant}/{namespace}/{functionName}/stop");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{functionName}", System.Uri.EscapeDataString(ConvertToString(functionName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
    
                    PrepareRequest(client_, request_, urlBuilder_);
    
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
    
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = (int)response_.StatusCode;
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Pulsar Function does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 200 || status_ == 204)
                        {
                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }
    
        /// <summary>Triggers a Pulsar Function with a user-specified value or file data</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="bodyBody">The value with which you want to trigger the Pulsar Function</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<Message> TriggerFunctionAsync(string tenant, string @namespace, string functionName, System.IO.Stream bodyBody)
        {
            return TriggerFunctionAsync(tenant, @namespace, functionName, bodyBody, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Triggers a Pulsar Function with a user-specified value or file data</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="bodyBody">The value with which you want to trigger the Pulsar Function</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<Message> TriggerFunctionAsync(string tenant, string @namespace, string functionName, System.IO.Stream bodyBody, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");
    
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");
    
            if (functionName == null)
                throw new System.ArgumentNullException("functionName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("functions/{tenant}/{namespace}/{functionName}/trigger");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{functionName}", System.Uri.EscapeDataString(ConvertToString(functionName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StreamContent(bodyBody);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("multipart/form-data");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
    
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
    
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Message>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Pulsar Function does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 408)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Request timeout", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }
    
        /// <summary>Restart an instance of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="instanceId">The instanceId of a Pulsar Function (if instance-id is not provided, all instances are restarted</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task RestartFunction2Async(string tenant, string @namespace, string functionName, string instanceId)
        {
            return RestartFunction2Async(tenant, @namespace, functionName, instanceId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Restart an instance of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="instanceId">The instanceId of a Pulsar Function (if instance-id is not provided, all instances are restarted</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task RestartFunction2Async(string tenant, string @namespace, string functionName, string instanceId, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");
    
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");
    
            if (functionName == null)
                throw new System.ArgumentNullException("functionName");
    
            if (instanceId == null)
                throw new System.ArgumentNullException("instanceId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("functions/{tenant}/{namespace}/{functionName}/{instanceId}/restart");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{functionName}", System.Uri.EscapeDataString(ConvertToString(functionName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{instanceId}", System.Uri.EscapeDataString(ConvertToString(instanceId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
    
                    PrepareRequest(client_, request_, urlBuilder_);
    
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
    
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = (int)response_.StatusCode;
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this function", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Pulsar Function does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 200 || status_ == 204)
                        {
                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }
    
        /// <summary>Start an instance of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="instanceId">The instanceId of a Pulsar Function (if instance-id is not provided, all instances sre started.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task StartFunction2Async(string tenant, string @namespace, string functionName, string instanceId)
        {
            return StartFunction2Async(tenant, @namespace, functionName, instanceId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Start an instance of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="instanceId">The instanceId of a Pulsar Function (if instance-id is not provided, all instances sre started.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task StartFunction2Async(string tenant, string @namespace, string functionName, string instanceId, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");
    
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");
    
            if (functionName == null)
                throw new System.ArgumentNullException("functionName");
    
            if (instanceId == null)
                throw new System.ArgumentNullException("instanceId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("functions/{tenant}/{namespace}/{functionName}/{instanceId}/start");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{functionName}", System.Uri.EscapeDataString(ConvertToString(functionName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{instanceId}", System.Uri.EscapeDataString(ConvertToString(instanceId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
    
                    PrepareRequest(client_, request_, urlBuilder_);
    
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
    
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = (int)response_.StatusCode;
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Pulsar Function does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 200 || status_ == 204)
                        {
                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }
    
        /// <summary>Displays the stats of a Pulsar Function instance</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="instanceId">The instanceId of a Pulsar Function (if instance-id is not provided, the stats of all instances is returned</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FunctionInstanceStatsData> GetFunctionInstanceStatsAsync(string tenant, string @namespace, string functionName, string instanceId)
        {
            return GetFunctionInstanceStatsAsync(tenant, @namespace, functionName, instanceId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Displays the stats of a Pulsar Function instance</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="instanceId">The instanceId of a Pulsar Function (if instance-id is not provided, the stats of all instances is returned</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FunctionInstanceStatsData> GetFunctionInstanceStatsAsync(string tenant, string @namespace, string functionName, string instanceId, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");
    
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");
    
            if (functionName == null)
                throw new System.ArgumentNullException("functionName");
    
            if (instanceId == null)
                throw new System.ArgumentNullException("instanceId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("functions/{tenant}/{namespace}/{functionName}/{instanceId}/stats");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{functionName}", System.Uri.EscapeDataString(ConvertToString(functionName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{instanceId}", System.Uri.EscapeDataString(ConvertToString(instanceId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
    
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
    
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FunctionInstanceStatsData>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this function", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Pulsar Function doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }
    
        /// <summary>Displays the status of a Pulsar Function instance</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="instanceId">The instanceId of a Pulsar Function (if instance-id is not provided, the stats of all instances is returned</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FunctionInstanceStatusData> GetFunctionInstanceStatusAsync(string tenant, string @namespace, string functionName, string instanceId)
        {
            return GetFunctionInstanceStatusAsync(tenant, @namespace, functionName, instanceId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Displays the status of a Pulsar Function instance</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="instanceId">The instanceId of a Pulsar Function (if instance-id is not provided, the stats of all instances is returned</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FunctionInstanceStatusData> GetFunctionInstanceStatusAsync(string tenant, string @namespace, string functionName, string instanceId, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");
    
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");
    
            if (functionName == null)
                throw new System.ArgumentNullException("functionName");
    
            if (instanceId == null)
                throw new System.ArgumentNullException("instanceId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("functions/{tenant}/{namespace}/{functionName}/{instanceId}/status");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{functionName}", System.Uri.EscapeDataString(ConvertToString(functionName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{instanceId}", System.Uri.EscapeDataString(ConvertToString(instanceId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
    
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
    
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FunctionInstanceStatusData>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 307)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current broker doesn\'t serve the namespace of this function", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The requester doesn\'t have admin permissions", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Pulsar Function doesn\'t exist", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }
    
        /// <summary>Stop an instance of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="instanceId">The instanceId of a Pulsar Function (if instance-id is not provided, all instances are stopped.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task StopFunction2Async(string tenant, string @namespace, string functionName, string instanceId)
        {
            return StopFunction2Async(tenant, @namespace, functionName, instanceId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Stop an instance of a Pulsar Function</summary>
        /// <param name="tenant">The tenant of a Pulsar Function</param>
        /// <param name="@namespace">The namespace of a Pulsar Function</param>
        /// <param name="functionName">The name of a Pulsar Function</param>
        /// <param name="instanceId">The instanceId of a Pulsar Function (if instance-id is not provided, all instances are stopped.</param>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task StopFunction2Async(string tenant, string @namespace, string functionName, string instanceId, System.Threading.CancellationToken cancellationToken)
        {
            if (tenant == null)
                throw new System.ArgumentNullException("tenant");
    
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");
    
            if (functionName == null)
                throw new System.ArgumentNullException("functionName");
    
            if (instanceId == null)
                throw new System.ArgumentNullException("instanceId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("functions/{tenant}/{namespace}/{functionName}/{instanceId}/stop");
            urlBuilder_.Replace("{tenant}", System.Uri.EscapeDataString(ConvertToString(tenant, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{functionName}", System.Uri.EscapeDataString(ConvertToString(functionName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{instanceId}", System.Uri.EscapeDataString(ConvertToString(instanceId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
    
                    PrepareRequest(client_, request_, urlBuilder_);
    
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
    
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = (int)response_.StatusCode;
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Pulsar Function does not exist", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 200 || status_ == 204)
                        {
                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }
    
        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }
    
            public T Object { get; }
    
            public string Text { get; }
        }
    
        public bool ReadResponseAsString { get; set; }
        
        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }
        
            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }
    
        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }
        
            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
        
                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }
        
            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class AuthenticationConfig 
    {
        [Newtonsoft.Json.JsonProperty("clientAuthenticationPlugin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClientAuthenticationPlugin { get; set; }
    
        [Newtonsoft.Json.JsonProperty("clientAuthenticationParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClientAuthenticationParameters { get; set; }
    
        [Newtonsoft.Json.JsonProperty("tlsTrustCertsFilePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TlsTrustCertsFilePath { get; set; }
    
        [Newtonsoft.Json.JsonProperty("useTls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UseTls { get; set; }
    
        [Newtonsoft.Json.JsonProperty("tlsAllowInsecureConnection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? TlsAllowInsecureConnection { get; set; }
    
        [Newtonsoft.Json.JsonProperty("tlsHostnameVerificationEnable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? TlsHostnameVerificationEnable { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class ConsumerConfig 
    {
        [Newtonsoft.Json.JsonProperty("schemaType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SchemaType { get; set; }
    
        [Newtonsoft.Json.JsonProperty("serdeClassName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SerdeClassName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("schemaProperties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> SchemaProperties { get; set; }
    
        [Newtonsoft.Json.JsonProperty("consumerProperties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> ConsumerProperties { get; set; }
    
        [Newtonsoft.Json.JsonProperty("receiverQueueSize", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ReceiverQueueSize { get; set; }
    
        [Newtonsoft.Json.JsonProperty("cryptoConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CryptoConfig CryptoConfig { get; set; }
    
        [Newtonsoft.Json.JsonProperty("regexPattern", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RegexPattern { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CryptoConfig 
    {
        [Newtonsoft.Json.JsonProperty("cryptoKeyReaderClassName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CryptoKeyReaderClassName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("cryptoKeyReaderConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, object> CryptoKeyReaderConfig { get; set; }
    
        [Newtonsoft.Json.JsonProperty("encryptionKeys", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> EncryptionKeys { get; set; }
    
        [Newtonsoft.Json.JsonProperty("producerCryptoFailureAction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CryptoConfigProducerCryptoFailureAction? ProducerCryptoFailureAction { get; set; }
    
        [Newtonsoft.Json.JsonProperty("consumerCryptoFailureAction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CryptoConfigConsumerCryptoFailureAction? ConsumerCryptoFailureAction { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class EncryptionContext 
    {
        [Newtonsoft.Json.JsonProperty("keys", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, EncryptionKey> Keys { get; set; }
    
        [Newtonsoft.Json.JsonProperty("param", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<byte[]> Param { get; set; }
    
        [Newtonsoft.Json.JsonProperty("algorithm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Algorithm { get; set; }
    
        [Newtonsoft.Json.JsonProperty("compressionType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EncryptionContextCompressionType? CompressionType { get; set; }
    
        [Newtonsoft.Json.JsonProperty("uncompressedMessageSize", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? UncompressedMessageSize { get; set; }
    
        [Newtonsoft.Json.JsonProperty("batchSize", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? BatchSize { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class EncryptionKey 
    {
        [Newtonsoft.Json.JsonProperty("keyValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<byte[]> KeyValue { get; set; }
    
        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class ExceptionInformation 
    {
        [Newtonsoft.Json.JsonProperty("exceptionString", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExceptionString { get; set; }
    
        [Newtonsoft.Json.JsonProperty("timestampMs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? TimestampMs { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class ExternalPulsarConfig 
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("serviceURL", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServiceURL { get; set; }
    
        [Newtonsoft.Json.JsonProperty("authConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AuthenticationConfig AuthConfig { get; set; }
    
        [Newtonsoft.Json.JsonProperty("producerConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProducerConfig ProducerConfig { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class FunctionConfig 
    {
        [Newtonsoft.Json.JsonProperty("runtimeFlags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RuntimeFlags { get; set; }
    
        [Newtonsoft.Json.JsonProperty("tenant", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tenant { get; set; }
    
        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }
    
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("className", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClassName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("inputs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Inputs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("customSerdeInputs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> CustomSerdeInputs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("topicsPattern", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TopicsPattern { get; set; }
    
        [Newtonsoft.Json.JsonProperty("customSchemaInputs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> CustomSchemaInputs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("customSchemaOutputs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> CustomSchemaOutputs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("inputSpecs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, ConsumerConfig> InputSpecs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("output", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Output { get; set; }
    
        [Newtonsoft.Json.JsonProperty("producerConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProducerConfig ProducerConfig { get; set; }
    
        [Newtonsoft.Json.JsonProperty("outputSchemaType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OutputSchemaType { get; set; }
    
        [Newtonsoft.Json.JsonProperty("outputSerdeClassName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OutputSerdeClassName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("logTopic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LogTopic { get; set; }
    
        [Newtonsoft.Json.JsonProperty("processingGuarantees", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FunctionConfigProcessingGuarantees? ProcessingGuarantees { get; set; }
    
        [Newtonsoft.Json.JsonProperty("retainOrdering", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RetainOrdering { get; set; }
    
        [Newtonsoft.Json.JsonProperty("retainKeyOrdering", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RetainKeyOrdering { get; set; }
    
        [Newtonsoft.Json.JsonProperty("batchBuilder", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BatchBuilder { get; set; }
    
        [Newtonsoft.Json.JsonProperty("forwardSourceMessageProperty", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ForwardSourceMessageProperty { get; set; }
    
        [Newtonsoft.Json.JsonProperty("userConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, object> UserConfig { get; set; }
    
        [Newtonsoft.Json.JsonProperty("externalPulsars", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, ExternalPulsarConfig> ExternalPulsars { get; set; }
    
        [Newtonsoft.Json.JsonProperty("secrets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, object> Secrets { get; set; }
    
        [Newtonsoft.Json.JsonProperty("runtime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FunctionConfigRuntime? Runtime { get; set; }
    
        [Newtonsoft.Json.JsonProperty("autoAck", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AutoAck { get; set; }
    
        [Newtonsoft.Json.JsonProperty("maxMessageRetries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxMessageRetries { get; set; }
    
        [Newtonsoft.Json.JsonProperty("deadLetterTopic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DeadLetterTopic { get; set; }
    
        [Newtonsoft.Json.JsonProperty("subName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("parallelism", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Parallelism { get; set; }
    
        [Newtonsoft.Json.JsonProperty("resources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Resources Resources { get; set; }
    
        [Newtonsoft.Json.JsonProperty("fqfn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fqfn { get; set; }
    
        [Newtonsoft.Json.JsonProperty("windowConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WindowConfig WindowConfig { get; set; }
    
        [Newtonsoft.Json.JsonProperty("timeoutMs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? TimeoutMs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jar", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Jar { get; set; }
    
        [Newtonsoft.Json.JsonProperty("py", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Py { get; set; }
    
        [Newtonsoft.Json.JsonProperty("go", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Go { get; set; }
    
        [Newtonsoft.Json.JsonProperty("cleanupSubscription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CleanupSubscription { get; set; }
    
        [Newtonsoft.Json.JsonProperty("customRuntimeOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CustomRuntimeOptions { get; set; }
    
        [Newtonsoft.Json.JsonProperty("maxPendingAsyncRequests", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxPendingAsyncRequests { get; set; }
    
        [Newtonsoft.Json.JsonProperty("subscriptionPosition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FunctionConfigSubscriptionPosition? SubscriptionPosition { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class FunctionInstanceStats 
    {
        [Newtonsoft.Json.JsonProperty("instanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? InstanceId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("metrics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FunctionInstanceStatsData Metrics { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class FunctionInstanceStatsData 
    {
        [Newtonsoft.Json.JsonProperty("receivedTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ReceivedTotal { get; set; }
    
        [Newtonsoft.Json.JsonProperty("processedSuccessfullyTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ProcessedSuccessfullyTotal { get; set; }
    
        [Newtonsoft.Json.JsonProperty("systemExceptionsTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? SystemExceptionsTotal { get; set; }
    
        [Newtonsoft.Json.JsonProperty("userExceptionsTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? UserExceptionsTotal { get; set; }
    
        [Newtonsoft.Json.JsonProperty("avgProcessLatency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AvgProcessLatency { get; set; }
    
        [Newtonsoft.Json.JsonProperty("1min", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FunctionInstanceStatsDataBase _1min { get; set; }
    
        [Newtonsoft.Json.JsonProperty("lastInvocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? LastInvocation { get; set; }
    
        [Newtonsoft.Json.JsonProperty("userMetrics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, double> UserMetrics { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class FunctionInstanceStatsDataBase 
    {
        [Newtonsoft.Json.JsonProperty("receivedTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ReceivedTotal { get; set; }
    
        [Newtonsoft.Json.JsonProperty("processedSuccessfullyTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ProcessedSuccessfullyTotal { get; set; }
    
        [Newtonsoft.Json.JsonProperty("systemExceptionsTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? SystemExceptionsTotal { get; set; }
    
        [Newtonsoft.Json.JsonProperty("userExceptionsTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? UserExceptionsTotal { get; set; }
    
        [Newtonsoft.Json.JsonProperty("avgProcessLatency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AvgProcessLatency { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class FunctionInstanceStatus 
    {
        [Newtonsoft.Json.JsonProperty("instanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? InstanceId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FunctionInstanceStatusData Status { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class FunctionInstanceStatusData 
    {
        [Newtonsoft.Json.JsonProperty("running", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Running { get; set; }
    
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error { get; set; }
    
        [Newtonsoft.Json.JsonProperty("numRestarts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NumRestarts { get; set; }
    
        [Newtonsoft.Json.JsonProperty("numReceived", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NumReceived { get; set; }
    
        [Newtonsoft.Json.JsonProperty("numSuccessfullyProcessed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NumSuccessfullyProcessed { get; set; }
    
        [Newtonsoft.Json.JsonProperty("numUserExceptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NumUserExceptions { get; set; }
    
        [Newtonsoft.Json.JsonProperty("latestUserExceptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ExceptionInformation> LatestUserExceptions { get; set; }
    
        [Newtonsoft.Json.JsonProperty("numSystemExceptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NumSystemExceptions { get; set; }
    
        [Newtonsoft.Json.JsonProperty("latestSystemExceptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ExceptionInformation> LatestSystemExceptions { get; set; }
    
        [Newtonsoft.Json.JsonProperty("averageLatency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AverageLatency { get; set; }
    
        [Newtonsoft.Json.JsonProperty("lastInvocationTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? LastInvocationTime { get; set; }
    
        [Newtonsoft.Json.JsonProperty("workerId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkerId { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class FunctionState 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }
    
        [Newtonsoft.Json.JsonProperty("stringValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StringValue { get; set; }
    
        [Newtonsoft.Json.JsonProperty("byteValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<byte[]> ByteValue { get; set; }
    
        [Newtonsoft.Json.JsonProperty("numberValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NumberValue { get; set; }
    
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Version { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class FunctionStats 
    {
        [Newtonsoft.Json.JsonProperty("receivedTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ReceivedTotal { get; set; }
    
        [Newtonsoft.Json.JsonProperty("processedSuccessfullyTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ProcessedSuccessfullyTotal { get; set; }
    
        [Newtonsoft.Json.JsonProperty("systemExceptionsTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? SystemExceptionsTotal { get; set; }
    
        [Newtonsoft.Json.JsonProperty("userExceptionsTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? UserExceptionsTotal { get; set; }
    
        [Newtonsoft.Json.JsonProperty("avgProcessLatency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AvgProcessLatency { get; set; }
    
        [Newtonsoft.Json.JsonProperty("1min", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FunctionInstanceStatsDataBase _1min { get; set; }
    
        [Newtonsoft.Json.JsonProperty("lastInvocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? LastInvocation { get; set; }
    
        [Newtonsoft.Json.JsonProperty("instances", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FunctionInstanceStats> Instances { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class FunctionStatus 
    {
        [Newtonsoft.Json.JsonProperty("numInstances", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumInstances { get; set; }
    
        [Newtonsoft.Json.JsonProperty("numRunning", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumRunning { get; set; }
    
        [Newtonsoft.Json.JsonProperty("instances", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FunctionInstanceStatus> Instances { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class InputStream 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class Message 
    {
        [Newtonsoft.Json.JsonProperty("producerName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProducerName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("orderingKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<byte[]> OrderingKey { get; set; }
    
        [Newtonsoft.Json.JsonProperty("encryptionCtx", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EncryptionContext EncryptionCtx { get; set; }
    
        [Newtonsoft.Json.JsonProperty("redeliveryCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? RedeliveryCount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("schemaVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<byte[]> SchemaVersion { get; set; }
    
        [Newtonsoft.Json.JsonProperty("messageId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public MessageId MessageId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("keyBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<byte[]> KeyBytes { get; set; }
    
        [Newtonsoft.Json.JsonProperty("publishTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? PublishTime { get; set; }
    
        [Newtonsoft.Json.JsonProperty("eventTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? EventTime { get; set; }
    
        [Newtonsoft.Json.JsonProperty("replicatedFrom", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ReplicatedFrom { get; set; }
    
        [Newtonsoft.Json.JsonProperty("replicated", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Replicated { get; set; }
    
        [Newtonsoft.Json.JsonProperty("topicName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TopicName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("sequenceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? SequenceId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<byte[]> Data { get; set; }
    
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Value { get; set; }
    
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }
    
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Properties { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class MessageId 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class ProducerConfig 
    {
        [Newtonsoft.Json.JsonProperty("maxPendingMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxPendingMessages { get; set; }
    
        [Newtonsoft.Json.JsonProperty("maxPendingMessagesAcrossPartitions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxPendingMessagesAcrossPartitions { get; set; }
    
        [Newtonsoft.Json.JsonProperty("useThreadLocalProducers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UseThreadLocalProducers { get; set; }
    
        [Newtonsoft.Json.JsonProperty("cryptoConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CryptoConfig CryptoConfig { get; set; }
    
        [Newtonsoft.Json.JsonProperty("batchBuilder", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BatchBuilder { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class Resources 
    {
        [Newtonsoft.Json.JsonProperty("cpu", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Cpu { get; set; }
    
        [Newtonsoft.Json.JsonProperty("ram", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Ram { get; set; }
    
        [Newtonsoft.Json.JsonProperty("disk", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Disk { get; set; }
    
    
    }
    
    /// <summary>Options while updating the sink</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class UpdateOptions 
    {
        /// <summary>Whether or not to update the auth data</summary>
        [Newtonsoft.Json.JsonProperty("update-auth-data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UpdateAuthData { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class WindowConfig 
    {
        [Newtonsoft.Json.JsonProperty("windowLengthCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? WindowLengthCount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("windowLengthDurationMs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? WindowLengthDurationMs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("slidingIntervalCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SlidingIntervalCount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("slidingIntervalDurationMs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? SlidingIntervalDurationMs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("lateDataTopic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LateDataTopic { get; set; }
    
        [Newtonsoft.Json.JsonProperty("maxLagMs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? MaxLagMs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("watermarkEmitIntervalMs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? WatermarkEmitIntervalMs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("timestampExtractorClassName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TimestampExtractorClassName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("actualWindowFunctionClassName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActualWindowFunctionClassName { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public enum CryptoConfigProducerCryptoFailureAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"FAIL")]
        FAIL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SEND")]
        SEND = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public enum CryptoConfigConsumerCryptoFailureAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"FAIL")]
        FAIL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DISCARD")]
        DISCARD = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONSUME")]
        CONSUME = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public enum EncryptionContextCompressionType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NONE")]
        NONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LZ4")]
        LZ4 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ZLIB")]
        ZLIB = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ZSTD")]
        ZSTD = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SNAPPY")]
        SNAPPY = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public enum FunctionConfigProcessingGuarantees
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ATLEAST_ONCE")]
        ATLEAST_ONCE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ATMOST_ONCE")]
        ATMOST_ONCE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EFFECTIVELY_ONCE")]
        EFFECTIVELY_ONCE = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public enum FunctionConfigRuntime
    {
        [System.Runtime.Serialization.EnumMember(Value = @"JAVA")]
        JAVA = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PYTHON")]
        PYTHON = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GO")]
        GO = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.3.11.0 (Newtonsoft.Json v12.0.0.2)")]
    public enum FunctionConfigSubscriptionPosition
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Latest")]
        Latest = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Earliest")]
        Earliest = 1,
    
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.10.8.0 (NJsonSchema v10.3.11.0 (Newtonsoft.Json v12.0.0.2))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response; 
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.10.8.0 (NJsonSchema v10.3.11.0 (Newtonsoft.Json v12.0.0.2))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108